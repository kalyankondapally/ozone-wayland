From ecc8470b3995a804a3fb52edb46b5cb43cb059bb Mon Sep 17 00:00:00 2001
From: Kondapally Kalyan <kalyan.kondapally@intel.com>
Date: Mon, 11 Nov 2013 01:05:06 +0200
Subject: [PATCH 11/11] WIP: Add initial support for OutputConfigurator with
 Ozone platform.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Output Configurator is responsible for output manipulation on Chrome-OS
with X11. Itâ€™s thus only included in X11 builds. we need  an ozone
implementation for supporting the same with Ozone. This patch tries to
seperate X11 dependencies and ability to provide a custom implmentation
when on Ozone platform.
---
 ash/ash.gyp                                        |    8 -
 .../display_change_observer_chromeos_unittest.cc   |    1 -
 ash/shell.cc                                       |   50 +-
 ash/shell.h                                        |    6 +-
 chromeos/chromeos.gyp                              |   22 +-
 chromeos/display/output_configurator.cc            |  125 +---
 chromeos/display/output_configurator.h             |   62 +-
 chromeos/display/output_configurator_ozone.cc      |   34 ++
 chromeos/display/output_configurator_ozone.h       |   34 ++
 chromeos/display/output_configurator_ozone_dri.cc  |   44 ++
 chromeos/display/output_configurator_ozone_dri.h   |   30 +
 chromeos/display/output_configurator_unittest.cc   |   57 +-
 chromeos/display/output_configurator_x11.cc        |  137 +++++
 chromeos/display/output_configurator_x11.h         |   41 ++
 chromeos/display/output_util.cc                    |   75 ---
 chromeos/display/output_util.h                     |   39 +-
 chromeos/display/output_util_dri.cc                |   22 +
 chromeos/display/output_util_unittest.cc           |    2 -
 chromeos/display/output_util_x11.cc                |   77 +++
 .../display/real_output_configurator_delegate.cc   |  614 -------------------
 .../display/real_output_configurator_delegate.h    |  100 ----
 .../real_output_configurator_delegate_dri.cc       |   96 +++
 .../real_output_configurator_delegate_dri.h        |   54 ++
 .../real_output_configurator_delegate_x11.cc       |  616 ++++++++++++++++++++
 .../real_output_configurator_delegate_x11.h        |  100 ++++
 ui/ozone/ozone_platform.cc                         |    4 +
 ui/ozone/ozone_platform.h                          |    6 +
 ui/ozone/platform/dri/ozone_platform_dri.cc        |    7 +
 ui/ozone/platform/dri/ozone_platform_dri.h         |   10 +
 ui/ozone/platform/test/ozone_platform_test.cc      |    7 +
 ui/ozone/platform/test/ozone_platform_test.h       |   11 +-
 31 files changed, 1470 insertions(+), 1021 deletions(-)
 create mode 100644 chromeos/display/output_configurator_ozone.cc
 create mode 100644 chromeos/display/output_configurator_ozone.h
 create mode 100644 chromeos/display/output_configurator_ozone_dri.cc
 create mode 100644 chromeos/display/output_configurator_ozone_dri.h
 create mode 100644 chromeos/display/output_configurator_x11.cc
 create mode 100644 chromeos/display/output_configurator_x11.h
 create mode 100644 chromeos/display/output_util_dri.cc
 create mode 100644 chromeos/display/output_util_x11.cc
 delete mode 100644 chromeos/display/real_output_configurator_delegate.cc
 delete mode 100644 chromeos/display/real_output_configurator_delegate.h
 create mode 100644 chromeos/display/real_output_configurator_delegate_dri.cc
 create mode 100644 chromeos/display/real_output_configurator_delegate_dri.h
 create mode 100644 chromeos/display/real_output_configurator_delegate_x11.cc
 create mode 100644 chromeos/display/real_output_configurator_delegate_x11.h

diff --git a/ash/ash.gyp b/ash/ash.gyp
index b1022ae..a885599 100644
--- a/ash/ash.gyp
+++ b/ash/ash.gyp
@@ -598,14 +598,6 @@
             ['exclude', 'system/monitor/tray_monitor.h'],
           ],
         }],
-        ['use_x11!=1', {
-          'sources/': [
-            ['exclude', 'display/display_change_observer_chromeos.cc'],
-            ['exclude', 'display/display_change_observer_chromeos.h'],
-            ['exclude', 'display/display_error_observer_chromeos.cc'],
-            ['exclude', 'display/display_error_observer_chromeos.h'],
-          ],
-        }],
         ['chromeos==1', {
           'dependencies': [
             '../chromeos/chromeos.gyp:chromeos',
diff --git a/chromeos/chromeos.gyp b/chromeos/chromeos.gyp
index 778b016..218e0d8 100644
--- a/chromeos/chromeos.gyp
+++ b/chromeos/chromeos.gyp
@@ -206,10 +206,20 @@
         'disks/disk_mount_manager.h',
         'display/output_configurator.cc',
         'display/output_configurator.h',
+        'display/output_configurator_x11.cc',
+        'display/output_configurator_x11.h',
+        'display/output_configurator_ozone.cc',
+        'display/output_configurator_ozone.h',
+        'display/output_configurator_ozone_dri.cc',
+        'display/output_configurator_ozone_dri.h',
         'display/output_util.cc',
         'display/output_util.h',
-        'display/real_output_configurator_delegate.cc',
-        'display/real_output_configurator_delegate.h',
+        'display/output_util_x11.cc',
+        'display/output_util_dri.cc',
+        'display/real_output_configurator_delegate_x11.cc',
+        'display/real_output_configurator_delegate_x11.h',
+        'display/real_output_configurator_delegate_dri.cc',
+        'display/real_output_configurator_delegate_dri.h',
         'ime/candidate_window.cc',
         'ime/candidate_window.h',
         'ime/component_extension_ime_manager.cc',
@@ -359,14 +369,6 @@
           'sources!': [
             'ime/xkeyboard.cc',
             'ime/xkeyboard.h',
-            'display/output_configurator.cc',
-            'display/output_configurator.h',
-            'display/output_util.cc',
-            'display/output_util.h',
-            'display/real_output_configurator_delegate.cc',
-            'display/real_output_configurator_delegate.h',
-            'ime/xkeyboard.cc',
-            'ime/xkeyboard.h',
           ],
         }],
       ],
diff --git a/chromeos/display/output_configurator.cc b/chromeos/display/output_configurator.cc
index 1a3cc31..6ce5cc3 100644
--- a/chromeos/display/output_configurator.cc
+++ b/chromeos/display/output_configurator.cc
@@ -4,18 +4,16 @@
 
 #include "chromeos/display/output_configurator.h"
 
-#include <X11/Xlib.h>
-#include <X11/extensions/Xrandr.h>
-#include <X11/extensions/XInput2.h>
-
 #include "base/bind.h"
 #include "base/logging.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/stringprintf.h"
 #include "base/sys_info.h"
 #include "base/time/time.h"
-#include "chromeos/display/output_util.h"
-#include "chromeos/display/real_output_configurator_delegate.h"
+
+#ifndef None
+#define None 0L
+#endif
 
 namespace chromeos {
 
@@ -164,37 +162,6 @@ OutputConfigurator::OutputSnapshot::OutputSnapshot()
 
 OutputConfigurator::OutputSnapshot::~OutputSnapshot() {}
 
-void OutputConfigurator::TestApi::SendScreenChangeEvent() {
-  XRRScreenChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRScreenChangeNotify;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
-}
-
-void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
-                                                        RRCrtc crtc,
-                                                        RRMode mode,
-                                                        bool connected) {
-  XRROutputChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRNotify;
-  event.subtype = RRNotify_OutputChange;
-  event.output = output;
-  event.crtc = crtc;
-  event.mode = mode;
-  event.connection = connected ? RR_Connected : RR_Disconnected;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
-}
-
-bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
-  if (configurator_->configure_timer_.get() &&
-      configurator_->configure_timer_->IsRunning()) {
-    configurator_->configure_timer_.reset();
-    configurator_->ConfigureOutputs();
-    return true;
-  } else {
-    return false;
-  }
-}
-
 // static
 const OutputConfigurator::ModeInfo* OutputConfigurator::GetModeInfo(
     const OutputSnapshot& output,
@@ -245,12 +212,22 @@ RRMode OutputConfigurator::FindOutputModeMatchingSize(
   return found;
 }
 
+bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
+  if (configurator_->configure_timer_.get() &&
+      configurator_->configure_timer_->IsRunning()) {
+    configurator_->configure_timer_.reset();
+    configurator_->ConfigureOutputs();
+    return true;
+  } else {
+    return false;
+  }
+}
+
 OutputConfigurator::OutputConfigurator()
     : state_controller_(NULL),
       mirroring_controller_(NULL),
       is_panel_fitting_enabled_(false),
       configure_display_(base::SysInfo::IsRunningOnChromeOS()),
-      xrandr_event_base_(0),
       output_state_(STATE_INVALID),
       power_state_(DISPLAY_POWER_ALL_ON),
       next_output_protection_client_id_(1) {
@@ -274,7 +251,7 @@ void OutputConfigurator::Init(bool is_panel_fitting_enabled) {
     return;
 
   if (!delegate_)
-    delegate_.reset(new RealOutputConfiguratorDelegate());
+    delegate_.reset(CreateDelegate());
 }
 
 void OutputConfigurator::Start(uint32 background_color_argb) {
@@ -282,7 +259,7 @@ void OutputConfigurator::Start(uint32 background_color_argb) {
     return;
 
   delegate_->GrabServer();
-  delegate_->InitXRandRExtension(&xrandr_event_base_);
+  InitializeResources();
 
   UpdateCachedOutputs();
   if (cached_outputs_.size() > 1 && background_color_argb)
@@ -457,6 +434,10 @@ bool OutputConfigurator::EnableOutputProtection(
   return true;
 }
 
+void OutputConfigurator::InitializeResources() {
+  NOTIMPLEMENTED();
+}
+
 void OutputConfigurator::Stop() {
   configure_display_ = false;
 }
@@ -526,73 +507,13 @@ bool OutputConfigurator::SetDisplayMode(OutputState new_state) {
 }
 
 bool OutputConfigurator::Dispatch(const base::NativeEvent& event) {
-  if (!configure_display_)
-    return true;
-
-  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
-    VLOG(1) << "Received RRScreenChangeNotify event";
-    delegate_->UpdateXRandRConfiguration(event);
-    return true;
-  }
-
-  // Bail out early for everything except RRNotify_OutputChange events
-  // about an output getting connected or disconnected.
-  if (event->type - xrandr_event_base_ != RRNotify)
-    return true;
-  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
-  if (notify_event->subtype != RRNotify_OutputChange)
-    return true;
-  const XRROutputChangeNotifyEvent* output_change_event =
-      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
-  const int action = output_change_event->connection;
-  if (action != RR_Connected && action != RR_Disconnected)
-    return true;
-
-  const bool connected = (action == RR_Connected);
-  VLOG(1) << "Received RRNotify_OutputChange event:"
-          << " output=" << output_change_event->output
-          << " crtc=" << output_change_event->crtc
-          << " mode=" << output_change_event->mode
-          << " action=" << (connected ? "connected" : "disconnected");
-
-  bool found_changed_output = false;
-  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs_.begin();
-       it != cached_outputs_.end(); ++it) {
-    if (it->output == output_change_event->output) {
-      if (connected && it->crtc == output_change_event->crtc &&
-          it->current_mode == output_change_event->mode) {
-        VLOG(1) << "Ignoring event describing already-cached state";
-        return true;
-      }
-      found_changed_output = true;
-      break;
-    }
-  }
-
-  if (!connected && !found_changed_output) {
-    VLOG(1) << "Ignoring event describing already-disconnected output";
-    return true;
-  }
-
-  // Connecting/disconnecting a display may generate multiple events. Defer
-  // configuring outputs to avoid grabbing X and configuring displays
-  // multiple times.
-  ScheduleConfigureOutputs();
+  NOTIMPLEMENTED();
   return true;
 }
 
 base::EventStatus OutputConfigurator::WillProcessEvent(
     const base::NativeEvent& event) {
-  // XI_HierarchyChanged events are special. There is no window associated with
-  // these events. So process them directly from here.
-  if (configure_display_ && event->type == GenericEvent &&
-      event->xgeneric.evtype == XI_HierarchyChanged) {
-    VLOG(1) << "Received XI_HierarchyChanged event";
-    // Defer configuring outputs to not stall event processing.
-    // This also takes care of same event being received twice.
-    ScheduleConfigureOutputs();
-  }
-
+  NOTIMPLEMENTED();
   return base::EVENT_CONTINUE;
 }
 
diff --git a/chromeos/display/output_configurator.h b/chromeos/display/output_configurator.h
index ef5085e..0b4bd90 100644
--- a/chromeos/display/output_configurator.h
+++ b/chromeos/display/output_configurator.h
@@ -20,10 +20,10 @@
 
 // Forward declarations for Xlib and Xrandr.
 // This is so unused X definitions don't pollute the namespace.
-typedef unsigned long XID;
-typedef XID RROutput;
-typedef XID RRCrtc;
-typedef XID RRMode;
+typedef unsigned long OUTPUTID;
+typedef OUTPUTID RROutput;
+typedef OUTPUTID RRCrtc;
+typedef OUTPUTID RRMode;
 
 namespace chromeos {
 
@@ -195,17 +195,17 @@ class CHROMEOS_EXPORT OutputConfigurator
    public:
     virtual ~Delegate() {}
 
-    // Initializes the XRandR extension, saving the base event ID to
-    // |event_base|.
-    virtual void InitXRandRExtension(int* event_base) = 0;
+    // Initializes any native resources, returns the base event ID.
+    virtual int InitResources() = 0;
 
-    // Tells XRandR to update its configuration in response to |event|, an
-    // RRScreenChangeNotify event.
-    virtual void UpdateXRandRConfiguration(const base::NativeEvent& event) = 0;
+    // Inform platform to update its configuration in response to |event|,
+    // an native ScreenChangeNotification event.
+    virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) = 0;
 
-    // Grabs the X server and refreshes XRandR-related resources.  While
-    // the server is grabbed, other clients are blocked.  Must be balanced
-    // by a call to UngrabServer().
+    // Configurator will call this api before fetching output properties. The
+    // delegate needs to ensure that no other client is able to update the
+    // display until UngrabServer is called.
     virtual void GrabServer() = 0;
 
     // Ungrabs the server and frees XRandR-related resources.
@@ -266,9 +266,9 @@ class CHROMEOS_EXPORT OutputConfigurator
   // Helper class used by tests.
   class TestApi {
    public:
-    TestApi(OutputConfigurator* configurator, int xrandr_event_base)
+    TestApi(OutputConfigurator* configurator, int native_event_base)
         : configurator_(configurator),
-          xrandr_event_base_(xrandr_event_base) {}
+          native_event_base_(native_event_base) {}
     ~TestApi() {}
 
     const std::vector<OutputSnapshot>& cached_outputs() const {
@@ -291,7 +291,7 @@ class CHROMEOS_EXPORT OutputConfigurator
    private:
     OutputConfigurator* configurator_;  // not owned
 
-    int xrandr_event_base_;
+    int native_event_base_;
 
     DISALLOW_COPY_AND_ASSIGN(TestApi);
   };
@@ -383,6 +383,13 @@ class CHROMEOS_EXPORT OutputConfigurator
   void AddObserver(Observer* observer);
   void RemoveObserver(Observer* observer);
 
+  // This should be called to set OutputConfigurator as the dispatcher for root
+  // window or start listening to hierarchy changed events.
+  virtual void StartProcessingEvents() { }
+  // This should be called to remove OutputConfigurator as dispatcher for root
+  // window.
+  virtual void StopProcessingEvents() { }
+
   // Sets all the displays into pre-suspend mode; usually this means
   // configure them for their resume state. This allows faster resume on
   // machines where display configuration is slow.
@@ -427,6 +434,25 @@ class CHROMEOS_EXPORT OutputConfigurator
       int64 display_id,
       uint32_t desired_protection_mask);
 
+ protected:
+  // This is called before doing initial configuration of displays during
+  // startup i.e. from Start(). Any necessary native resources should be
+  // initialized here.
+  virtual void InitializeResources();
+
+  // Create Delegate to be used by the Configurator.
+  virtual Delegate* CreateDelegate() = 0;
+
+  // Returns cached outputs.
+  const std::vector<OutputSnapshot>& GetCachedOutputs() const {
+    return cached_outputs_;
+  }
+
+  // Returns delegate used by Configurator.
+  Delegate* GetDelegate() const { return delegate_.get(); }
+
+  bool HandleConfigureDisplay() const { return configure_display_; }
+
  private:
   // Mapping a display_id to a protection request bitmask.
   typedef std::map<int64, uint32_t> DisplayProtections;
@@ -517,10 +543,6 @@ class CHROMEOS_EXPORT OutputConfigurator
   // configuration to immediately fail without changing the state.
   bool configure_display_;
 
-  // The base of the event numbers used to represent XRandr events used in
-  // decoding events regarding output add/remove.
-  int xrandr_event_base_;
-
   // The current display state.
   OutputState output_state_;
 
diff --git a/chromeos/display/output_configurator_ozone.cc b/chromeos/display/output_configurator_ozone.cc
new file mode 100644
index 0000000..44a2c84
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_ozone.h"
+
+namespace chromeos {
+
+// static
+OutputConfigurator* OutputConfiguratorOzone::impl_ = NULL;
+
+OutputConfiguratorOzone::OutputConfiguratorOzone()
+    : OutputConfigurator() {
+}
+
+OutputConfiguratorOzone::~OutputConfiguratorOzone() {
+
+}
+
+OutputConfigurator* OutputConfiguratorOzone::GetInstance() {
+  CHECK(impl_) << "No OutputConfiguratorOzone implementation set.";
+  return impl_;
+}
+
+void OutputConfiguratorOzone::SetInstance(OutputConfigurator* impl) {
+  impl_ = impl;
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorOzone::CreateDelegate() {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_configurator_ozone.h b/chromeos/display/output_configurator_ozone.h
new file mode 100644
index 0000000..f9b9749
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
+
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+
+class CHROMEOS_EXPORT OutputConfiguratorOzone : public OutputConfigurator {
+ public:
+  OutputConfiguratorOzone();
+  virtual ~OutputConfiguratorOzone();
+
+  // Returns the static instance last set using SetInstance().
+  static OutputConfigurator* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(OutputConfigurator*);
+
+ protected:
+  virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+ private:
+  static OutputConfigurator* impl_;  // not owned
+
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorOzone);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
diff --git a/chromeos/display/output_configurator_ozone_dri.cc b/chromeos/display/output_configurator_ozone_dri.cc
new file mode 100644
index 0000000..f2458f8
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone_dri.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#include "chromeos/display/real_output_configurator_delegate_dri.h"
+
+#include "base/message_loop/message_pump_ozone.h"
+
+namespace chromeos {
+
+void OutputConfigurator::TestApi::SendScreenChangeEvent() {
+  NOTIMPLEMENTED();
+}
+
+void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
+                                                        RRCrtc crtc,
+                                                        RRMode mode,
+                                                        bool connected) {
+  NOTIMPLEMENTED();
+}
+
+OutputConfiguratorOzoneDri::OutputConfiguratorOzoneDri()
+    : OutputConfiguratorOzone() {
+}
+
+OutputConfiguratorOzoneDri::~OutputConfiguratorOzoneDri() {
+
+}
+
+void OutputConfiguratorOzoneDri::StartProcessingEvents() {
+  base::MessagePumpOzone::Current()->AddObserver(this);
+}
+
+void OutputConfiguratorOzoneDri::StopProcessingEvents() {
+  base::MessagePumpOzone::Current()->RemoveObserver(this);
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorOzoneDri::CreateDelegate() {
+  return new RealOutputConfiguratorDelegateDri();
+}
+
+}  // namespace chromeos
+
diff --git a/chromeos/display/output_configurator_ozone_dri.h b/chromeos/display/output_configurator_ozone_dri.h
new file mode 100644
index 0000000..e23628b
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone_dri.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+
+#include "chromeos/display/output_configurator_ozone.h"
+
+namespace chromeos {
+
+class CHROMEOS_EXPORT OutputConfiguratorOzoneDri
+    : public OutputConfiguratorOzone {
+ public:
+  OutputConfiguratorOzoneDri();
+  virtual ~OutputConfiguratorOzoneDri();
+  virtual void StartProcessingEvents() OVERRIDE;
+  virtual void StopProcessingEvents() OVERRIDE;
+
+protected:
+ virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorOzoneDri);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+
diff --git a/chromeos/display/output_configurator_x11.cc b/chromeos/display/output_configurator_x11.cc
new file mode 100644
index 0000000..0d48c44
--- /dev/null
+++ b/chromeos/display/output_configurator_x11.cc
@@ -0,0 +1,137 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_x11.h"
+
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/extensions/XInput2.h>
+
+#include "chromeos/display/real_output_configurator_delegate.h"
+#include "base/message_loop/message_pump_x11.h"
+
+namespace chromeos {
+
+void OutputConfigurator::TestApi::SendScreenChangeEvent() {
+  XRRScreenChangeNotifyEvent event = {0};
+  event.type = native_event_base_ + RRScreenChangeNotify;
+  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
+}
+
+void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
+                                                        RRCrtc crtc,
+                                                        RRMode mode,
+                                                        bool connected) {
+  XRROutputChangeNotifyEvent event = {0};
+  event.type = native_event_base_ + RRNotify;
+  event.subtype = RRNotify_OutputChange;
+  event.output = output;
+  event.crtc = crtc;
+  event.mode = mode;
+  event.connection = connected ? RR_Connected : RR_Disconnected;
+  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
+}
+
+OutputConfiguratorX11::OutputConfiguratorX11()
+    : OutputConfigurator(),
+      xrandr_event_base_(0) {
+}
+
+OutputConfiguratorX11::~OutputConfiguratorX11() {
+
+}
+
+void OutputConfiguratorX11::StartProcessingEvents() {
+  base::MessagePumpX11::Current()->AddDispatcherForRootWindow(this);
+  // We can't do this with a root window listener because XI_HierarchyChanged
+  // messages don't have a target window.
+  base::MessagePumpX11::Current()->AddObserver(this);
+}
+
+void OutputConfiguratorX11::StopProcessingEvents() {
+  base::MessagePumpX11::Current()->RemoveDispatcherForRootWindow(this);
+  base::MessagePumpX11::Current()->RemoveObserver(this);
+}
+
+void OutputConfiguratorX11::InitializeResources() {
+  xrandr_event_base_ = GetDelegate()->InitResources();
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorX11::CreateDelegate() {
+  return new RealOutputConfiguratorDelegate();
+}
+
+bool OutputConfiguratorX11::Dispatch(const base::NativeEvent& event) {
+  if (!HandleConfigureDisplay())
+    return true;
+
+  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
+      VLOG(1) << "Received RRScreenChangeNotify event";
+      GetDelegate()->HandleScreenChangeNotification(event);
+      return true;
+  }
+
+  // Bail out early for everything except RRNotify_OutputChange events
+  // about an output getting connected or disconnected.
+  if (event->type - xrandr_event_base_ != RRNotify)
+    return true;
+  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
+  if (notify_event->subtype != RRNotify_OutputChange)
+    return true;
+  const XRROutputChangeNotifyEvent* output_change_event =
+      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
+  const int action = output_change_event->connection;
+  if (action != RR_Connected && action != RR_Disconnected)
+    return true;
+
+  const bool connected = (action == RR_Connected);
+  VLOG(1) << "Received RRNotify_OutputChange event:"
+          << " output=" << output_change_event->output
+          << " crtc=" << output_change_event->crtc
+          << " mode=" << output_change_event->mode
+          << " action=" << (connected ? "connected" : "disconnected");
+
+  bool found_changed_output = false;
+  const std::vector<OutputSnapshot>& cached_outputs = GetCachedOutputs();
+  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs.begin();
+       it != cached_outputs.end(); ++it) {
+    if (it->output == output_change_event->output) {
+      if (connected && it->crtc == output_change_event->crtc &&
+          it->current_mode == output_change_event->mode) {
+        VLOG(1) << "Ignoring event describing already-cached state";
+        return true;
+      }
+      found_changed_output = true;
+      break;
+    }
+  }
+
+  if (!connected && !found_changed_output) {
+    VLOG(1) << "Ignoring event describing already-disconnected output";
+    return true;
+  }
+
+  // Connecting/disconnecting a display may generate multiple events. Defer
+  // configuring outputs to avoid grabbing X and configuring displays
+  // multiple times.
+  ScheduleConfigureOutputs();
+  return true;
+}
+
+base::EventStatus OutputConfiguratorX11::WillProcessEvent(
+    const base::NativeEvent& event) {
+  // XI_HierarchyChanged events are special. There is no window associated with
+  // these events. So process them directly from here.
+  if (HandleConfigureDisplay() && event->type == GenericEvent &&
+      event->xgeneric.evtype == XI_HierarchyChanged) {
+    VLOG(1) << "Received XI_HierarchyChanged event";
+    // Defer configuring outputs to not stall event processing.
+    // This also takes care of same event being received twice.
+    ScheduleConfigureOutputs();
+  }
+
+  return base::EVENT_CONTINUE;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_configurator_x11.h b/chromeos/display/output_configurator_x11.h
new file mode 100644
index 0000000..541fa84
--- /dev/null
+++ b/chromeos/display/output_configurator_x11.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
+
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+// This class interacts directly with the underlying Xrandr API to manipulate
+// CTRCs and Outputs.
+
+class CHROMEOS_EXPORT OutputConfiguratorX11 : public OutputConfigurator {
+ public:
+
+  OutputConfiguratorX11();
+  virtual ~OutputConfiguratorX11();
+
+  virtual void StartProcessingEvents() OVERRIDE;
+  virtual void StopProcessingEvents() OVERRIDE;
+
+  // Overridden from base::MessagePumpObserver:
+  virtual base::EventStatus WillProcessEvent(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual bool Dispatch(const base::NativeEvent& event) OVERRIDE;
+
+ protected:
+  virtual void InitializeResources() OVERRIDE;
+  virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+  // The base of the event numbers used to represent XRandr events used in
+  // decoding events regarding output add/remove.
+  int xrandr_event_base_;
+
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorX11);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
diff --git a/chromeos/display/output_util.cc b/chromeos/display/output_util.cc
index a1485b4..b920ded 100644
--- a/chromeos/display/output_util.cc
+++ b/chromeos/display/output_util.cc
@@ -3,13 +3,7 @@
 // found in the LICENSE file.
 
 #include "chromeos/display/output_util.h"
-
-#include <X11/extensions/Xrandr.h>
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-
 #include "base/strings/string_util.h"
-#include "base/x11/edid_parser_x11.h"
 
 namespace chromeos {
 namespace {
@@ -18,44 +12,8 @@ namespace {
 const char kInternal_LVDS[] = "LVDS";
 const char kInternal_eDP[] = "eDP";
 const char kInternal_DSI[] = "DSI";
-
-// Gets some useful data from the specified output device, such like
-// manufacturer's ID, product code, and human readable name. Returns false if it
-// fails to get those data and doesn't touch manufacturer ID/product code/name.
-// NULL can be passed for unwanted output parameters.
-bool GetOutputDeviceData(XID output,
-                         uint16* manufacturer_id,
-                         std::string* human_readable_name) {
-  unsigned long nitems = 0;
-  unsigned char *prop = NULL;
-  if (!base::GetEDIDProperty(output, &nitems, &prop))
-    return false;
-
-  bool result = base::ParseOutputDeviceData(
-      prop, nitems, manufacturer_id, human_readable_name);
-  XFree(prop);
-  return result;
-}
-
 }  // namespace
 
-std::string GetDisplayName(XID output_id) {
-  std::string display_name;
-  GetOutputDeviceData(output_id, NULL, &display_name);
-  return display_name;
-}
-
-bool GetOutputOverscanFlag(XID output, bool* flag) {
-  unsigned long nitems = 0;
-  unsigned char *prop = NULL;
-  if (!base::GetEDIDProperty(output, &nitems, &prop))
-    return false;
-
-  bool found = ParseOutputOverscanFlag(prop, nitems, flag);
-  XFree(prop);
-  return found;
-}
-
 bool ParseOutputOverscanFlag(const unsigned char* prop,
                              unsigned long nitems,
                              bool *flag) {
@@ -140,37 +98,4 @@ bool IsInternalOutputName(const std::string& name) {
       name.find(kInternal_DSI) == 0;
 }
 
-const XRRModeInfo* FindXRRModeInfo(const XRRScreenResources* screen_resources,
-                                   XID current_mode) {
-  for (int m = 0; m < screen_resources->nmode; m++) {
-    XRRModeInfo *mode = &screen_resources->modes[m];
-    if (mode->id == current_mode)
-      return mode;
-  }
-  return NULL;
-}
-
-namespace test {
-
-XRRModeInfo CreateModeInfo(int id,
-                           int width,
-                           int height,
-                           bool interlaced,
-                           float refresh_rate) {
-  XRRModeInfo mode_info = {0};
-  mode_info.id = id;
-  mode_info.width = width;
-  mode_info.height = height;
-  if (interlaced)
-    mode_info.modeFlags = RR_Interlace;
-  if (refresh_rate != 0.0f) {
-    mode_info.hTotal = 1;
-    mode_info.vTotal = 1;
-    mode_info.dotClock = refresh_rate;
-  }
-  return mode_info;
-}
-
-}  // namespace test
-
 }  // namespace chromeos
diff --git a/chromeos/display/output_util.h b/chromeos/display/output_util.h
index 3c7a49f..41fc620 100644
--- a/chromeos/display/output_util.h
+++ b/chromeos/display/output_util.h
@@ -12,26 +12,19 @@
 
 // Forward declarations for Xlib and Xrandr.
 // This is so unused X definitions don't pollute the namespace.
-typedef unsigned long XID;
-typedef XID RRMode;
-struct _XRRModeInfo;
-typedef _XRRModeInfo XRRModeInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
+typedef unsigned long OUTPUTID;
 
 namespace chromeos {
 
 // Generates the human readable string from EDID obtained for |output|.
-CHROMEOS_EXPORT std::string GetDisplayName(XID output);
+CHROMEOS_EXPORT std::string GetDisplayName(OUTPUTID output);
 
 // Gets the overscan flag from |output| and stores to |flag|. Returns true if
 // the flag is found. Otherwise returns false and doesn't touch |flag|. The
 // output will produce overscan if |flag| is set to true, but the output may
 // still produce overscan even though it returns true and |flag| is set to
 // false.
-CHROMEOS_EXPORT bool GetOutputOverscanFlag(XID output, bool* flag);
+CHROMEOS_EXPORT bool GetOutputOverscanFlag(OUTPUTID output, bool* flag);
 
 // Parses |prop| as EDID data and stores the overscan flag to |flag|. Returns
 // true if the flag is found. This is exported for x11_util_unittest.cc.
@@ -42,32 +35,6 @@ CHROMEOS_EXPORT bool ParseOutputOverscanFlag(const unsigned char* prop,
 // Returns true if an output named |name| is an internal display.
 CHROMEOS_EXPORT bool IsInternalOutputName(const std::string& name);
 
-// Find a XRRModeInfo that matches |mode|.
-CHROMEOS_EXPORT const XRRModeInfo* FindXRRModeInfo(
-    const XRRScreenResources* screen_resources,
-    XID mode);
-
-// Find a mode that matches the given size with highest refresh
-// rate. Non-interlaced mode takes precedence, so non-interlaced mode
-// with a lower refresh rate will be used even if there is an interlaced
-// mode with a higher refresh rate.
-CHROMEOS_EXPORT RRMode FindOutputModeMatchingSize(
-    const XRRScreenResources* screen_resources,
-    const XRROutputInfo* output_info,
-    size_t width,
-    size_t height);
-
-namespace test {
-
-// Creates XRRModeInfo for unit tests.
-CHROMEOS_EXPORT XRRModeInfo CreateModeInfo(int id,
-                                           int width,
-                                           int height,
-                                           bool interlaced,
-                                           float refresh_rate);
-
-}  // namespace test
-
 }  // namespace chromeos
 
 #endif  // CHROMEOS_DISPLAY_OUTPUT_UTIL_H_
diff --git a/chromeos/display/output_util_dri.cc b/chromeos/display/output_util_dri.cc
new file mode 100644
index 0000000..ba59fa6
--- /dev/null
+++ b/chromeos/display/output_util_dri.cc
@@ -0,0 +1,22 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_util.h"
+
+#include "base/strings/string_util.h"
+
+namespace chromeos {
+
+std::string GetDisplayName(OUTPUTID output_id) {
+  std::string display_name;
+  NOTIMPLEMENTED();
+  return display_name;
+}
+
+bool GetOutputOverscanFlag(OUTPUTID output, bool* flag) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_util_unittest.cc b/chromeos/display/output_util_unittest.cc
index 1229b4f..e8dc584 100644
--- a/chromeos/display/output_util_unittest.cc
+++ b/chromeos/display/output_util_unittest.cc
@@ -7,8 +7,6 @@
 #include "base/memory/scoped_ptr.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#include <X11/extensions/Xrandr.h>
-
 namespace chromeos {
 
 namespace {
diff --git a/chromeos/display/output_util_x11.cc b/chromeos/display/output_util_x11.cc
new file mode 100644
index 0000000..57a2119
--- /dev/null
+++ b/chromeos/display/output_util_x11.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_util.h"
+
+#include <X11/extensions/Xrandr.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+
+#include "base/strings/string_util.h"
+#include "base/x11/edid_parser_x11.h"
+
+namespace chromeos {
+namespace {
+// Gets some useful data from the specified output device, such like
+// manufacturer's ID, product code, and human readable name. Returns false if it
+// fails to get those data and doesn't touch manufacturer ID/product code/name.
+// NULL can be passed for unwanted output parameters.
+bool GetOutputDeviceData(OUTPUTID output,
+                         uint16* manufacturer_id,
+                         std::string* human_readable_name) {
+  unsigned long nitems = 0;
+  unsigned char *prop = NULL;
+  if (!base::GetEDIDProperty(output, &nitems, &prop))
+    return false;
+
+  bool result = base::ParseOutputDeviceData(
+      prop, nitems, manufacturer_id, human_readable_name);
+  XFree(prop);
+  return result;
+}
+
+}  // namespace
+
+std::string GetDisplayName(OUTPUTID output_id) {
+  std::string display_name;
+  GetOutputDeviceData(output_id, NULL, &display_name);
+  return display_name;
+}
+
+bool GetOutputOverscanFlag(OUTPUTID output, bool* flag) {
+  unsigned long nitems = 0;
+  unsigned char *prop = NULL;
+  if (!base::GetEDIDProperty(output, &nitems, &prop))
+    return false;
+
+  bool found = ParseOutputOverscanFlag(prop, nitems, flag);
+  XFree(prop);
+  return found;
+}
+
+namespace test {
+
+XRRModeInfo CreateModeInfo(int id,
+                           int width,
+                           int height,
+                           bool interlaced,
+                           float refresh_rate) {
+  XRRModeInfo mode_info = {0};
+  mode_info.id = id;
+  mode_info.width = width;
+  mode_info.height = height;
+  if (interlaced)
+    mode_info.modeFlags = RR_Interlace;
+  if (refresh_rate != 0.0f) {
+    mode_info.hTotal = 1;
+    mode_info.vTotal = 1;
+    mode_info.dotClock = refresh_rate;
+  }
+  return mode_info;
+}
+
+}  // namespace test
+
+}  // namespace chromeos
+
diff --git a/chromeos/display/real_output_configurator_delegate.cc b/chromeos/display/real_output_configurator_delegate.cc
deleted file mode 100644
index 5bb4757..0000000
--- a/chromeos/display/real_output_configurator_delegate.cc
+++ /dev/null
@@ -1,614 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chromeos/display/real_output_configurator_delegate.h"
-
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-#include <X11/extensions/dpms.h>
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XInput2.h>
-#include <X11/extensions/Xrandr.h>
-
-#include <cmath>
-#include <set>
-#include <utility>
-
-#include "base/logging.h"
-#include "base/message_loop/message_pump_x11.h"
-#include "base/x11/edid_parser_x11.h"
-#include "base/x11/x11_error_tracker.h"
-#include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/dbus/power_manager_client.h"
-#include "chromeos/display/output_util.h"
-
-namespace chromeos {
-
-namespace {
-
-// DPI measurements.
-const float kMmInInch = 25.4;
-const float kDpi96 = 96.0;
-const float kPixelsToMmScale = kMmInInch / kDpi96;
-
-// Prefixes of output name
-const char kOutputName_VGA[] = "VGA";
-const char kOutputName_HDMI[] = "HDMI";
-const char kOutputName_DVI[] = "DVI";
-const char kOutputName_DisplayPort[] = "DP";
-
-const char kContentProtectionAtomName[] = "Content Protection";
-const char kProtectionUndesiredAtomName[] = "Undesired";
-const char kProtectionDesiredAtomName[] = "Desired";
-const char kProtectionEnabledAtomName[] = "Enabled";
-
-bool IsInternalOutput(const XRROutputInfo* output_info) {
-  return IsInternalOutputName(std::string(output_info->name));
-}
-
-RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
-  return output_info->nmode > 0 ? output_info->modes[0] : None;
-}
-
-}  // namespace
-
-RealOutputConfiguratorDelegate::RealOutputConfiguratorDelegate()
-    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
-      window_(DefaultRootWindow(display_)),
-      screen_(NULL) {
-}
-
-RealOutputConfiguratorDelegate::~RealOutputConfiguratorDelegate() {
-}
-
-void RealOutputConfiguratorDelegate::InitXRandRExtension(int* event_base) {
-  int error_base_ignored = 0;
-  XRRQueryExtension(display_, event_base, &error_base_ignored);
-}
-
-void RealOutputConfiguratorDelegate::UpdateXRandRConfiguration(
-    const base::NativeEvent& event) {
-  XRRUpdateConfiguration(event);
-}
-
-void RealOutputConfiguratorDelegate::GrabServer() {
-  CHECK(!screen_) << "Server already grabbed";
-  XGrabServer(display_);
-  screen_ = XRRGetScreenResources(display_, window_);
-  CHECK(screen_);
-}
-
-void RealOutputConfiguratorDelegate::UngrabServer() {
-  CHECK(screen_) << "Server not grabbed";
-  XRRFreeScreenResources(screen_);
-  screen_ = NULL;
-  XUngrabServer(display_);
-}
-
-void RealOutputConfiguratorDelegate::SyncWithServer() {
-  XSync(display_, 0);
-}
-
-void RealOutputConfiguratorDelegate::SetBackgroundColor(uint32 color_argb) {
-  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
-  // same background color while configuring the display to minimize the
-  // duration of black screen at boot time. The background is filled with
-  // black later in ash::DisplayManager.  crbug.com/171050.
-  XSetWindowAttributes swa = {0};
-  XColor color;
-  Colormap colormap = DefaultColormap(display_, 0);
-  // XColor uses 16 bits per color.
-  color.red = (color_argb & 0x00FF0000) >> 8;
-  color.green = (color_argb & 0x0000FF00);
-  color.blue = (color_argb & 0x000000FF) << 8;
-  color.flags = DoRed | DoGreen | DoBlue;
-  XAllocColor(display_, colormap, &color);
-  swa.background_pixel = color.pixel;
-  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
-  XFreeColors(display_, colormap, &color.pixel, 1, 0);
-}
-
-void RealOutputConfiguratorDelegate::ForceDPMSOn() {
-  CHECK(DPMSEnable(display_));
-  CHECK(DPMSForceLevel(display_, DPMSModeOn));
-}
-
-std::vector<OutputConfigurator::OutputSnapshot>
-RealOutputConfiguratorDelegate::GetOutputs() {
-  CHECK(screen_) << "Server not grabbed";
-
-  std::vector<OutputConfigurator::OutputSnapshot> outputs;
-  RRCrtc last_used_crtc = None;
-
-  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
-    RROutput output_id = screen_->outputs[i];
-    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
-    if (output_info->connection == RR_Connected) {
-      OutputConfigurator::OutputSnapshot output = InitOutputSnapshot(
-          output_id, output_info, &last_used_crtc, i);
-      VLOG(2) << "Found display " << outputs.size() << ":"
-              << " output=" << output.output
-              << " crtc=" << output.crtc
-              << " current_mode=" << output.current_mode;
-      outputs.push_back(output);
-    }
-    XRRFreeOutputInfo(output_info);
-  }
-
-  GetTouchscreens(&outputs);
-  return outputs;
-}
-
-void RealOutputConfiguratorDelegate::AddOutputMode(RROutput output,
-                                                   RRMode mode) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "AddOutputMode: output=" << output << " mode=" << mode;
-  XRRAddOutputMode(display_, output, mode);
-}
-
-bool RealOutputConfiguratorDelegate::ConfigureCrtc(
-    RRCrtc crtc,
-    RRMode mode,
-    RROutput output,
-    int x,
-    int y) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "ConfigureCrtc: crtc=" << crtc
-          << " mode=" << mode
-          << " output=" << output
-          << " x=" << x
-          << " y=" << y;
-  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
-  // Status, which is typically 0 for failure and 1 for success. In
-  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
-  return XRRSetCrtcConfig(display_,
-                          screen_,
-                          crtc,
-                          CurrentTime,
-                          x,
-                          y,
-                          mode,
-                          RR_Rotate_0,
-                          (output && mode) ? &output : NULL,
-                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
-}
-
-void RealOutputConfiguratorDelegate::CreateFrameBuffer(
-    int width,
-    int height,
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  int current_width = DisplayWidth(display_, DefaultScreen(display_));
-  int current_height = DisplayHeight(display_, DefaultScreen(display_));
-  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
-          << " current=" << current_width << "x" << current_height;
-  if (width ==  current_width && height == current_height)
-    return;
-
-  DestroyUnusedCrtcs(outputs);
-  int mm_width = width * kPixelsToMmScale;
-  int mm_height = height * kPixelsToMmScale;
-  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
-}
-
-void RealOutputConfiguratorDelegate::ConfigureCTM(
-    int touch_device_id,
-    const OutputConfigurator::CoordinateTransformation& ctm) {
-  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
-          << " scale=" << ctm.x_scale << "x" << ctm.y_scale
-          << " offset=(" << ctm.x_offset << ", " << ctm.y_offset << ")";
-  int ndevices = 0;
-  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
-  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
-  Atom float_atom = XInternAtom(display_, "FLOAT", False);
-  if (ndevices == 1 && prop != None && float_atom != None) {
-    Atom type;
-    int format;
-    unsigned long num_items;
-    unsigned long bytes_after;
-    unsigned char* data = NULL;
-    // Verify that the property exists with correct format, type, etc.
-    int status = XIGetProperty(display_, info->deviceid, prop, 0, 0, False,
-        AnyPropertyType, &type, &format, &num_items, &bytes_after, &data);
-    if (data)
-      XFree(data);
-    if (status == Success && type == float_atom && format == 32) {
-      float value[3][3] = {
-          { ctm.x_scale,         0.0, ctm.x_offset },
-          {         0.0, ctm.y_scale, ctm.y_offset },
-          {         0.0,         0.0,          1.0 }
-      };
-      XIChangeProperty(display_,
-                       info->deviceid,
-                       prop,
-                       type,
-                       format,
-                       PropModeReplace,
-                       reinterpret_cast<unsigned char*>(value),
-                       9);
-    }
-  }
-  XIFreeDeviceInfo(info);
-}
-
-void RealOutputConfiguratorDelegate::SendProjectingStateToPowerManager(
-    bool projecting) {
-  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->
-      SetIsProjecting(projecting);
-}
-
-bool RealOutputConfiguratorDelegate::InitModeInfo(
-    RRMode mode,
-    OutputConfigurator::ModeInfo* mode_info) {
-  DCHECK(mode_info);
-  CHECK(screen_) << "Server not grabbed";
-  // TODO: Determine if we need to organize modes in a way which provides
-  // better than O(n) lookup time.  In many call sites, for example, the
-  // "next" mode is typically what we are looking for so using this
-  // helper might be too expensive.
-  for (int i = 0; i < screen_->nmode; ++i) {
-    if (mode == screen_->modes[i].id) {
-      const XRRModeInfo& info = screen_->modes[i];
-      mode_info->width = info.width;
-      mode_info->height = info.height;
-      mode_info->interlaced = info.modeFlags & RR_Interlace;
-      if (info.hTotal && info.vTotal) {
-        mode_info->refresh_rate = static_cast<float>(info.dotClock) /
-            (static_cast<float>(info.hTotal) *
-             static_cast<float>(info.vTotal));
-      } else {
-        mode_info->refresh_rate = 0.0f;
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
-OutputConfigurator::OutputSnapshot
-RealOutputConfiguratorDelegate::InitOutputSnapshot(
-    RROutput id,
-    XRROutputInfo* info,
-    RRCrtc* last_used_crtc,
-    int index) {
-  OutputConfigurator::OutputSnapshot output;
-  output.output = id;
-  output.width_mm = info->mm_width;
-  output.height_mm = info->mm_height;
-  output.has_display_id = base::GetDisplayId(id, index, &output.display_id);
-  output.is_internal = IsInternalOutput(info);
-  output.index = index;
-
-  // Use the index as a valid display ID even if the internal
-  // display doesn't have valid EDID because the index
-  // will never change.
-  if (!output.has_display_id && output.is_internal)
-    output.has_display_id = true;
-
-  if (info->crtc) {
-    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
-    output.current_mode = crtc_info->mode;
-    output.x = crtc_info->x;
-    output.y = crtc_info->y;
-    XRRFreeCrtcInfo(crtc_info);
-  }
-
-  // Assign a CRTC that isn't already in use.
-  for (int i = 0; i < info->ncrtc; ++i) {
-    if (info->crtcs[i] != *last_used_crtc) {
-      output.crtc = info->crtcs[i];
-      *last_used_crtc = output.crtc;
-      break;
-    }
-  }
-
-  output.native_mode = GetOutputNativeMode(info);
-  output.is_aspect_preserving_scaling = IsOutputAspectPreservingScaling(id);
-  output.touch_device_id = None;
-
-  for (int i = 0; i < info->nmode; ++i) {
-    const RRMode mode = info->modes[i];
-    OutputConfigurator::ModeInfo mode_info;
-    if (InitModeInfo(mode, &mode_info))
-      output.mode_infos.insert(std::make_pair(mode, mode_info));
-    else
-      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
-  }
-
-  std::string name(info->name);
-  if (output.is_internal) {
-    output.type = OUTPUT_TYPE_INTERNAL;
-  } else if (name.find(kOutputName_VGA) == 0) {
-    output.type = OUTPUT_TYPE_VGA;
-  } else if (name.find(kOutputName_HDMI) == 0) {
-    output.type = OUTPUT_TYPE_HDMI;
-  } else if (name.find(kOutputName_DVI) == 0) {
-    output.type = OUTPUT_TYPE_DVI;
-  } else if (name.find(kOutputName_DisplayPort) == 0) {
-    output.type = OUTPUT_TYPE_DISPLAYPORT;
-  } else {
-    LOG(ERROR) << "Unknown link type: " << name;
-    output.type = OUTPUT_TYPE_UNKNOWN;
-  }
-
-  return output;
-}
-
-bool RealOutputConfiguratorDelegate::GetHDCPState(RROutput id,
-                                                  HDCPState* state) {
-  unsigned char* values = NULL;
-  int actual_format = 0;
-  unsigned long nitems = 0;
-  unsigned long bytes_after = 0;
-  Atom actual_type = None;
-  int success = 0;
-  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
-  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
-
-  bool ok = true;
-  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
-  // output_util.cc)
-  success = XRRGetOutputProperty(display_, id, prop, 0, 100, False,
-                                 False, AnyPropertyType, &actual_type,
-                                 &actual_format, &nitems, &bytes_after,
-                                 &values);
-  if (actual_type == None) {
-    LOG(ERROR) << "Property '" << kContentProtectionAtomName
-               << "' does not exist";
-    ok = false;
-  } else if (success == Success && actual_type == XA_ATOM &&
-             actual_format == 32 && nitems == 1) {
-    Atom value = reinterpret_cast<Atom*>(values)[0];
-    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
-      *state = HDCP_STATE_UNDESIRED;
-    } else if (value == XInternAtom(display_, kProtectionDesiredAtomName,
-                                    False)) {
-      *state = HDCP_STATE_DESIRED;
-    } else if (value == XInternAtom(display_, kProtectionEnabledAtomName,
-                                    False)) {
-      *state = HDCP_STATE_ENABLED;
-    } else {
-      LOG(ERROR) << "Unknown " << kContentProtectionAtomName << " value: "
-                 << value;
-      ok = false;
-    }
-  } else {
-    LOG(ERROR) << "XRRGetOutputProperty failed";
-    ok = false;
-  }
-  if (values)
-    XFree(values);
-
-  VLOG(3) << "HDCP state: " << ok << "," << *state;
-  return ok;
-}
-
-bool RealOutputConfiguratorDelegate::SetHDCPState(RROutput id,
-                                                  HDCPState state) {
-  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
-  Atom value = None;
-  switch (state) {
-    case HDCP_STATE_UNDESIRED:
-      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
-      break;
-    case HDCP_STATE_DESIRED:
-      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
-      break;
-    default:
-      NOTREACHED() << "Invalid HDCP state: " << state;
-      return false;
-  }
-  base::X11ErrorTracker err_tracker;
-  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
-  XRRChangeOutputProperty(display_, id, name, XA_ATOM, 32,
-                          PropModeReplace, data, 1);
-  if (err_tracker.FoundNewError()) {
-    LOG(ERROR) << "XRRChangeOutputProperty failed";
-    return false;
-  } else {
-    return true;
-  }
-}
-
-void RealOutputConfiguratorDelegate::DestroyUnusedCrtcs(
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
-  // At the same time, turning CRTCs off and back on uses up a lot of time.
-  // This function tries to be smart to avoid too many off/on cycles:
-  // - We disable all the CRTCs we won't need after the FB resize.
-  // - We set the new modes on CRTCs, if they fit in both the old and new
-  //   FBs, and park them at (0,0)
-  // - We disable the CRTCs we will need but don't fit in the old FB. Those
-  //   will be reenabled after the resize.
-  // We don't worry about the cached state of the outputs here since we are
-  // not interested in the state we are setting - we just try to get the CRTCs
-  // out of the way so we can rebuild the frame buffer.
-  for (int i = 0; i < screen_->ncrtc; ++i) {
-    // Default config is to disable the crtcs.
-    RRCrtc crtc = screen_->crtcs[i];
-    RRMode mode = None;
-    RROutput output = None;
-    const OutputConfigurator::ModeInfo* mode_info = NULL;
-    for (std::vector<OutputConfigurator::OutputSnapshot>::const_iterator it =
-         outputs.begin(); it != outputs.end(); ++it) {
-      if (crtc == it->crtc) {
-        mode = it->current_mode;
-        output = it->output;
-        if (mode != None)
-          mode_info = OutputConfigurator::GetModeInfo(*it, mode);
-        break;
-      }
-    }
-
-    if (mode_info) {
-      // In case our CRTC doesn't fit in our current framebuffer, disable it.
-      // It'll get reenabled after we resize the framebuffer.
-      int current_width = DisplayWidth(display_, DefaultScreen(display_));
-      int current_height = DisplayHeight(display_, DefaultScreen(display_));
-      if (mode_info->width > current_width ||
-          mode_info->height > current_height) {
-        mode = None;
-        output = None;
-        mode_info = NULL;
-      }
-    }
-
-    ConfigureCrtc(crtc, mode, output, 0, 0);
-  }
-}
-
-bool RealOutputConfiguratorDelegate::IsOutputAspectPreservingScaling(
-    RROutput id) {
-  bool ret = false;
-
-  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
-  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
-  if (scaling_prop == None || full_aspect_atom == None)
-    return false;
-
-  int nprop = 0;
-  Atom* props = XRRListOutputProperties(display_, id, &nprop);
-  for (int j = 0; j < nprop && !ret; j++) {
-    Atom prop = props[j];
-    if (scaling_prop == prop) {
-      unsigned char* values = NULL;
-      int actual_format;
-      unsigned long nitems;
-      unsigned long bytes_after;
-      Atom actual_type;
-      int success;
-
-      success = XRRGetOutputProperty(display_, id, prop, 0, 100, False, False,
-          AnyPropertyType, &actual_type, &actual_format, &nitems,
-          &bytes_after, &values);
-      if (success == Success && actual_type == XA_ATOM &&
-          actual_format == 32 && nitems == 1) {
-        Atom value = reinterpret_cast<Atom*>(values)[0];
-        if (full_aspect_atom == value)
-          ret = true;
-      }
-      if (values)
-        XFree(values);
-    }
-  }
-  if (props)
-    XFree(props);
-
-  return ret;
-}
-
-void RealOutputConfiguratorDelegate::GetTouchscreens(
-    std::vector<OutputConfigurator::OutputSnapshot>* outputs) {
-  int ndevices = 0;
-  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
-  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
-  if (valuator_x == None || valuator_y == None)
-    return;
-
-  std::set<int> no_match_touchscreen;
-  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
-  for (int i = 0; i < ndevices; i++) {
-    if (!info[i].enabled || info[i].use != XIFloatingSlave)
-      continue;  // Assume all touchscreens are floating slaves
-
-    double width = -1.0;
-    double height = -1.0;
-    bool is_direct_touch = false;
-
-    for (int j = 0; j < info[i].num_classes; j++) {
-      XIAnyClassInfo* class_info = info[i].classes[j];
-
-      if (class_info->type == XIValuatorClass) {
-        XIValuatorClassInfo* valuator_info =
-            reinterpret_cast<XIValuatorClassInfo*>(class_info);
-
-        if (valuator_x == valuator_info->label) {
-          // Ignore X axis valuator with unexpected properties
-          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            width = valuator_info->max;
-          }
-        } else if (valuator_y == valuator_info->label) {
-          // Ignore Y axis valuator with unexpected properties
-          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            height = valuator_info->max;
-          }
-        }
-      }
-#if defined(USE_XI2_MT)
-      if (class_info->type == XITouchClass) {
-        XITouchClassInfo* touch_info =
-            reinterpret_cast<XITouchClassInfo*>(class_info);
-        is_direct_touch = touch_info->mode == XIDirectTouch;
-      }
-#endif
-    }
-
-    // Touchscreens should have absolute X and Y axes,
-    // and be direct touch devices.
-    if (width > 0.0 && height > 0.0 && is_direct_touch) {
-      size_t k = 0;
-      for (; k < outputs->size(); k++) {
-        OutputConfigurator::OutputSnapshot* output = &(*outputs)[k];
-        if (output->native_mode == None || output->touch_device_id != None)
-          continue;
-
-        const OutputConfigurator::ModeInfo* mode_info =
-            OutputConfigurator::GetModeInfo(*output, output->native_mode);
-        if (!mode_info)
-          continue;
-
-        // Allow 1 pixel difference between screen and touchscreen
-        // resolutions.  Because in some cases for monitor resolution
-        // 1024x768 touchscreen's resolution would be 1024x768, but for
-        // some 1023x767.  It really depends on touchscreen's firmware
-        // configuration.
-        if (std::abs(mode_info->width - width) <= 1.0 &&
-            std::abs(mode_info->height - height) <= 1.0) {
-          output->touch_device_id = info[i].deviceid;
-
-          VLOG(2) << "Found touchscreen for output #" << k
-                  << " id " << output->touch_device_id
-                  << " width " << width
-                  << " height " << height;
-          break;
-        }
-      }
-
-      if (k == outputs->size()) {
-        no_match_touchscreen.insert(info[i].deviceid);
-        VLOG(2) << "No matching output for touchscreen"
-                << " id " << info[i].deviceid
-                << " width " << width
-                << " height " << height;
-      }
-
-    }
-  }
-
-  // Sometimes we can't find a matching screen for the touchscreen, e.g.
-  // due to the touchscreen's reporting range having no correlation with the
-  // screen's resolution. In this case, we arbitrarily assign unmatched
-  // touchscreens to unmatched screens.
-  for (std::set<int>::iterator it = no_match_touchscreen.begin();
-       it != no_match_touchscreen.end();
-       it++) {
-    for (size_t i = 0; i < outputs->size(); i++) {
-      if ((*outputs)[i].is_internal == false &&
-          (*outputs)[i].native_mode != None &&
-          (*outputs)[i].touch_device_id == None ) {
-        (*outputs)[i].touch_device_id = *it;
-        VLOG(2) << "Arbitrarily matching touchscreen "
-                << (*outputs)[i].touch_device_id << " to output #" << i;
-        break;
-      }
-    }
-  }
-
-  XIFreeDeviceInfo(info);
-}
-
-}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate.h b/chromeos/display/real_output_configurator_delegate.h
deleted file mode 100644
index 26940c4..0000000
--- a/chromeos/display/real_output_configurator_delegate.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-
-#include <vector>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "chromeos/display/output_configurator.h"
-
-typedef XID Window;
-
-struct _XDisplay;
-typedef struct _XDisplay Display;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-
-namespace chromeos {
-
-class RealOutputConfiguratorDelegate : public OutputConfigurator::Delegate {
- public:
-  RealOutputConfiguratorDelegate();
-  virtual ~RealOutputConfiguratorDelegate();
-
-  // OutputConfigurator::Delegate overrides:
-  virtual void InitXRandRExtension(int* event_base) OVERRIDE;
-  virtual void UpdateXRandRConfiguration(
-      const base::NativeEvent& event) OVERRIDE;
-  virtual void GrabServer() OVERRIDE;
-  virtual void UngrabServer() OVERRIDE;
-  virtual void SyncWithServer() OVERRIDE;
-  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
-  virtual void ForceDPMSOn() OVERRIDE;
-  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
-  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
-  virtual bool ConfigureCrtc(
-      RRCrtc crtc,
-      RRMode mode,
-      RROutput output,
-      int x,
-      int y) OVERRIDE;
-  virtual void CreateFrameBuffer(
-      int width,
-      int height,
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
-  virtual void ConfigureCTM(
-      int touch_device_id,
-      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
-  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
-  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
-  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
-
- private:
-  // Initializes |mode_info| to contain details corresponding to |mode|. Returns
-  // true on success.
-  bool InitModeInfo(RRMode mode, OutputConfigurator::ModeInfo* mode_info);
-
-  // Helper method for GetOutputs() that returns an OutputSnapshot struct based
-  // on the passed-in information. Further initialization is required (e.g.
-  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
-  OutputConfigurator::OutputSnapshot InitOutputSnapshot(
-      RROutput id,
-      XRROutputInfo* info,
-      RRCrtc* last_used_crtc,
-      int index);
-
-  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
-  // framebuffer resize. This is faster than turning them off, resizing,
-  // then turning them back on.
-  void DestroyUnusedCrtcs(
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs);
-
-  // Returns whether |id| is configured to preserve aspect when scaling.
-  bool IsOutputAspectPreservingScaling(RROutput id);
-
-  // Searches for touchscreens among input devices,
-  // and tries to match them up to screens in |outputs|.
-  // |outputs| is an array of detected screens.
-  // If a touchscreen with same resolution as an output's native mode
-  // is detected, its id will be stored in this output.
-  void GetTouchscreens(
-      std::vector<OutputConfigurator::OutputSnapshot>* outputs);
-
-  Display* display_;
-  Window window_;
-
-  // Initialized when the server is grabbed and freed when it's ungrabbed.
-  XRRScreenResources* screen_;
-
-  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegate);
-};
-
-}  // namespace chromeos
-
-#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/chromeos/display/real_output_configurator_delegate_dri.cc b/chromeos/display/real_output_configurator_delegate_dri.cc
new file mode 100644
index 0000000..9f9fb7c
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_dri.cc
@@ -0,0 +1,96 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/real_output_configurator_delegate_dri.h"
+
+namespace chromeos {
+
+RealOutputConfiguratorDelegateDri::RealOutputConfiguratorDelegateDri() {
+}
+
+RealOutputConfiguratorDelegateDri::~RealOutputConfiguratorDelegateDri() {
+}
+
+int RealOutputConfiguratorDelegateDri::InitResources() {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+void RealOutputConfiguratorDelegateDri::HandleScreenChangeNotification(
+    const base::NativeEvent& event) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::GrabServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::UngrabServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SyncWithServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SetBackgroundColor(uint32 color_argb) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::ForceDPMSOn() {
+  NOTIMPLEMENTED();
+}
+
+std::vector<OutputConfigurator::OutputSnapshot>
+RealOutputConfiguratorDelegateDri::GetOutputs() {
+  std::vector<OutputConfigurator::OutputSnapshot> outputs;
+  NOTIMPLEMENTED();
+  return outputs;
+}
+
+void RealOutputConfiguratorDelegateDri::AddOutputMode(RROutput output,
+                                                   RRMode mode) {
+  NOTIMPLEMENTED();
+}
+
+bool RealOutputConfiguratorDelegateDri::ConfigureCrtc(RRCrtc crtc,
+                                                      RRMode mode,
+                                                      RROutput output,
+                                                      int x,
+                                                      int y) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void RealOutputConfiguratorDelegateDri::CreateFrameBuffer(
+    int width,
+    int height,
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::ConfigureCTM(
+    int touch_device_id,
+    const OutputConfigurator::CoordinateTransformation& ctm) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SendProjectingStateToPowerManager(
+    bool projecting) {
+  NOTIMPLEMENTED();
+}
+
+bool RealOutputConfiguratorDelegateDri::GetHDCPState(RROutput id,
+                                                  HDCPState* state) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool RealOutputConfiguratorDelegateDri::SetHDCPState(RROutput id,
+                                                  HDCPState state) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate_dri.h b/chromeos/display/real_output_configurator_delegate_dri.h
new file mode 100644
index 0000000..7ecee82
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_dri.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+
+class RealOutputConfiguratorDelegateDri : public OutputConfigurator::Delegate {
+ public:
+  RealOutputConfiguratorDelegateDri();
+  virtual ~RealOutputConfiguratorDelegateDri();
+
+  // OutputConfigurator::Delegate overrides:
+  virtual int InitResources() OVERRIDE;
+  virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual void GrabServer() OVERRIDE;
+  virtual void UngrabServer() OVERRIDE;
+  virtual void SyncWithServer() OVERRIDE;
+  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
+  virtual void ForceDPMSOn() OVERRIDE;
+  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
+  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
+  virtual bool ConfigureCrtc(
+      RRCrtc crtc,
+      RRMode mode,
+      RROutput output,
+      int x,
+      int y) OVERRIDE;
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
+  virtual void ConfigureCTM(
+      int touch_device_id,
+      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
+  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
+  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
+
+  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegateDri);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/chromeos/display/real_output_configurator_delegate_x11.cc b/chromeos/display/real_output_configurator_delegate_x11.cc
new file mode 100644
index 0000000..6344980
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_x11.cc
@@ -0,0 +1,616 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/real_output_configurator_delegate_x11.h"
+
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/dpms.h>
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xrandr.h>
+
+#include <cmath>
+#include <set>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/message_loop/message_pump_x11.h"
+#include "base/x11/edid_parser_x11.h"
+#include "base/x11/x11_error_tracker.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/power_manager_client.h"
+#include "chromeos/display/output_util.h"
+
+namespace chromeos {
+
+namespace {
+
+// DPI measurements.
+const float kMmInInch = 25.4;
+const float kDpi96 = 96.0;
+const float kPixelsToMmScale = kMmInInch / kDpi96;
+
+// Prefixes of output name
+const char kOutputName_VGA[] = "VGA";
+const char kOutputName_HDMI[] = "HDMI";
+const char kOutputName_DVI[] = "DVI";
+const char kOutputName_DisplayPort[] = "DP";
+
+const char kContentProtectionAtomName[] = "Content Protection";
+const char kProtectionUndesiredAtomName[] = "Undesired";
+const char kProtectionDesiredAtomName[] = "Desired";
+const char kProtectionEnabledAtomName[] = "Enabled";
+
+bool IsInternalOutput(const XRROutputInfo* output_info) {
+  return IsInternalOutputName(std::string(output_info->name));
+}
+
+RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
+  return output_info->nmode > 0 ? output_info->modes[0] : None;
+}
+
+}  // namespace
+
+RealOutputConfiguratorDelegate::RealOutputConfiguratorDelegate()
+    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
+      window_(DefaultRootWindow(display_)),
+      screen_(NULL) {
+}
+
+RealOutputConfiguratorDelegate::~RealOutputConfiguratorDelegate() {
+}
+
+int RealOutputConfiguratorDelegate::InitResources() {
+  int error_base_ignored = 0;
+  int event_base = -1;
+  XRRQueryExtension(display_, &event_base, &error_base_ignored);
+  return event_base;
+}
+
+void RealOutputConfiguratorDelegate::HandleScreenChangeNotification(
+    const base::NativeEvent& event) {
+  XRRUpdateConfiguration(event);
+}
+
+void RealOutputConfiguratorDelegate::GrabServer() {
+  CHECK(!screen_) << "Server already grabbed";
+  XGrabServer(display_);
+  screen_ = XRRGetScreenResources(display_, window_);
+  CHECK(screen_);
+}
+
+void RealOutputConfiguratorDelegate::UngrabServer() {
+  CHECK(screen_) << "Server not grabbed";
+  XRRFreeScreenResources(screen_);
+  screen_ = NULL;
+  XUngrabServer(display_);
+}
+
+void RealOutputConfiguratorDelegate::SyncWithServer() {
+  XSync(display_, 0);
+}
+
+void RealOutputConfiguratorDelegate::SetBackgroundColor(uint32 color_argb) {
+  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
+  // same background color while configuring the display to minimize the
+  // duration of black screen at boot time. The background is filled with
+  // black later in ash::DisplayManager.  crbug.com/171050.
+  XSetWindowAttributes swa = {0};
+  XColor color;
+  Colormap colormap = DefaultColormap(display_, 0);
+  // XColor uses 16 bits per color.
+  color.red = (color_argb & 0x00FF0000) >> 8;
+  color.green = (color_argb & 0x0000FF00);
+  color.blue = (color_argb & 0x000000FF) << 8;
+  color.flags = DoRed | DoGreen | DoBlue;
+  XAllocColor(display_, colormap, &color);
+  swa.background_pixel = color.pixel;
+  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
+  XFreeColors(display_, colormap, &color.pixel, 1, 0);
+}
+
+void RealOutputConfiguratorDelegate::ForceDPMSOn() {
+  CHECK(DPMSEnable(display_));
+  CHECK(DPMSForceLevel(display_, DPMSModeOn));
+}
+
+std::vector<OutputConfigurator::OutputSnapshot>
+RealOutputConfiguratorDelegate::GetOutputs() {
+  CHECK(screen_) << "Server not grabbed";
+
+  std::vector<OutputConfigurator::OutputSnapshot> outputs;
+  RRCrtc last_used_crtc = None;
+
+  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
+    RROutput output_id = screen_->outputs[i];
+    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
+    if (output_info->connection == RR_Connected) {
+      OutputConfigurator::OutputSnapshot output = InitOutputSnapshot(
+          output_id, output_info, &last_used_crtc, i);
+      VLOG(2) << "Found display " << outputs.size() << ":"
+              << " output=" << output.output
+              << " crtc=" << output.crtc
+              << " current_mode=" << output.current_mode;
+      outputs.push_back(output);
+    }
+    XRRFreeOutputInfo(output_info);
+  }
+
+  GetTouchscreens(&outputs);
+  return outputs;
+}
+
+void RealOutputConfiguratorDelegate::AddOutputMode(RROutput output,
+                                                   RRMode mode) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "AddOutputMode: output=" << output << " mode=" << mode;
+  XRRAddOutputMode(display_, output, mode);
+}
+
+bool RealOutputConfiguratorDelegate::ConfigureCrtc(
+    RRCrtc crtc,
+    RRMode mode,
+    RROutput output,
+    int x,
+    int y) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "ConfigureCrtc: crtc=" << crtc
+          << " mode=" << mode
+          << " output=" << output
+          << " x=" << x
+          << " y=" << y;
+  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
+  // Status, which is typically 0 for failure and 1 for success. In
+  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
+  return XRRSetCrtcConfig(display_,
+                          screen_,
+                          crtc,
+                          CurrentTime,
+                          x,
+                          y,
+                          mode,
+                          RR_Rotate_0,
+                          (output && mode) ? &output : NULL,
+                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
+}
+
+void RealOutputConfiguratorDelegate::CreateFrameBuffer(
+    int width,
+    int height,
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  int current_width = DisplayWidth(display_, DefaultScreen(display_));
+  int current_height = DisplayHeight(display_, DefaultScreen(display_));
+  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
+          << " current=" << current_width << "x" << current_height;
+  if (width ==  current_width && height == current_height)
+    return;
+
+  DestroyUnusedCrtcs(outputs);
+  int mm_width = width * kPixelsToMmScale;
+  int mm_height = height * kPixelsToMmScale;
+  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
+}
+
+void RealOutputConfiguratorDelegate::ConfigureCTM(
+    int touch_device_id,
+    const OutputConfigurator::CoordinateTransformation& ctm) {
+  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
+          << " scale=" << ctm.x_scale << "x" << ctm.y_scale
+          << " offset=(" << ctm.x_offset << ", " << ctm.y_offset << ")";
+  int ndevices = 0;
+  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
+  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
+  Atom float_atom = XInternAtom(display_, "FLOAT", False);
+  if (ndevices == 1 && prop != None && float_atom != None) {
+    Atom type;
+    int format;
+    unsigned long num_items;
+    unsigned long bytes_after;
+    unsigned char* data = NULL;
+    // Verify that the property exists with correct format, type, etc.
+    int status = XIGetProperty(display_, info->deviceid, prop, 0, 0, False,
+        AnyPropertyType, &type, &format, &num_items, &bytes_after, &data);
+    if (data)
+      XFree(data);
+    if (status == Success && type == float_atom && format == 32) {
+      float value[3][3] = {
+          { ctm.x_scale,         0.0, ctm.x_offset },
+          {         0.0, ctm.y_scale, ctm.y_offset },
+          {         0.0,         0.0,          1.0 }
+      };
+      XIChangeProperty(display_,
+                       info->deviceid,
+                       prop,
+                       type,
+                       format,
+                       PropModeReplace,
+                       reinterpret_cast<unsigned char*>(value),
+                       9);
+    }
+  }
+  XIFreeDeviceInfo(info);
+}
+
+void RealOutputConfiguratorDelegate::SendProjectingStateToPowerManager(
+    bool projecting) {
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->
+      SetIsProjecting(projecting);
+}
+
+bool RealOutputConfiguratorDelegate::InitModeInfo(
+    RRMode mode,
+    OutputConfigurator::ModeInfo* mode_info) {
+  DCHECK(mode_info);
+  CHECK(screen_) << "Server not grabbed";
+  // TODO: Determine if we need to organize modes in a way which provides
+  // better than O(n) lookup time.  In many call sites, for example, the
+  // "next" mode is typically what we are looking for so using this
+  // helper might be too expensive.
+  for (int i = 0; i < screen_->nmode; ++i) {
+    if (mode == screen_->modes[i].id) {
+      const XRRModeInfo& info = screen_->modes[i];
+      mode_info->width = info.width;
+      mode_info->height = info.height;
+      mode_info->interlaced = info.modeFlags & RR_Interlace;
+      if (info.hTotal && info.vTotal) {
+        mode_info->refresh_rate = static_cast<float>(info.dotClock) /
+            (static_cast<float>(info.hTotal) *
+             static_cast<float>(info.vTotal));
+      } else {
+        mode_info->refresh_rate = 0.0f;
+      }
+      return true;
+    }
+  }
+  return false;
+}
+
+OutputConfigurator::OutputSnapshot
+RealOutputConfiguratorDelegate::InitOutputSnapshot(
+    RROutput id,
+    XRROutputInfo* info,
+    RRCrtc* last_used_crtc,
+    int index) {
+  OutputConfigurator::OutputSnapshot output;
+  output.output = id;
+  output.width_mm = info->mm_width;
+  output.height_mm = info->mm_height;
+  output.has_display_id = base::GetDisplayId(id, index, &output.display_id);
+  output.is_internal = IsInternalOutput(info);
+  output.index = index;
+
+  // Use the index as a valid display ID even if the internal
+  // display doesn't have valid EDID because the index
+  // will never change.
+  if (!output.has_display_id && output.is_internal)
+    output.has_display_id = true;
+
+  if (info->crtc) {
+    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
+    output.current_mode = crtc_info->mode;
+    output.x = crtc_info->x;
+    output.y = crtc_info->y;
+    XRRFreeCrtcInfo(crtc_info);
+  }
+
+  // Assign a CRTC that isn't already in use.
+  for (int i = 0; i < info->ncrtc; ++i) {
+    if (info->crtcs[i] != *last_used_crtc) {
+      output.crtc = info->crtcs[i];
+      *last_used_crtc = output.crtc;
+      break;
+    }
+  }
+
+  output.native_mode = GetOutputNativeMode(info);
+  output.is_aspect_preserving_scaling = IsOutputAspectPreservingScaling(id);
+  output.touch_device_id = None;
+
+  for (int i = 0; i < info->nmode; ++i) {
+    const RRMode mode = info->modes[i];
+    OutputConfigurator::ModeInfo mode_info;
+    if (InitModeInfo(mode, &mode_info))
+      output.mode_infos.insert(std::make_pair(mode, mode_info));
+    else
+      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
+  }
+
+  std::string name(info->name);
+  if (output.is_internal) {
+    output.type = OUTPUT_TYPE_INTERNAL;
+  } else if (name.find(kOutputName_VGA) == 0) {
+    output.type = OUTPUT_TYPE_VGA;
+  } else if (name.find(kOutputName_HDMI) == 0) {
+    output.type = OUTPUT_TYPE_HDMI;
+  } else if (name.find(kOutputName_DVI) == 0) {
+    output.type = OUTPUT_TYPE_DVI;
+  } else if (name.find(kOutputName_DisplayPort) == 0) {
+    output.type = OUTPUT_TYPE_DISPLAYPORT;
+  } else {
+    LOG(ERROR) << "Unknown link type: " << name;
+    output.type = OUTPUT_TYPE_UNKNOWN;
+  }
+
+  return output;
+}
+
+bool RealOutputConfiguratorDelegate::GetHDCPState(RROutput id,
+                                                  HDCPState* state) {
+  unsigned char* values = NULL;
+  int actual_format = 0;
+  unsigned long nitems = 0;
+  unsigned long bytes_after = 0;
+  Atom actual_type = None;
+  int success = 0;
+  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
+  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
+
+  bool ok = true;
+  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
+  // output_util.cc)
+  success = XRRGetOutputProperty(display_, id, prop, 0, 100, False,
+                                 False, AnyPropertyType, &actual_type,
+                                 &actual_format, &nitems, &bytes_after,
+                                 &values);
+  if (actual_type == None) {
+    LOG(ERROR) << "Property '" << kContentProtectionAtomName
+               << "' does not exist";
+    ok = false;
+  } else if (success == Success && actual_type == XA_ATOM &&
+             actual_format == 32 && nitems == 1) {
+    Atom value = reinterpret_cast<Atom*>(values)[0];
+    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
+      *state = HDCP_STATE_UNDESIRED;
+    } else if (value == XInternAtom(display_, kProtectionDesiredAtomName,
+                                    False)) {
+      *state = HDCP_STATE_DESIRED;
+    } else if (value == XInternAtom(display_, kProtectionEnabledAtomName,
+                                    False)) {
+      *state = HDCP_STATE_ENABLED;
+    } else {
+      LOG(ERROR) << "Unknown " << kContentProtectionAtomName << " value: "
+                 << value;
+      ok = false;
+    }
+  } else {
+    LOG(ERROR) << "XRRGetOutputProperty failed";
+    ok = false;
+  }
+  if (values)
+    XFree(values);
+
+  VLOG(3) << "HDCP state: " << ok << "," << *state;
+  return ok;
+}
+
+bool RealOutputConfiguratorDelegate::SetHDCPState(RROutput id,
+                                                  HDCPState state) {
+  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
+  Atom value = None;
+  switch (state) {
+    case HDCP_STATE_UNDESIRED:
+      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
+      break;
+    case HDCP_STATE_DESIRED:
+      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
+      break;
+    default:
+      NOTREACHED() << "Invalid HDCP state: " << state;
+      return false;
+  }
+  base::X11ErrorTracker err_tracker;
+  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
+  XRRChangeOutputProperty(display_, id, name, XA_ATOM, 32,
+                          PropModeReplace, data, 1);
+  if (err_tracker.FoundNewError()) {
+    LOG(ERROR) << "XRRChangeOutputProperty failed";
+    return false;
+  } else {
+    return true;
+  }
+}
+
+void RealOutputConfiguratorDelegate::DestroyUnusedCrtcs(
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
+  // At the same time, turning CRTCs off and back on uses up a lot of time.
+  // This function tries to be smart to avoid too many off/on cycles:
+  // - We disable all the CRTCs we won't need after the FB resize.
+  // - We set the new modes on CRTCs, if they fit in both the old and new
+  //   FBs, and park them at (0,0)
+  // - We disable the CRTCs we will need but don't fit in the old FB. Those
+  //   will be reenabled after the resize.
+  // We don't worry about the cached state of the outputs here since we are
+  // not interested in the state we are setting - we just try to get the CRTCs
+  // out of the way so we can rebuild the frame buffer.
+  for (int i = 0; i < screen_->ncrtc; ++i) {
+    // Default config is to disable the crtcs.
+    RRCrtc crtc = screen_->crtcs[i];
+    RRMode mode = None;
+    RROutput output = None;
+    const OutputConfigurator::ModeInfo* mode_info = NULL;
+    for (std::vector<OutputConfigurator::OutputSnapshot>::const_iterator it =
+         outputs.begin(); it != outputs.end(); ++it) {
+      if (crtc == it->crtc) {
+        mode = it->current_mode;
+        output = it->output;
+        if (mode != None)
+          mode_info = OutputConfigurator::GetModeInfo(*it, mode);
+        break;
+      }
+    }
+
+    if (mode_info) {
+      // In case our CRTC doesn't fit in our current framebuffer, disable it.
+      // It'll get reenabled after we resize the framebuffer.
+      int current_width = DisplayWidth(display_, DefaultScreen(display_));
+      int current_height = DisplayHeight(display_, DefaultScreen(display_));
+      if (mode_info->width > current_width ||
+          mode_info->height > current_height) {
+        mode = None;
+        output = None;
+        mode_info = NULL;
+      }
+    }
+
+    ConfigureCrtc(crtc, mode, output, 0, 0);
+  }
+}
+
+bool RealOutputConfiguratorDelegate::IsOutputAspectPreservingScaling(
+    RROutput id) {
+  bool ret = false;
+
+  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
+  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
+  if (scaling_prop == None || full_aspect_atom == None)
+    return false;
+
+  int nprop = 0;
+  Atom* props = XRRListOutputProperties(display_, id, &nprop);
+  for (int j = 0; j < nprop && !ret; j++) {
+    Atom prop = props[j];
+    if (scaling_prop == prop) {
+      unsigned char* values = NULL;
+      int actual_format;
+      unsigned long nitems;
+      unsigned long bytes_after;
+      Atom actual_type;
+      int success;
+
+      success = XRRGetOutputProperty(display_, id, prop, 0, 100, False, False,
+          AnyPropertyType, &actual_type, &actual_format, &nitems,
+          &bytes_after, &values);
+      if (success == Success && actual_type == XA_ATOM &&
+          actual_format == 32 && nitems == 1) {
+        Atom value = reinterpret_cast<Atom*>(values)[0];
+        if (full_aspect_atom == value)
+          ret = true;
+      }
+      if (values)
+        XFree(values);
+    }
+  }
+  if (props)
+    XFree(props);
+
+  return ret;
+}
+
+void RealOutputConfiguratorDelegate::GetTouchscreens(
+    std::vector<OutputConfigurator::OutputSnapshot>* outputs) {
+  int ndevices = 0;
+  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
+  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
+  if (valuator_x == None || valuator_y == None)
+    return;
+
+  std::set<int> no_match_touchscreen;
+  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
+  for (int i = 0; i < ndevices; i++) {
+    if (!info[i].enabled || info[i].use != XIFloatingSlave)
+      continue;  // Assume all touchscreens are floating slaves
+
+    double width = -1.0;
+    double height = -1.0;
+    bool is_direct_touch = false;
+
+    for (int j = 0; j < info[i].num_classes; j++) {
+      XIAnyClassInfo* class_info = info[i].classes[j];
+
+      if (class_info->type == XIValuatorClass) {
+        XIValuatorClassInfo* valuator_info =
+            reinterpret_cast<XIValuatorClassInfo*>(class_info);
+
+        if (valuator_x == valuator_info->label) {
+          // Ignore X axis valuator with unexpected properties
+          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            width = valuator_info->max;
+          }
+        } else if (valuator_y == valuator_info->label) {
+          // Ignore Y axis valuator with unexpected properties
+          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            height = valuator_info->max;
+          }
+        }
+      }
+#if defined(USE_XI2_MT)
+      if (class_info->type == XITouchClass) {
+        XITouchClassInfo* touch_info =
+            reinterpret_cast<XITouchClassInfo*>(class_info);
+        is_direct_touch = touch_info->mode == XIDirectTouch;
+      }
+#endif
+    }
+
+    // Touchscreens should have absolute X and Y axes,
+    // and be direct touch devices.
+    if (width > 0.0 && height > 0.0 && is_direct_touch) {
+      size_t k = 0;
+      for (; k < outputs->size(); k++) {
+        OutputConfigurator::OutputSnapshot* output = &(*outputs)[k];
+        if (output->native_mode == None || output->touch_device_id != None)
+          continue;
+
+        const OutputConfigurator::ModeInfo* mode_info =
+            OutputConfigurator::GetModeInfo(*output, output->native_mode);
+        if (!mode_info)
+          continue;
+
+        // Allow 1 pixel difference between screen and touchscreen
+        // resolutions.  Because in some cases for monitor resolution
+        // 1024x768 touchscreen's resolution would be 1024x768, but for
+        // some 1023x767.  It really depends on touchscreen's firmware
+        // configuration.
+        if (std::abs(mode_info->width - width) <= 1.0 &&
+            std::abs(mode_info->height - height) <= 1.0) {
+          output->touch_device_id = info[i].deviceid;
+
+          VLOG(2) << "Found touchscreen for output #" << k
+                  << " id " << output->touch_device_id
+                  << " width " << width
+                  << " height " << height;
+          break;
+        }
+      }
+
+      if (k == outputs->size()) {
+        no_match_touchscreen.insert(info[i].deviceid);
+        VLOG(2) << "No matching output for touchscreen"
+                << " id " << info[i].deviceid
+                << " width " << width
+                << " height " << height;
+      }
+
+    }
+  }
+
+  // Sometimes we can't find a matching screen for the touchscreen, e.g.
+  // due to the touchscreen's reporting range having no correlation with the
+  // screen's resolution. In this case, we arbitrarily assign unmatched
+  // touchscreens to unmatched screens.
+  for (std::set<int>::iterator it = no_match_touchscreen.begin();
+       it != no_match_touchscreen.end();
+       it++) {
+    for (size_t i = 0; i < outputs->size(); i++) {
+      if ((*outputs)[i].is_internal == false &&
+          (*outputs)[i].native_mode != None &&
+          (*outputs)[i].touch_device_id == None ) {
+        (*outputs)[i].touch_device_id = *it;
+        VLOG(2) << "Arbitrarily matching touchscreen "
+                << (*outputs)[i].touch_device_id << " to output #" << i;
+        break;
+      }
+    }
+  }
+
+  XIFreeDeviceInfo(info);
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate_x11.h b/chromeos/display/real_output_configurator_delegate_x11.h
new file mode 100644
index 0000000..8130a6d
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_x11.h
@@ -0,0 +1,100 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "chromeos/display/output_configurator.h"
+
+typedef OUTPUTID Window;
+
+struct _XDisplay;
+typedef struct _XDisplay Display;
+struct _XRROutputInfo;
+typedef _XRROutputInfo XRROutputInfo;
+struct _XRRScreenResources;
+typedef _XRRScreenResources XRRScreenResources;
+
+namespace chromeos {
+
+class RealOutputConfiguratorDelegate : public OutputConfigurator::Delegate {
+ public:
+  RealOutputConfiguratorDelegate();
+  virtual ~RealOutputConfiguratorDelegate();
+
+  // OutputConfigurator::Delegate overrides:
+  virtual int InitResources() OVERRIDE;
+  virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual void GrabServer() OVERRIDE;
+  virtual void UngrabServer() OVERRIDE;
+  virtual void SyncWithServer() OVERRIDE;
+  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
+  virtual void ForceDPMSOn() OVERRIDE;
+  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
+  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
+  virtual bool ConfigureCrtc(
+      RRCrtc crtc,
+      RRMode mode,
+      RROutput output,
+      int x,
+      int y) OVERRIDE;
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
+  virtual void ConfigureCTM(
+      int touch_device_id,
+      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
+  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
+  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
+
+ private:
+  // Initializes |mode_info| to contain details corresponding to |mode|. Returns
+  // true on success.
+  bool InitModeInfo(RRMode mode, OutputConfigurator::ModeInfo* mode_info);
+
+  // Helper method for GetOutputs() that returns an OutputSnapshot struct based
+  // on the passed-in information. Further initialization is required (e.g.
+  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
+  OutputConfigurator::OutputSnapshot InitOutputSnapshot(
+      RROutput id,
+      XRROutputInfo* info,
+      RRCrtc* last_used_crtc,
+      int index);
+
+  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
+  // framebuffer resize. This is faster than turning them off, resizing,
+  // then turning them back on.
+  void DestroyUnusedCrtcs(
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs);
+
+  // Returns whether |id| is configured to preserve aspect when scaling.
+  bool IsOutputAspectPreservingScaling(RROutput id);
+
+  // Searches for touchscreens among input devices,
+  // and tries to match them up to screens in |outputs|.
+  // |outputs| is an array of detected screens.
+  // If a touchscreen with same resolution as an output's native mode
+  // is detected, its id will be stored in this output.
+  void GetTouchscreens(
+      std::vector<OutputConfigurator::OutputSnapshot>* outputs);
+
+  Display* display_;
+  Window window_;
+
+  // Initialized when the server is grabbed and freed when it's ungrabbed.
+  XRRScreenResources* screen_;
+
+  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegate);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/ui/ozone/ozone_platform.cc b/ui/ozone/ozone_platform.cc
index a084005..49cd7c6 100644
--- a/ui/ozone/ozone_platform.cc
+++ b/ui/ozone/ozone_platform.cc
@@ -54,6 +54,10 @@ void OzonePlatform::Initialize() {
   // Inject ozone interfaces.
   gfx::SurfaceFactoryOzone::SetInstance(instance_->GetSurfaceFactoryOzone());
   ui::EventFactoryOzone::SetInstance(instance_->GetEventFactoryOzone());
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzone::SetInstance(
+      instance_->GetOutputConfiguratorOzone());
+#endif
 }
 
 // static
diff --git a/ui/ozone/ozone_platform.h b/ui/ozone/ozone_platform.h
index 519d8b2..5f9c5d4 100644
--- a/ui/ozone/ozone_platform.h
+++ b/ui/ozone/ozone_platform.h
@@ -6,6 +6,9 @@
 #define UI_OZONE_OZONE_PLATFORM_H_
 
 #include "base/memory/scoped_ptr.h"
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone.h"
+#endif
 #include "ui/events/ozone/event_factory_ozone.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
 #include "ui/ozone/ozone_export.h"
@@ -40,6 +43,9 @@ class OZONE_EXPORT OzonePlatform {
   // inject these objects themselves. Ownership is retained by OzonePlatform.
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() = 0;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() = 0;
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone* GetOutputConfiguratorOzone() = 0;
+#endif
 
  private:
   static OzonePlatform* instance_;
diff --git a/ui/ozone/platform/dri/ozone_platform_dri.cc b/ui/ozone/platform/dri/ozone_platform_dri.cc
index 9feb9a2..3e4690f 100644
--- a/ui/ozone/platform/dri/ozone_platform_dri.cc
+++ b/ui/ozone/platform/dri/ozone_platform_dri.cc
@@ -20,6 +20,13 @@ ui::EventFactoryOzone* OzonePlatformDri::GetEventFactoryOzone() {
   return &event_factory_ozone_;
 }
 
+#if defined(OS_CHROMEOS)
+chromeos::OutputConfiguratorOzone*
+  OzonePlatformDri::GetOutputConfiguratorOzone() {
+  return &output_configurator_;
+}
+#endif
+
 OzonePlatform* CreateOzonePlatformDri() { return new OzonePlatformDri; }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/dri/ozone_platform_dri.h b/ui/ozone/platform/dri/ozone_platform_dri.h
index 64df1cc..2487a3d 100644
--- a/ui/ozone/platform/dri/ozone_platform_dri.h
+++ b/ui/ozone/platform/dri/ozone_platform_dri.h
@@ -5,6 +5,9 @@
 #ifndef UI_OZONE_PLATFORM_DRI_OZONE_PLATFORM_DRI_H_
 #define UI_OZONE_PLATFORM_DRI_OZONE_PLATFORM_DRI_H_
 
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#endif
 #include "ui/events/ozone/evdev/event_factory.h"
 #include "ui/gfx/ozone/dri/dri_surface_factory.h"
 #include "ui/ozone/ozone_platform.h"
@@ -22,10 +25,17 @@ class OzonePlatformDri : public OzonePlatform {
 
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() OVERRIDE;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() OVERRIDE;
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone*
+    GetOutputConfiguratorOzone() OVERRIDE;
+#endif
 
  private:
   gfx::DriSurfaceFactory surface_factory_ozone_;
   ui::EventFactoryEvdev event_factory_ozone_;
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzoneDri output_configurator_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformDri);
 };
diff --git a/ui/ozone/platform/test/ozone_platform_test.cc b/ui/ozone/platform/test/ozone_platform_test.cc
index 860837e..4830522 100644
--- a/ui/ozone/platform/test/ozone_platform_test.cc
+++ b/ui/ozone/platform/test/ozone_platform_test.cc
@@ -24,6 +24,13 @@ ui::EventFactoryOzone* OzonePlatformTest::GetEventFactoryOzone() {
   return &event_factory_ozone_;
 }
 
+#if defined(OS_CHROMEOS)
+chromeos::OutputConfiguratorOzone*
+  OzonePlatformTest::GetOutputConfiguratorOzone() {
+  return &output_configurator_;
+}
+#endif
+
 OzonePlatform* CreateOzonePlatformTest() {
   CommandLine* cmd = CommandLine::ForCurrentProcess();
   base::FilePath location = base::FilePath("/dev/null");
diff --git a/ui/ozone/platform/test/ozone_platform_test.h b/ui/ozone/platform/test/ozone_platform_test.h
index bb199a3..e273f52 100644
--- a/ui/ozone/platform/test/ozone_platform_test.h
+++ b/ui/ozone/platform/test/ozone_platform_test.h
@@ -6,6 +6,9 @@
 #define UI_OZONE_PLATFORM_TEST_OZONE_PLATFORM_TEST_H_
 
 #include "base/files/file_path.h"
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#endif
 #include "ui/events/ozone/evdev/event_factory.h"
 #include "ui/gfx/ozone/impl/file_surface_factory.h"
 #include "ui/ozone/ozone_platform.h"
@@ -22,10 +25,16 @@ class OzonePlatformTest : public OzonePlatform {
 
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() OVERRIDE;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() OVERRIDE;
-
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone*
+    GetOutputConfiguratorOzone() OVERRIDE;
+#endif
  private:
   gfx::FileSurfaceFactory surface_factory_ozone_;
   ui::EventFactoryEvdev event_factory_ozone_;
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzoneDri output_configurator_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformTest);
 };
-- 
1.7.9.5

