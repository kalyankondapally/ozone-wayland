From ecc8470b3995a804a3fb52edb46b5cb43cb059bb Mon Sep 17 00:00:00 2001
From: Kondapally Kalyan <kalyan.kondapally@intel.com>
Date: Mon, 11 Nov 2013 01:05:06 +0200
Subject: [PATCH 11/11] WIP: Add initial support for OutputConfigurator with
 Ozone platform.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Output Configurator is responsible for output manipulation on Chrome-OS
with X11. Itâ€™s thus only included in X11 builds. we need  an ozone
implementation for supporting the same with Ozone. This patch tries to
seperate X11 dependencies and ability to provide a custom implmentation
when on Ozone platform.
---
 ash/ash.gyp                                        |    8 -
 .../display_change_observer_chromeos_unittest.cc   |    1 -
 ash/shell.cc                                       |   50 +-
 ash/shell.h                                        |    6 +-
 chromeos/chromeos.gyp                              |   22 +-
 chromeos/display/output_configurator.cc            |  125 +---
 chromeos/display/output_configurator.h             |   62 +-
 chromeos/display/output_configurator_ozone.cc      |   34 ++
 chromeos/display/output_configurator_ozone.h       |   34 ++
 chromeos/display/output_configurator_ozone_dri.cc  |   44 ++
 chromeos/display/output_configurator_ozone_dri.h   |   30 +
 chromeos/display/output_configurator_unittest.cc   |   57 +-
 chromeos/display/output_configurator_x11.cc        |  137 +++++
 chromeos/display/output_configurator_x11.h         |   41 ++
 chromeos/display/output_util.cc                    |   75 ---
 chromeos/display/output_util.h                     |   39 +-
 chromeos/display/output_util_dri.cc                |   22 +
 chromeos/display/output_util_unittest.cc           |    2 -
 chromeos/display/output_util_x11.cc                |   77 +++
 .../display/real_output_configurator_delegate.cc   |  614 -------------------
 .../display/real_output_configurator_delegate.h    |  100 ----
 .../real_output_configurator_delegate_dri.cc       |   96 +++
 .../real_output_configurator_delegate_dri.h        |   54 ++
 .../real_output_configurator_delegate_x11.cc       |  616 ++++++++++++++++++++
 .../real_output_configurator_delegate_x11.h        |  100 ++++
 ui/ozone/ozone_platform.cc                         |    4 +
 ui/ozone/ozone_platform.h                          |    6 +
 ui/ozone/platform/dri/ozone_platform_dri.cc        |    7 +
 ui/ozone/platform/dri/ozone_platform_dri.h         |   10 +
 ui/ozone/platform/test/ozone_platform_test.cc      |    7 +
 ui/ozone/platform/test/ozone_platform_test.h       |   11 +-
 31 files changed, 1470 insertions(+), 1021 deletions(-)
 create mode 100644 chromeos/display/output_configurator_ozone.cc
 create mode 100644 chromeos/display/output_configurator_ozone.h
 create mode 100644 chromeos/display/output_configurator_ozone_dri.cc
 create mode 100644 chromeos/display/output_configurator_ozone_dri.h
 create mode 100644 chromeos/display/output_configurator_x11.cc
 create mode 100644 chromeos/display/output_configurator_x11.h
 create mode 100644 chromeos/display/output_util_dri.cc
 create mode 100644 chromeos/display/output_util_x11.cc
 delete mode 100644 chromeos/display/real_output_configurator_delegate.cc
 delete mode 100644 chromeos/display/real_output_configurator_delegate.h
 create mode 100644 chromeos/display/real_output_configurator_delegate_dri.cc
 create mode 100644 chromeos/display/real_output_configurator_delegate_dri.h
 create mode 100644 chromeos/display/real_output_configurator_delegate_x11.cc
 create mode 100644 chromeos/display/real_output_configurator_delegate_x11.h

diff --git a/ash/ash.gyp b/ash/ash.gyp
index b1022ae..a885599 100644
--- a/ash/ash.gyp
+++ b/ash/ash.gyp
@@ -598,14 +598,6 @@
             ['exclude', 'system/monitor/tray_monitor.h'],
           ],
         }],
-        ['use_x11!=1', {
-          'sources/': [
-            ['exclude', 'display/display_change_observer_chromeos.cc'],
-            ['exclude', 'display/display_change_observer_chromeos.h'],
-            ['exclude', 'display/display_error_observer_chromeos.cc'],
-            ['exclude', 'display/display_error_observer_chromeos.h'],
-          ],
-        }],
         ['chromeos==1', {
           'dependencies': [
             '../chromeos/chromeos.gyp:chromeos',
diff --git a/ash/display/display_change_observer_chromeos_unittest.cc b/ash/display/display_change_observer_chromeos_unittest.cc
index a437aec..b466e17 100644
--- a/ash/display/display_change_observer_chromeos_unittest.cc
+++ b/ash/display/display_change_observer_chromeos_unittest.cc
@@ -6,7 +6,6 @@
 
 #include "ash/display/display_info.h"
 #include "chromeos/display/output_configurator.h"
-#include "chromeos/display/output_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 using chromeos::OutputConfigurator;
diff --git a/ash/shell.cc b/ash/shell.cc
index 63f15d2..fd80437 100644
--- a/ash/shell.cc
+++ b/ash/shell.cc
@@ -115,16 +115,18 @@
 
 #if defined(OS_CHROMEOS)
 #if defined(USE_X11)
+#include "chromeos/display/output_configurator_x11.h"
+#elif defined(USE_OZONE)
+#include "ui/ozone/ozone_platform.h"
+#endif  // defined(USE_X11)
+
 #include "ash/ash_constants.h"
 #include "ash/display/display_change_observer_chromeos.h"
 #include "ash/display/display_error_observer_chromeos.h"
 #include "ash/display/output_configurator_animation.h"
-#include "base/message_loop/message_pump_x11.h"
 #include "base/sys_info.h"
-#include "chromeos/display/output_configurator.h"
 #include "content/public/browser/gpu_data_manager.h"
 #include "gpu/config/gpu_feature_type.h"
-#endif  // defined(USE_X11)
 #include "ash/system/chromeos/brightness/brightness_controller_chromeos.h"
 #include "ash/system/chromeos/power/power_event_observer.h"
 #include "ash/system/chromeos/power/power_status.h"
@@ -534,6 +536,19 @@ void Shell::DoInitialWorkspaceAnimation() {
 ////////////////////////////////////////////////////////////////////////////////
 // Shell, private:
 
+#if defined(OS_CHROMEOS)
+chromeos::OutputConfigurator* CreateOuputConfigurator() {
+#if defined(USE_OZONE)
+  ui::OzonePlatform::Initialize();
+  return chromeos::OutputConfiguratorOzone::GetInstance();
+#elif defined(USE_X11)
+  return new chromeos::OutputConfiguratorX11();
+#endif
+
+  NOTREACHED();
+  return 0;
+}
+#endif
 Shell::Shell(ShellDelegate* delegate)
     : screen_(new ScreenAsh),
       target_root_window_(NULL),
@@ -541,9 +556,9 @@ Shell::Shell(ShellDelegate* delegate)
       delegate_(delegate),
       window_positioner_(new WindowPositioner),
       activation_client_(NULL),
-#if defined(OS_CHROMEOS) && defined(USE_X11)
-      output_configurator_(new chromeos::OutputConfigurator()),
-#endif  // defined(OS_CHROMEOS) && defined(USE_X11)
+#if defined(OS_CHROMEOS)
+      output_configurator_(CreateOuputConfigurator()),
+#endif  // defined(OS_CHROMEOS)
       native_cursor_manager_(new AshNativeCursorManager),
       cursor_manager_(scoped_ptr<views::corewm::NativeCursorManager>(
           native_cursor_manager_)),
@@ -557,21 +572,13 @@ Shell::Shell(ShellDelegate* delegate)
   if (!gfx::Screen::GetScreenByType(gfx::SCREEN_TYPE_NATIVE))
     gfx::Screen::SetScreenInstance(gfx::SCREEN_TYPE_NATIVE, screen_);
   display_controller_.reset(new DisplayController);
-#if defined(OS_CHROMEOS) && defined(USE_X11)
+#if defined(OS_CHROMEOS)
   bool is_panel_fitting_disabled =
       content::GpuDataManager::GetInstance()->IsFeatureBlacklisted(
           gpu::GPU_FEATURE_TYPE_PANEL_FITTING);
 
   output_configurator_->Init(!is_panel_fitting_disabled);
-
-  base::MessagePumpX11::Current()->AddDispatcherForRootWindow(
-      output_configurator());
-  // We can't do this with a root window listener because XI_HierarchyChanged
-  // messages don't have a target window.
-  base::MessagePumpX11::Current()->AddObserver(output_configurator());
-#endif  // defined(OS_CHROMEOS)
-
-#if defined(OS_CHROMEOS)
+  output_configurator_->StartProcessingEvents();
   internal::PowerStatus::Initialize();
 #endif
 }
@@ -669,16 +676,15 @@ Shell::~Shell() {
   new_window_delegate_.reset();
   media_delegate_.reset();
 
-#if defined(OS_CHROMEOS) && defined(USE_X11)
+#if defined(OS_CHROMEOS)
    if (display_change_observer_)
     output_configurator_->RemoveObserver(display_change_observer_.get());
   if (output_configurator_animation_)
     output_configurator_->RemoveObserver(output_configurator_animation_.get());
   if (display_error_observer_)
     output_configurator_->RemoveObserver(display_error_observer_.get());
-  base::MessagePumpX11::Current()->RemoveDispatcherForRootWindow(
-      output_configurator());
-  base::MessagePumpX11::Current()->RemoveObserver(output_configurator());
+
+  output_configurator_->StopProcessingEvents();
   display_change_observer_.reset();
 #endif  // defined(OS_CHROMEOS)
 
@@ -699,7 +705,7 @@ void Shell::Init() {
         internal::DisplayManager::VIRTUAL_KEYBOARD);
   }
   bool display_initialized = display_manager_->InitFromCommandLine();
-#if defined(OS_CHROMEOS) && defined(USE_X11)
+#if defined(OS_CHROMEOS)
   output_configurator_animation_.reset(
       new internal::OutputConfiguratorAnimation());
   output_configurator_->AddObserver(output_configurator_animation_.get());
@@ -717,7 +723,7 @@ void Shell::Init() {
         delegate_->IsFirstRunAfterBoot() ? kChromeOsBootColor : 0);
     display_initialized = true;
   }
-#endif  // defined(OS_CHROMEOS) && defined(USE_X11)
+#endif  // defined(OS_CHROMEOS)
   if (!display_initialized)
     display_manager_->InitDefaultDisplay();
 
diff --git a/ash/shell.h b/ash/shell.h
index 583e50c..0783e2d 100644
--- a/ash/shell.h
+++ b/ash/shell.h
@@ -473,7 +473,7 @@ class ASH_EXPORT Shell
   // Starts the animation that occurs on first login.
   void DoInitialWorkspaceAnimation();
 
-#if defined(OS_CHROMEOS) && defined(USE_X11)
+#if defined(OS_CHROMEOS)
   // TODO(oshima): Move these objects to DisplayController.
   chromeos::OutputConfigurator* output_configurator() {
     return output_configurator_.get();
@@ -484,7 +484,7 @@ class ASH_EXPORT Shell
   internal::DisplayErrorObserver* display_error_observer() {
     return display_error_observer_.get();
   }
-#endif  // defined(OS_CHROMEOS) && defined(USE_X11)
+#endif  // defined(OS_CHROMEOS)
 
   internal::ResolutionNotificationController*
       resolution_notification_controller() {
@@ -660,7 +660,6 @@ class ASH_EXPORT Shell
   scoped_ptr<internal::UserActivityNotifier> user_activity_notifier_;
   scoped_ptr<internal::VideoActivityNotifier> video_activity_notifier_;
   scoped_ptr<StickyKeys> sticky_keys_;
-#if defined(USE_X11)
   // Controls video output device state.
   scoped_ptr<chromeos::OutputConfigurator> output_configurator_;
   scoped_ptr<internal::OutputConfiguratorAnimation>
@@ -669,7 +668,6 @@ class ASH_EXPORT Shell
 
   // Listens for output changes and updates the display manager.
   scoped_ptr<internal::DisplayChangeObserver> display_change_observer_;
-#endif  // defined(USE_X11)
 #endif  // defined(OS_CHROMEOS)
 
   scoped_ptr<internal::ResolutionNotificationController>
diff --git a/chromeos/chromeos.gyp b/chromeos/chromeos.gyp
index 778b016..218e0d8 100644
--- a/chromeos/chromeos.gyp
+++ b/chromeos/chromeos.gyp
@@ -206,10 +206,20 @@
         'disks/disk_mount_manager.h',
         'display/output_configurator.cc',
         'display/output_configurator.h',
+        'display/output_configurator_x11.cc',
+        'display/output_configurator_x11.h',
+        'display/output_configurator_ozone.cc',
+        'display/output_configurator_ozone.h',
+        'display/output_configurator_ozone_dri.cc',
+        'display/output_configurator_ozone_dri.h',
         'display/output_util.cc',
         'display/output_util.h',
-        'display/real_output_configurator_delegate.cc',
-        'display/real_output_configurator_delegate.h',
+        'display/output_util_x11.cc',
+        'display/output_util_dri.cc',
+        'display/real_output_configurator_delegate_x11.cc',
+        'display/real_output_configurator_delegate_x11.h',
+        'display/real_output_configurator_delegate_dri.cc',
+        'display/real_output_configurator_delegate_dri.h',
         'ime/candidate_window.cc',
         'ime/candidate_window.h',
         'ime/component_extension_ime_manager.cc',
@@ -359,14 +369,6 @@
           'sources!': [
             'ime/xkeyboard.cc',
             'ime/xkeyboard.h',
-            'display/output_configurator.cc',
-            'display/output_configurator.h',
-            'display/output_util.cc',
-            'display/output_util.h',
-            'display/real_output_configurator_delegate.cc',
-            'display/real_output_configurator_delegate.h',
-            'ime/xkeyboard.cc',
-            'ime/xkeyboard.h',
           ],
         }],
       ],
diff --git a/chromeos/display/output_configurator.cc b/chromeos/display/output_configurator.cc
index 1a3cc31..6ce5cc3 100644
--- a/chromeos/display/output_configurator.cc
+++ b/chromeos/display/output_configurator.cc
@@ -4,18 +4,16 @@
 
 #include "chromeos/display/output_configurator.h"
 
-#include <X11/Xlib.h>
-#include <X11/extensions/Xrandr.h>
-#include <X11/extensions/XInput2.h>
-
 #include "base/bind.h"
 #include "base/logging.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/stringprintf.h"
 #include "base/sys_info.h"
 #include "base/time/time.h"
-#include "chromeos/display/output_util.h"
-#include "chromeos/display/real_output_configurator_delegate.h"
+
+#ifndef None
+#define None 0L
+#endif
 
 namespace chromeos {
 
@@ -164,37 +162,6 @@ OutputConfigurator::OutputSnapshot::OutputSnapshot()
 
 OutputConfigurator::OutputSnapshot::~OutputSnapshot() {}
 
-void OutputConfigurator::TestApi::SendScreenChangeEvent() {
-  XRRScreenChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRScreenChangeNotify;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
-}
-
-void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
-                                                        RRCrtc crtc,
-                                                        RRMode mode,
-                                                        bool connected) {
-  XRROutputChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRNotify;
-  event.subtype = RRNotify_OutputChange;
-  event.output = output;
-  event.crtc = crtc;
-  event.mode = mode;
-  event.connection = connected ? RR_Connected : RR_Disconnected;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
-}
-
-bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
-  if (configurator_->configure_timer_.get() &&
-      configurator_->configure_timer_->IsRunning()) {
-    configurator_->configure_timer_.reset();
-    configurator_->ConfigureOutputs();
-    return true;
-  } else {
-    return false;
-  }
-}
-
 // static
 const OutputConfigurator::ModeInfo* OutputConfigurator::GetModeInfo(
     const OutputSnapshot& output,
@@ -245,12 +212,22 @@ RRMode OutputConfigurator::FindOutputModeMatchingSize(
   return found;
 }
 
+bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
+  if (configurator_->configure_timer_.get() &&
+      configurator_->configure_timer_->IsRunning()) {
+    configurator_->configure_timer_.reset();
+    configurator_->ConfigureOutputs();
+    return true;
+  } else {
+    return false;
+  }
+}
+
 OutputConfigurator::OutputConfigurator()
     : state_controller_(NULL),
       mirroring_controller_(NULL),
       is_panel_fitting_enabled_(false),
       configure_display_(base::SysInfo::IsRunningOnChromeOS()),
-      xrandr_event_base_(0),
       output_state_(STATE_INVALID),
       power_state_(DISPLAY_POWER_ALL_ON),
       next_output_protection_client_id_(1) {
@@ -274,7 +251,7 @@ void OutputConfigurator::Init(bool is_panel_fitting_enabled) {
     return;
 
   if (!delegate_)
-    delegate_.reset(new RealOutputConfiguratorDelegate());
+    delegate_.reset(CreateDelegate());
 }
 
 void OutputConfigurator::Start(uint32 background_color_argb) {
@@ -282,7 +259,7 @@ void OutputConfigurator::Start(uint32 background_color_argb) {
     return;
 
   delegate_->GrabServer();
-  delegate_->InitXRandRExtension(&xrandr_event_base_);
+  InitializeResources();
 
   UpdateCachedOutputs();
   if (cached_outputs_.size() > 1 && background_color_argb)
@@ -457,6 +434,10 @@ bool OutputConfigurator::EnableOutputProtection(
   return true;
 }
 
+void OutputConfigurator::InitializeResources() {
+  NOTIMPLEMENTED();
+}
+
 void OutputConfigurator::Stop() {
   configure_display_ = false;
 }
@@ -526,73 +507,13 @@ bool OutputConfigurator::SetDisplayMode(OutputState new_state) {
 }
 
 bool OutputConfigurator::Dispatch(const base::NativeEvent& event) {
-  if (!configure_display_)
-    return true;
-
-  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
-    VLOG(1) << "Received RRScreenChangeNotify event";
-    delegate_->UpdateXRandRConfiguration(event);
-    return true;
-  }
-
-  // Bail out early for everything except RRNotify_OutputChange events
-  // about an output getting connected or disconnected.
-  if (event->type - xrandr_event_base_ != RRNotify)
-    return true;
-  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
-  if (notify_event->subtype != RRNotify_OutputChange)
-    return true;
-  const XRROutputChangeNotifyEvent* output_change_event =
-      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
-  const int action = output_change_event->connection;
-  if (action != RR_Connected && action != RR_Disconnected)
-    return true;
-
-  const bool connected = (action == RR_Connected);
-  VLOG(1) << "Received RRNotify_OutputChange event:"
-          << " output=" << output_change_event->output
-          << " crtc=" << output_change_event->crtc
-          << " mode=" << output_change_event->mode
-          << " action=" << (connected ? "connected" : "disconnected");
-
-  bool found_changed_output = false;
-  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs_.begin();
-       it != cached_outputs_.end(); ++it) {
-    if (it->output == output_change_event->output) {
-      if (connected && it->crtc == output_change_event->crtc &&
-          it->current_mode == output_change_event->mode) {
-        VLOG(1) << "Ignoring event describing already-cached state";
-        return true;
-      }
-      found_changed_output = true;
-      break;
-    }
-  }
-
-  if (!connected && !found_changed_output) {
-    VLOG(1) << "Ignoring event describing already-disconnected output";
-    return true;
-  }
-
-  // Connecting/disconnecting a display may generate multiple events. Defer
-  // configuring outputs to avoid grabbing X and configuring displays
-  // multiple times.
-  ScheduleConfigureOutputs();
+  NOTIMPLEMENTED();
   return true;
 }
 
 base::EventStatus OutputConfigurator::WillProcessEvent(
     const base::NativeEvent& event) {
-  // XI_HierarchyChanged events are special. There is no window associated with
-  // these events. So process them directly from here.
-  if (configure_display_ && event->type == GenericEvent &&
-      event->xgeneric.evtype == XI_HierarchyChanged) {
-    VLOG(1) << "Received XI_HierarchyChanged event";
-    // Defer configuring outputs to not stall event processing.
-    // This also takes care of same event being received twice.
-    ScheduleConfigureOutputs();
-  }
-
+  NOTIMPLEMENTED();
   return base::EVENT_CONTINUE;
 }
 
diff --git a/chromeos/display/output_configurator.h b/chromeos/display/output_configurator.h
index ef5085e..0b4bd90 100644
--- a/chromeos/display/output_configurator.h
+++ b/chromeos/display/output_configurator.h
@@ -20,10 +20,10 @@
 
 // Forward declarations for Xlib and Xrandr.
 // This is so unused X definitions don't pollute the namespace.
-typedef unsigned long XID;
-typedef XID RROutput;
-typedef XID RRCrtc;
-typedef XID RRMode;
+typedef unsigned long OUTPUTID;
+typedef OUTPUTID RROutput;
+typedef OUTPUTID RRCrtc;
+typedef OUTPUTID RRMode;
 
 namespace chromeos {
 
@@ -195,17 +195,17 @@ class CHROMEOS_EXPORT OutputConfigurator
    public:
     virtual ~Delegate() {}
 
-    // Initializes the XRandR extension, saving the base event ID to
-    // |event_base|.
-    virtual void InitXRandRExtension(int* event_base) = 0;
+    // Initializes any native resources, returns the base event ID.
+    virtual int InitResources() = 0;
 
-    // Tells XRandR to update its configuration in response to |event|, an
-    // RRScreenChangeNotify event.
-    virtual void UpdateXRandRConfiguration(const base::NativeEvent& event) = 0;
+    // Inform platform to update its configuration in response to |event|,
+    // an native ScreenChangeNotification event.
+    virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) = 0;
 
-    // Grabs the X server and refreshes XRandR-related resources.  While
-    // the server is grabbed, other clients are blocked.  Must be balanced
-    // by a call to UngrabServer().
+    // Configurator will call this api before fetching output properties. The
+    // delegate needs to ensure that no other client is able to update the
+    // display until UngrabServer is called.
     virtual void GrabServer() = 0;
 
     // Ungrabs the server and frees XRandR-related resources.
@@ -266,9 +266,9 @@ class CHROMEOS_EXPORT OutputConfigurator
   // Helper class used by tests.
   class TestApi {
    public:
-    TestApi(OutputConfigurator* configurator, int xrandr_event_base)
+    TestApi(OutputConfigurator* configurator, int native_event_base)
         : configurator_(configurator),
-          xrandr_event_base_(xrandr_event_base) {}
+          native_event_base_(native_event_base) {}
     ~TestApi() {}
 
     const std::vector<OutputSnapshot>& cached_outputs() const {
@@ -291,7 +291,7 @@ class CHROMEOS_EXPORT OutputConfigurator
    private:
     OutputConfigurator* configurator_;  // not owned
 
-    int xrandr_event_base_;
+    int native_event_base_;
 
     DISALLOW_COPY_AND_ASSIGN(TestApi);
   };
@@ -383,6 +383,13 @@ class CHROMEOS_EXPORT OutputConfigurator
   void AddObserver(Observer* observer);
   void RemoveObserver(Observer* observer);
 
+  // This should be called to set OutputConfigurator as the dispatcher for root
+  // window or start listening to hierarchy changed events.
+  virtual void StartProcessingEvents() { }
+  // This should be called to remove OutputConfigurator as dispatcher for root
+  // window.
+  virtual void StopProcessingEvents() { }
+
   // Sets all the displays into pre-suspend mode; usually this means
   // configure them for their resume state. This allows faster resume on
   // machines where display configuration is slow.
@@ -427,6 +434,25 @@ class CHROMEOS_EXPORT OutputConfigurator
       int64 display_id,
       uint32_t desired_protection_mask);
 
+ protected:
+  // This is called before doing initial configuration of displays during
+  // startup i.e. from Start(). Any necessary native resources should be
+  // initialized here.
+  virtual void InitializeResources();
+
+  // Create Delegate to be used by the Configurator.
+  virtual Delegate* CreateDelegate() = 0;
+
+  // Returns cached outputs.
+  const std::vector<OutputSnapshot>& GetCachedOutputs() const {
+    return cached_outputs_;
+  }
+
+  // Returns delegate used by Configurator.
+  Delegate* GetDelegate() const { return delegate_.get(); }
+
+  bool HandleConfigureDisplay() const { return configure_display_; }
+
  private:
   // Mapping a display_id to a protection request bitmask.
   typedef std::map<int64, uint32_t> DisplayProtections;
@@ -517,10 +543,6 @@ class CHROMEOS_EXPORT OutputConfigurator
   // configuration to immediately fail without changing the state.
   bool configure_display_;
 
-  // The base of the event numbers used to represent XRandr events used in
-  // decoding events regarding output add/remove.
-  int xrandr_event_base_;
-
   // The current display state.
   OutputState output_state_;
 
diff --git a/chromeos/display/output_configurator_ozone.cc b/chromeos/display/output_configurator_ozone.cc
new file mode 100644
index 0000000..44a2c84
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_ozone.h"
+
+namespace chromeos {
+
+// static
+OutputConfigurator* OutputConfiguratorOzone::impl_ = NULL;
+
+OutputConfiguratorOzone::OutputConfiguratorOzone()
+    : OutputConfigurator() {
+}
+
+OutputConfiguratorOzone::~OutputConfiguratorOzone() {
+
+}
+
+OutputConfigurator* OutputConfiguratorOzone::GetInstance() {
+  CHECK(impl_) << "No OutputConfiguratorOzone implementation set.";
+  return impl_;
+}
+
+void OutputConfiguratorOzone::SetInstance(OutputConfigurator* impl) {
+  impl_ = impl;
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorOzone::CreateDelegate() {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_configurator_ozone.h b/chromeos/display/output_configurator_ozone.h
new file mode 100644
index 0000000..f9b9749
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
+
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+
+class CHROMEOS_EXPORT OutputConfiguratorOzone : public OutputConfigurator {
+ public:
+  OutputConfiguratorOzone();
+  virtual ~OutputConfiguratorOzone();
+
+  // Returns the static instance last set using SetInstance().
+  static OutputConfigurator* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(OutputConfigurator*);
+
+ protected:
+  virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+ private:
+  static OutputConfigurator* impl_;  // not owned
+
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorOzone);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_H_
diff --git a/chromeos/display/output_configurator_ozone_dri.cc b/chromeos/display/output_configurator_ozone_dri.cc
new file mode 100644
index 0000000..f2458f8
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone_dri.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#include "chromeos/display/real_output_configurator_delegate_dri.h"
+
+#include "base/message_loop/message_pump_ozone.h"
+
+namespace chromeos {
+
+void OutputConfigurator::TestApi::SendScreenChangeEvent() {
+  NOTIMPLEMENTED();
+}
+
+void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
+                                                        RRCrtc crtc,
+                                                        RRMode mode,
+                                                        bool connected) {
+  NOTIMPLEMENTED();
+}
+
+OutputConfiguratorOzoneDri::OutputConfiguratorOzoneDri()
+    : OutputConfiguratorOzone() {
+}
+
+OutputConfiguratorOzoneDri::~OutputConfiguratorOzoneDri() {
+
+}
+
+void OutputConfiguratorOzoneDri::StartProcessingEvents() {
+  base::MessagePumpOzone::Current()->AddObserver(this);
+}
+
+void OutputConfiguratorOzoneDri::StopProcessingEvents() {
+  base::MessagePumpOzone::Current()->RemoveObserver(this);
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorOzoneDri::CreateDelegate() {
+  return new RealOutputConfiguratorDelegateDri();
+}
+
+}  // namespace chromeos
+
diff --git a/chromeos/display/output_configurator_ozone_dri.h b/chromeos/display/output_configurator_ozone_dri.h
new file mode 100644
index 0000000..e23628b
--- /dev/null
+++ b/chromeos/display/output_configurator_ozone_dri.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+
+#include "chromeos/display/output_configurator_ozone.h"
+
+namespace chromeos {
+
+class CHROMEOS_EXPORT OutputConfiguratorOzoneDri
+    : public OutputConfiguratorOzone {
+ public:
+  OutputConfiguratorOzoneDri();
+  virtual ~OutputConfiguratorOzoneDri();
+  virtual void StartProcessingEvents() OVERRIDE;
+  virtual void StopProcessingEvents() OVERRIDE;
+
+protected:
+ virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorOzoneDri);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_OZONE_DRI_H_
+
diff --git a/chromeos/display/output_configurator_unittest.cc b/chromeos/display/output_configurator_unittest.cc
index 28f0553..93b172b 100644
--- a/chromeos/display/output_configurator_unittest.cc
+++ b/chromeos/display/output_configurator_unittest.cc
@@ -2,7 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "chromeos/display/output_configurator.h"
+#if defined(USE_X11)
+#include "chromeos/display/output_configurator_x11.h"
+#endif
 
 #include <cstdarg>
 #include <map>
@@ -21,8 +23,8 @@ namespace {
 
 // Strings returned by TestDelegate::GetActionsAndClear() to describe various
 // actions that were performed.
-const char kInitXRandR[] = "init";
-const char kUpdateXRandR[] = "update";
+const char kInit[] = "init";
+const char kScreenChangeNotification[] = "update";
 const char kGrab[] = "grab";
 const char kUngrab[] = "ungrab";
 const char kSync[] = "sync";
@@ -98,7 +100,7 @@ std::string JoinActions(const char* action, ...) {
 
 class TestDelegate : public OutputConfigurator::Delegate {
  public:
-  static const int kXRandREventBase = 10;
+  static const int kNativeEventBase = 10;
 
   TestDelegate()
       : configure_crtc_result_(true),
@@ -129,12 +131,13 @@ class TestDelegate : public OutputConfigurator::Delegate {
   }
 
   // OutputConfigurator::Delegate overrides:
-  virtual void InitXRandRExtension(int* event_base) OVERRIDE {
-    AppendAction(kInitXRandR);
-    *event_base = kXRandREventBase;
+  virtual int InitResources() OVERRIDE {
+    AppendAction(kInit);
+    return kNativeEventBase;
   }
-  virtual void UpdateXRandRConfiguration(
-      const base::NativeEvent& event) OVERRIDE { AppendAction(kUpdateXRandR); }
+  virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) OVERRIDE {
+    AppendAction(kScreenChangeNotification); }
   virtual void GrabServer() OVERRIDE { AppendAction(kGrab); }
   virtual void UngrabServer() OVERRIDE { AppendAction(kUngrab); }
   virtual void SyncWithServer() OVERRIDE { AppendAction(kSync); }
@@ -330,7 +333,7 @@ class OutputConfiguratorTest : public testing::Test {
 
   OutputConfiguratorTest()
       : observer_(&configurator_),
-        test_api_(&configurator_, TestDelegate::kXRandREventBase) {}
+        test_api_(&configurator_, TestDelegate::kNativeEventBase) {}
   virtual ~OutputConfiguratorTest() {}
 
   virtual void SetUp() OVERRIDE {
@@ -409,7 +412,7 @@ class OutputConfiguratorTest : public testing::Test {
     configurator_.Init(false);
     EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
     configurator_.Start(0);
-    EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
+    EXPECT_EQ(JoinActions(kGrab, kInit,
                           GetFramebufferAction(kSmallModeWidth,
                               kSmallModeHeight, outputs_[0].crtc, 0).c_str(),
                           GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -421,7 +424,9 @@ class OutputConfiguratorTest : public testing::Test {
   base::MessageLoop message_loop_;
   TestStateController state_controller_;
   TestMirroringController mirroring_controller_;
-  OutputConfigurator configurator_;
+#if defined(USE_X11)
+  OutputConfiguratorX11 configurator_;
+#endif
   TestObserver observer_;
   TestDelegate* delegate_;  // not owned
   OutputConfigurator::TestApi test_api_;
@@ -512,7 +517,7 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
   UpdateOutputs(2, true);
   const int kDualHeight =
       kSmallModeHeight + OutputConfigurator::kVerticalGap + kBigModeHeight;
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kBigModeWidth, kDualHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -542,7 +547,7 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
   // Disconnect the second output.
   observer_.Reset();
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, 0).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -556,7 +561,7 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
   outputs_[1].mode_infos.erase(kSmallModeId);
   state_controller_.set_state(STATE_DUAL_EXTENDED);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kBigModeWidth, kDualHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -594,7 +599,7 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
   // Disconnect the second output.
   observer_.Reset();
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, 0).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -611,7 +616,7 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   state_controller_.set_state(STATE_DUAL_MIRROR);
   observer_.Reset();
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -682,7 +687,7 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   UpdateOutputs(2, true);
   const int kDualHeight =
       kSmallModeHeight + OutputConfigurator::kVerticalGap + kBigModeHeight;
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kBigModeWidth, kDualHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -803,7 +808,7 @@ TEST_F(OutputConfiguratorTest, SuspendAndResume) {
   // powered back on before suspending.
   state_controller_.set_state(STATE_DUAL_MIRROR);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -848,7 +853,7 @@ TEST_F(OutputConfiguratorTest, Headless) {
   configurator_.Init(false);
   EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
   configurator_.Start(0);
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR, kForceDPMS, kUngrab,
+  EXPECT_EQ(JoinActions(kGrab, kInit, kForceDPMS, kUngrab,
                         kProjectingOff, NULL),
             delegate_->GetActionsAndClear());
 
@@ -865,7 +870,7 @@ TEST_F(OutputConfiguratorTest, Headless) {
   // Connect an external display and check that it's configured correctly.
   outputs_[0] = outputs_[1];
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kBigModeWidth, kBigModeHeight,
                             outputs_[0].crtc, 0).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kBigModeId,
@@ -882,7 +887,7 @@ TEST_F(OutputConfiguratorTest, StartWithTwoOutputs) {
 
   state_controller_.set_state(STATE_DUAL_MIRROR);
   configurator_.Start(0);
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
+  EXPECT_EQ(JoinActions(kGrab, kInit,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -951,7 +956,7 @@ TEST_F(OutputConfiguratorTest, AvoidUnnecessaryProbes) {
   // the output change events don't trigger an additional probe, which can
   // block the UI thread.
   test_api_.SendScreenChangeEvent();
-  EXPECT_EQ(kUpdateXRandR, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kScreenChangeNotification, delegate_->GetActionsAndClear());
 
   test_api_.SendOutputChangeEvent(
       outputs_[0].output, outputs_[0].crtc, outputs_[0].current_mode, true);
@@ -994,7 +999,7 @@ TEST_F(OutputConfiguratorTest, AvoidUnnecessaryProbes) {
 
   // Disconnect the second output.
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, 0).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -1013,7 +1018,7 @@ TEST_F(OutputConfiguratorTest, AvoidUnnecessaryProbes) {
   // second output sticking with its native mode.
   delegate_->set_configure_crtc_result(false);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
+  EXPECT_EQ(JoinActions(kScreenChangeNotification, kGrab,
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
                             outputs_[0].crtc, outputs_[1].crtc).c_str(),
                         GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
@@ -1079,7 +1084,7 @@ TEST_F(OutputConfiguratorTest, PanelFitting) {
   configurator_.Init(true /* is_panel_fitting_enabled */);
   configurator_.Start(0);
   EXPECT_EQ(STATE_DUAL_MIRROR, configurator_.output_state());
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
+  EXPECT_EQ(JoinActions(kGrab, kInit,
                         GetAddOutputModeAction(
                             outputs_[0].output, kSmallModeId).c_str(),
                         GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
diff --git a/chromeos/display/output_configurator_x11.cc b/chromeos/display/output_configurator_x11.cc
new file mode 100644
index 0000000..0d48c44
--- /dev/null
+++ b/chromeos/display/output_configurator_x11.cc
@@ -0,0 +1,137 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_configurator_x11.h"
+
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/extensions/XInput2.h>
+
+#include "chromeos/display/real_output_configurator_delegate.h"
+#include "base/message_loop/message_pump_x11.h"
+
+namespace chromeos {
+
+void OutputConfigurator::TestApi::SendScreenChangeEvent() {
+  XRRScreenChangeNotifyEvent event = {0};
+  event.type = native_event_base_ + RRScreenChangeNotify;
+  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
+}
+
+void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
+                                                        RRCrtc crtc,
+                                                        RRMode mode,
+                                                        bool connected) {
+  XRROutputChangeNotifyEvent event = {0};
+  event.type = native_event_base_ + RRNotify;
+  event.subtype = RRNotify_OutputChange;
+  event.output = output;
+  event.crtc = crtc;
+  event.mode = mode;
+  event.connection = connected ? RR_Connected : RR_Disconnected;
+  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
+}
+
+OutputConfiguratorX11::OutputConfiguratorX11()
+    : OutputConfigurator(),
+      xrandr_event_base_(0) {
+}
+
+OutputConfiguratorX11::~OutputConfiguratorX11() {
+
+}
+
+void OutputConfiguratorX11::StartProcessingEvents() {
+  base::MessagePumpX11::Current()->AddDispatcherForRootWindow(this);
+  // We can't do this with a root window listener because XI_HierarchyChanged
+  // messages don't have a target window.
+  base::MessagePumpX11::Current()->AddObserver(this);
+}
+
+void OutputConfiguratorX11::StopProcessingEvents() {
+  base::MessagePumpX11::Current()->RemoveDispatcherForRootWindow(this);
+  base::MessagePumpX11::Current()->RemoveObserver(this);
+}
+
+void OutputConfiguratorX11::InitializeResources() {
+  xrandr_event_base_ = GetDelegate()->InitResources();
+}
+
+OutputConfigurator::Delegate* OutputConfiguratorX11::CreateDelegate() {
+  return new RealOutputConfiguratorDelegate();
+}
+
+bool OutputConfiguratorX11::Dispatch(const base::NativeEvent& event) {
+  if (!HandleConfigureDisplay())
+    return true;
+
+  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
+      VLOG(1) << "Received RRScreenChangeNotify event";
+      GetDelegate()->HandleScreenChangeNotification(event);
+      return true;
+  }
+
+  // Bail out early for everything except RRNotify_OutputChange events
+  // about an output getting connected or disconnected.
+  if (event->type - xrandr_event_base_ != RRNotify)
+    return true;
+  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
+  if (notify_event->subtype != RRNotify_OutputChange)
+    return true;
+  const XRROutputChangeNotifyEvent* output_change_event =
+      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
+  const int action = output_change_event->connection;
+  if (action != RR_Connected && action != RR_Disconnected)
+    return true;
+
+  const bool connected = (action == RR_Connected);
+  VLOG(1) << "Received RRNotify_OutputChange event:"
+          << " output=" << output_change_event->output
+          << " crtc=" << output_change_event->crtc
+          << " mode=" << output_change_event->mode
+          << " action=" << (connected ? "connected" : "disconnected");
+
+  bool found_changed_output = false;
+  const std::vector<OutputSnapshot>& cached_outputs = GetCachedOutputs();
+  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs.begin();
+       it != cached_outputs.end(); ++it) {
+    if (it->output == output_change_event->output) {
+      if (connected && it->crtc == output_change_event->crtc &&
+          it->current_mode == output_change_event->mode) {
+        VLOG(1) << "Ignoring event describing already-cached state";
+        return true;
+      }
+      found_changed_output = true;
+      break;
+    }
+  }
+
+  if (!connected && !found_changed_output) {
+    VLOG(1) << "Ignoring event describing already-disconnected output";
+    return true;
+  }
+
+  // Connecting/disconnecting a display may generate multiple events. Defer
+  // configuring outputs to avoid grabbing X and configuring displays
+  // multiple times.
+  ScheduleConfigureOutputs();
+  return true;
+}
+
+base::EventStatus OutputConfiguratorX11::WillProcessEvent(
+    const base::NativeEvent& event) {
+  // XI_HierarchyChanged events are special. There is no window associated with
+  // these events. So process them directly from here.
+  if (HandleConfigureDisplay() && event->type == GenericEvent &&
+      event->xgeneric.evtype == XI_HierarchyChanged) {
+    VLOG(1) << "Received XI_HierarchyChanged event";
+    // Defer configuring outputs to not stall event processing.
+    // This also takes care of same event being received twice.
+    ScheduleConfigureOutputs();
+  }
+
+  return base::EVENT_CONTINUE;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_configurator_x11.h b/chromeos/display/output_configurator_x11.h
new file mode 100644
index 0000000..541fa84
--- /dev/null
+++ b/chromeos/display/output_configurator_x11.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
+#define CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
+
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+// This class interacts directly with the underlying Xrandr API to manipulate
+// CTRCs and Outputs.
+
+class CHROMEOS_EXPORT OutputConfiguratorX11 : public OutputConfigurator {
+ public:
+
+  OutputConfiguratorX11();
+  virtual ~OutputConfiguratorX11();
+
+  virtual void StartProcessingEvents() OVERRIDE;
+  virtual void StopProcessingEvents() OVERRIDE;
+
+  // Overridden from base::MessagePumpObserver:
+  virtual base::EventStatus WillProcessEvent(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual bool Dispatch(const base::NativeEvent& event) OVERRIDE;
+
+ protected:
+  virtual void InitializeResources() OVERRIDE;
+  virtual OutputConfigurator::Delegate* CreateDelegate() OVERRIDE;
+
+  // The base of the event numbers used to represent XRandr events used in
+  // decoding events regarding output add/remove.
+  int xrandr_event_base_;
+
+  DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorX11);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_X11_H_
diff --git a/chromeos/display/output_util.cc b/chromeos/display/output_util.cc
index a1485b4..b920ded 100644
--- a/chromeos/display/output_util.cc
+++ b/chromeos/display/output_util.cc
@@ -3,13 +3,7 @@
 // found in the LICENSE file.
 
 #include "chromeos/display/output_util.h"
-
-#include <X11/extensions/Xrandr.h>
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-
 #include "base/strings/string_util.h"
-#include "base/x11/edid_parser_x11.h"
 
 namespace chromeos {
 namespace {
@@ -18,44 +12,8 @@ namespace {
 const char kInternal_LVDS[] = "LVDS";
 const char kInternal_eDP[] = "eDP";
 const char kInternal_DSI[] = "DSI";
-
-// Gets some useful data from the specified output device, such like
-// manufacturer's ID, product code, and human readable name. Returns false if it
-// fails to get those data and doesn't touch manufacturer ID/product code/name.
-// NULL can be passed for unwanted output parameters.
-bool GetOutputDeviceData(XID output,
-                         uint16* manufacturer_id,
-                         std::string* human_readable_name) {
-  unsigned long nitems = 0;
-  unsigned char *prop = NULL;
-  if (!base::GetEDIDProperty(output, &nitems, &prop))
-    return false;
-
-  bool result = base::ParseOutputDeviceData(
-      prop, nitems, manufacturer_id, human_readable_name);
-  XFree(prop);
-  return result;
-}
-
 }  // namespace
 
-std::string GetDisplayName(XID output_id) {
-  std::string display_name;
-  GetOutputDeviceData(output_id, NULL, &display_name);
-  return display_name;
-}
-
-bool GetOutputOverscanFlag(XID output, bool* flag) {
-  unsigned long nitems = 0;
-  unsigned char *prop = NULL;
-  if (!base::GetEDIDProperty(output, &nitems, &prop))
-    return false;
-
-  bool found = ParseOutputOverscanFlag(prop, nitems, flag);
-  XFree(prop);
-  return found;
-}
-
 bool ParseOutputOverscanFlag(const unsigned char* prop,
                              unsigned long nitems,
                              bool *flag) {
@@ -140,37 +98,4 @@ bool IsInternalOutputName(const std::string& name) {
       name.find(kInternal_DSI) == 0;
 }
 
-const XRRModeInfo* FindXRRModeInfo(const XRRScreenResources* screen_resources,
-                                   XID current_mode) {
-  for (int m = 0; m < screen_resources->nmode; m++) {
-    XRRModeInfo *mode = &screen_resources->modes[m];
-    if (mode->id == current_mode)
-      return mode;
-  }
-  return NULL;
-}
-
-namespace test {
-
-XRRModeInfo CreateModeInfo(int id,
-                           int width,
-                           int height,
-                           bool interlaced,
-                           float refresh_rate) {
-  XRRModeInfo mode_info = {0};
-  mode_info.id = id;
-  mode_info.width = width;
-  mode_info.height = height;
-  if (interlaced)
-    mode_info.modeFlags = RR_Interlace;
-  if (refresh_rate != 0.0f) {
-    mode_info.hTotal = 1;
-    mode_info.vTotal = 1;
-    mode_info.dotClock = refresh_rate;
-  }
-  return mode_info;
-}
-
-}  // namespace test
-
 }  // namespace chromeos
diff --git a/chromeos/display/output_util.h b/chromeos/display/output_util.h
index 3c7a49f..41fc620 100644
--- a/chromeos/display/output_util.h
+++ b/chromeos/display/output_util.h
@@ -12,26 +12,19 @@
 
 // Forward declarations for Xlib and Xrandr.
 // This is so unused X definitions don't pollute the namespace.
-typedef unsigned long XID;
-typedef XID RRMode;
-struct _XRRModeInfo;
-typedef _XRRModeInfo XRRModeInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
+typedef unsigned long OUTPUTID;
 
 namespace chromeos {
 
 // Generates the human readable string from EDID obtained for |output|.
-CHROMEOS_EXPORT std::string GetDisplayName(XID output);
+CHROMEOS_EXPORT std::string GetDisplayName(OUTPUTID output);
 
 // Gets the overscan flag from |output| and stores to |flag|. Returns true if
 // the flag is found. Otherwise returns false and doesn't touch |flag|. The
 // output will produce overscan if |flag| is set to true, but the output may
 // still produce overscan even though it returns true and |flag| is set to
 // false.
-CHROMEOS_EXPORT bool GetOutputOverscanFlag(XID output, bool* flag);
+CHROMEOS_EXPORT bool GetOutputOverscanFlag(OUTPUTID output, bool* flag);
 
 // Parses |prop| as EDID data and stores the overscan flag to |flag|. Returns
 // true if the flag is found. This is exported for x11_util_unittest.cc.
@@ -42,32 +35,6 @@ CHROMEOS_EXPORT bool ParseOutputOverscanFlag(const unsigned char* prop,
 // Returns true if an output named |name| is an internal display.
 CHROMEOS_EXPORT bool IsInternalOutputName(const std::string& name);
 
-// Find a XRRModeInfo that matches |mode|.
-CHROMEOS_EXPORT const XRRModeInfo* FindXRRModeInfo(
-    const XRRScreenResources* screen_resources,
-    XID mode);
-
-// Find a mode that matches the given size with highest refresh
-// rate. Non-interlaced mode takes precedence, so non-interlaced mode
-// with a lower refresh rate will be used even if there is an interlaced
-// mode with a higher refresh rate.
-CHROMEOS_EXPORT RRMode FindOutputModeMatchingSize(
-    const XRRScreenResources* screen_resources,
-    const XRROutputInfo* output_info,
-    size_t width,
-    size_t height);
-
-namespace test {
-
-// Creates XRRModeInfo for unit tests.
-CHROMEOS_EXPORT XRRModeInfo CreateModeInfo(int id,
-                                           int width,
-                                           int height,
-                                           bool interlaced,
-                                           float refresh_rate);
-
-}  // namespace test
-
 }  // namespace chromeos
 
 #endif  // CHROMEOS_DISPLAY_OUTPUT_UTIL_H_
diff --git a/chromeos/display/output_util_dri.cc b/chromeos/display/output_util_dri.cc
new file mode 100644
index 0000000..ba59fa6
--- /dev/null
+++ b/chromeos/display/output_util_dri.cc
@@ -0,0 +1,22 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_util.h"
+
+#include "base/strings/string_util.h"
+
+namespace chromeos {
+
+std::string GetDisplayName(OUTPUTID output_id) {
+  std::string display_name;
+  NOTIMPLEMENTED();
+  return display_name;
+}
+
+bool GetOutputOverscanFlag(OUTPUTID output, bool* flag) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/output_util_unittest.cc b/chromeos/display/output_util_unittest.cc
index 1229b4f..e8dc584 100644
--- a/chromeos/display/output_util_unittest.cc
+++ b/chromeos/display/output_util_unittest.cc
@@ -7,8 +7,6 @@
 #include "base/memory/scoped_ptr.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#include <X11/extensions/Xrandr.h>
-
 namespace chromeos {
 
 namespace {
diff --git a/chromeos/display/output_util_x11.cc b/chromeos/display/output_util_x11.cc
new file mode 100644
index 0000000..57a2119
--- /dev/null
+++ b/chromeos/display/output_util_x11.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/output_util.h"
+
+#include <X11/extensions/Xrandr.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+
+#include "base/strings/string_util.h"
+#include "base/x11/edid_parser_x11.h"
+
+namespace chromeos {
+namespace {
+// Gets some useful data from the specified output device, such like
+// manufacturer's ID, product code, and human readable name. Returns false if it
+// fails to get those data and doesn't touch manufacturer ID/product code/name.
+// NULL can be passed for unwanted output parameters.
+bool GetOutputDeviceData(OUTPUTID output,
+                         uint16* manufacturer_id,
+                         std::string* human_readable_name) {
+  unsigned long nitems = 0;
+  unsigned char *prop = NULL;
+  if (!base::GetEDIDProperty(output, &nitems, &prop))
+    return false;
+
+  bool result = base::ParseOutputDeviceData(
+      prop, nitems, manufacturer_id, human_readable_name);
+  XFree(prop);
+  return result;
+}
+
+}  // namespace
+
+std::string GetDisplayName(OUTPUTID output_id) {
+  std::string display_name;
+  GetOutputDeviceData(output_id, NULL, &display_name);
+  return display_name;
+}
+
+bool GetOutputOverscanFlag(OUTPUTID output, bool* flag) {
+  unsigned long nitems = 0;
+  unsigned char *prop = NULL;
+  if (!base::GetEDIDProperty(output, &nitems, &prop))
+    return false;
+
+  bool found = ParseOutputOverscanFlag(prop, nitems, flag);
+  XFree(prop);
+  return found;
+}
+
+namespace test {
+
+XRRModeInfo CreateModeInfo(int id,
+                           int width,
+                           int height,
+                           bool interlaced,
+                           float refresh_rate) {
+  XRRModeInfo mode_info = {0};
+  mode_info.id = id;
+  mode_info.width = width;
+  mode_info.height = height;
+  if (interlaced)
+    mode_info.modeFlags = RR_Interlace;
+  if (refresh_rate != 0.0f) {
+    mode_info.hTotal = 1;
+    mode_info.vTotal = 1;
+    mode_info.dotClock = refresh_rate;
+  }
+  return mode_info;
+}
+
+}  // namespace test
+
+}  // namespace chromeos
+
diff --git a/chromeos/display/real_output_configurator_delegate.cc b/chromeos/display/real_output_configurator_delegate.cc
deleted file mode 100644
index 5bb4757..0000000
--- a/chromeos/display/real_output_configurator_delegate.cc
+++ /dev/null
@@ -1,614 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chromeos/display/real_output_configurator_delegate.h"
-
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-#include <X11/extensions/dpms.h>
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XInput2.h>
-#include <X11/extensions/Xrandr.h>
-
-#include <cmath>
-#include <set>
-#include <utility>
-
-#include "base/logging.h"
-#include "base/message_loop/message_pump_x11.h"
-#include "base/x11/edid_parser_x11.h"
-#include "base/x11/x11_error_tracker.h"
-#include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/dbus/power_manager_client.h"
-#include "chromeos/display/output_util.h"
-
-namespace chromeos {
-
-namespace {
-
-// DPI measurements.
-const float kMmInInch = 25.4;
-const float kDpi96 = 96.0;
-const float kPixelsToMmScale = kMmInInch / kDpi96;
-
-// Prefixes of output name
-const char kOutputName_VGA[] = "VGA";
-const char kOutputName_HDMI[] = "HDMI";
-const char kOutputName_DVI[] = "DVI";
-const char kOutputName_DisplayPort[] = "DP";
-
-const char kContentProtectionAtomName[] = "Content Protection";
-const char kProtectionUndesiredAtomName[] = "Undesired";
-const char kProtectionDesiredAtomName[] = "Desired";
-const char kProtectionEnabledAtomName[] = "Enabled";
-
-bool IsInternalOutput(const XRROutputInfo* output_info) {
-  return IsInternalOutputName(std::string(output_info->name));
-}
-
-RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
-  return output_info->nmode > 0 ? output_info->modes[0] : None;
-}
-
-}  // namespace
-
-RealOutputConfiguratorDelegate::RealOutputConfiguratorDelegate()
-    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
-      window_(DefaultRootWindow(display_)),
-      screen_(NULL) {
-}
-
-RealOutputConfiguratorDelegate::~RealOutputConfiguratorDelegate() {
-}
-
-void RealOutputConfiguratorDelegate::InitXRandRExtension(int* event_base) {
-  int error_base_ignored = 0;
-  XRRQueryExtension(display_, event_base, &error_base_ignored);
-}
-
-void RealOutputConfiguratorDelegate::UpdateXRandRConfiguration(
-    const base::NativeEvent& event) {
-  XRRUpdateConfiguration(event);
-}
-
-void RealOutputConfiguratorDelegate::GrabServer() {
-  CHECK(!screen_) << "Server already grabbed";
-  XGrabServer(display_);
-  screen_ = XRRGetScreenResources(display_, window_);
-  CHECK(screen_);
-}
-
-void RealOutputConfiguratorDelegate::UngrabServer() {
-  CHECK(screen_) << "Server not grabbed";
-  XRRFreeScreenResources(screen_);
-  screen_ = NULL;
-  XUngrabServer(display_);
-}
-
-void RealOutputConfiguratorDelegate::SyncWithServer() {
-  XSync(display_, 0);
-}
-
-void RealOutputConfiguratorDelegate::SetBackgroundColor(uint32 color_argb) {
-  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
-  // same background color while configuring the display to minimize the
-  // duration of black screen at boot time. The background is filled with
-  // black later in ash::DisplayManager.  crbug.com/171050.
-  XSetWindowAttributes swa = {0};
-  XColor color;
-  Colormap colormap = DefaultColormap(display_, 0);
-  // XColor uses 16 bits per color.
-  color.red = (color_argb & 0x00FF0000) >> 8;
-  color.green = (color_argb & 0x0000FF00);
-  color.blue = (color_argb & 0x000000FF) << 8;
-  color.flags = DoRed | DoGreen | DoBlue;
-  XAllocColor(display_, colormap, &color);
-  swa.background_pixel = color.pixel;
-  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
-  XFreeColors(display_, colormap, &color.pixel, 1, 0);
-}
-
-void RealOutputConfiguratorDelegate::ForceDPMSOn() {
-  CHECK(DPMSEnable(display_));
-  CHECK(DPMSForceLevel(display_, DPMSModeOn));
-}
-
-std::vector<OutputConfigurator::OutputSnapshot>
-RealOutputConfiguratorDelegate::GetOutputs() {
-  CHECK(screen_) << "Server not grabbed";
-
-  std::vector<OutputConfigurator::OutputSnapshot> outputs;
-  RRCrtc last_used_crtc = None;
-
-  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
-    RROutput output_id = screen_->outputs[i];
-    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
-    if (output_info->connection == RR_Connected) {
-      OutputConfigurator::OutputSnapshot output = InitOutputSnapshot(
-          output_id, output_info, &last_used_crtc, i);
-      VLOG(2) << "Found display " << outputs.size() << ":"
-              << " output=" << output.output
-              << " crtc=" << output.crtc
-              << " current_mode=" << output.current_mode;
-      outputs.push_back(output);
-    }
-    XRRFreeOutputInfo(output_info);
-  }
-
-  GetTouchscreens(&outputs);
-  return outputs;
-}
-
-void RealOutputConfiguratorDelegate::AddOutputMode(RROutput output,
-                                                   RRMode mode) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "AddOutputMode: output=" << output << " mode=" << mode;
-  XRRAddOutputMode(display_, output, mode);
-}
-
-bool RealOutputConfiguratorDelegate::ConfigureCrtc(
-    RRCrtc crtc,
-    RRMode mode,
-    RROutput output,
-    int x,
-    int y) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "ConfigureCrtc: crtc=" << crtc
-          << " mode=" << mode
-          << " output=" << output
-          << " x=" << x
-          << " y=" << y;
-  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
-  // Status, which is typically 0 for failure and 1 for success. In
-  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
-  return XRRSetCrtcConfig(display_,
-                          screen_,
-                          crtc,
-                          CurrentTime,
-                          x,
-                          y,
-                          mode,
-                          RR_Rotate_0,
-                          (output && mode) ? &output : NULL,
-                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
-}
-
-void RealOutputConfiguratorDelegate::CreateFrameBuffer(
-    int width,
-    int height,
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  int current_width = DisplayWidth(display_, DefaultScreen(display_));
-  int current_height = DisplayHeight(display_, DefaultScreen(display_));
-  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
-          << " current=" << current_width << "x" << current_height;
-  if (width ==  current_width && height == current_height)
-    return;
-
-  DestroyUnusedCrtcs(outputs);
-  int mm_width = width * kPixelsToMmScale;
-  int mm_height = height * kPixelsToMmScale;
-  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
-}
-
-void RealOutputConfiguratorDelegate::ConfigureCTM(
-    int touch_device_id,
-    const OutputConfigurator::CoordinateTransformation& ctm) {
-  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
-          << " scale=" << ctm.x_scale << "x" << ctm.y_scale
-          << " offset=(" << ctm.x_offset << ", " << ctm.y_offset << ")";
-  int ndevices = 0;
-  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
-  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
-  Atom float_atom = XInternAtom(display_, "FLOAT", False);
-  if (ndevices == 1 && prop != None && float_atom != None) {
-    Atom type;
-    int format;
-    unsigned long num_items;
-    unsigned long bytes_after;
-    unsigned char* data = NULL;
-    // Verify that the property exists with correct format, type, etc.
-    int status = XIGetProperty(display_, info->deviceid, prop, 0, 0, False,
-        AnyPropertyType, &type, &format, &num_items, &bytes_after, &data);
-    if (data)
-      XFree(data);
-    if (status == Success && type == float_atom && format == 32) {
-      float value[3][3] = {
-          { ctm.x_scale,         0.0, ctm.x_offset },
-          {         0.0, ctm.y_scale, ctm.y_offset },
-          {         0.0,         0.0,          1.0 }
-      };
-      XIChangeProperty(display_,
-                       info->deviceid,
-                       prop,
-                       type,
-                       format,
-                       PropModeReplace,
-                       reinterpret_cast<unsigned char*>(value),
-                       9);
-    }
-  }
-  XIFreeDeviceInfo(info);
-}
-
-void RealOutputConfiguratorDelegate::SendProjectingStateToPowerManager(
-    bool projecting) {
-  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->
-      SetIsProjecting(projecting);
-}
-
-bool RealOutputConfiguratorDelegate::InitModeInfo(
-    RRMode mode,
-    OutputConfigurator::ModeInfo* mode_info) {
-  DCHECK(mode_info);
-  CHECK(screen_) << "Server not grabbed";
-  // TODO: Determine if we need to organize modes in a way which provides
-  // better than O(n) lookup time.  In many call sites, for example, the
-  // "next" mode is typically what we are looking for so using this
-  // helper might be too expensive.
-  for (int i = 0; i < screen_->nmode; ++i) {
-    if (mode == screen_->modes[i].id) {
-      const XRRModeInfo& info = screen_->modes[i];
-      mode_info->width = info.width;
-      mode_info->height = info.height;
-      mode_info->interlaced = info.modeFlags & RR_Interlace;
-      if (info.hTotal && info.vTotal) {
-        mode_info->refresh_rate = static_cast<float>(info.dotClock) /
-            (static_cast<float>(info.hTotal) *
-             static_cast<float>(info.vTotal));
-      } else {
-        mode_info->refresh_rate = 0.0f;
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
-OutputConfigurator::OutputSnapshot
-RealOutputConfiguratorDelegate::InitOutputSnapshot(
-    RROutput id,
-    XRROutputInfo* info,
-    RRCrtc* last_used_crtc,
-    int index) {
-  OutputConfigurator::OutputSnapshot output;
-  output.output = id;
-  output.width_mm = info->mm_width;
-  output.height_mm = info->mm_height;
-  output.has_display_id = base::GetDisplayId(id, index, &output.display_id);
-  output.is_internal = IsInternalOutput(info);
-  output.index = index;
-
-  // Use the index as a valid display ID even if the internal
-  // display doesn't have valid EDID because the index
-  // will never change.
-  if (!output.has_display_id && output.is_internal)
-    output.has_display_id = true;
-
-  if (info->crtc) {
-    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
-    output.current_mode = crtc_info->mode;
-    output.x = crtc_info->x;
-    output.y = crtc_info->y;
-    XRRFreeCrtcInfo(crtc_info);
-  }
-
-  // Assign a CRTC that isn't already in use.
-  for (int i = 0; i < info->ncrtc; ++i) {
-    if (info->crtcs[i] != *last_used_crtc) {
-      output.crtc = info->crtcs[i];
-      *last_used_crtc = output.crtc;
-      break;
-    }
-  }
-
-  output.native_mode = GetOutputNativeMode(info);
-  output.is_aspect_preserving_scaling = IsOutputAspectPreservingScaling(id);
-  output.touch_device_id = None;
-
-  for (int i = 0; i < info->nmode; ++i) {
-    const RRMode mode = info->modes[i];
-    OutputConfigurator::ModeInfo mode_info;
-    if (InitModeInfo(mode, &mode_info))
-      output.mode_infos.insert(std::make_pair(mode, mode_info));
-    else
-      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
-  }
-
-  std::string name(info->name);
-  if (output.is_internal) {
-    output.type = OUTPUT_TYPE_INTERNAL;
-  } else if (name.find(kOutputName_VGA) == 0) {
-    output.type = OUTPUT_TYPE_VGA;
-  } else if (name.find(kOutputName_HDMI) == 0) {
-    output.type = OUTPUT_TYPE_HDMI;
-  } else if (name.find(kOutputName_DVI) == 0) {
-    output.type = OUTPUT_TYPE_DVI;
-  } else if (name.find(kOutputName_DisplayPort) == 0) {
-    output.type = OUTPUT_TYPE_DISPLAYPORT;
-  } else {
-    LOG(ERROR) << "Unknown link type: " << name;
-    output.type = OUTPUT_TYPE_UNKNOWN;
-  }
-
-  return output;
-}
-
-bool RealOutputConfiguratorDelegate::GetHDCPState(RROutput id,
-                                                  HDCPState* state) {
-  unsigned char* values = NULL;
-  int actual_format = 0;
-  unsigned long nitems = 0;
-  unsigned long bytes_after = 0;
-  Atom actual_type = None;
-  int success = 0;
-  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
-  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
-
-  bool ok = true;
-  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
-  // output_util.cc)
-  success = XRRGetOutputProperty(display_, id, prop, 0, 100, False,
-                                 False, AnyPropertyType, &actual_type,
-                                 &actual_format, &nitems, &bytes_after,
-                                 &values);
-  if (actual_type == None) {
-    LOG(ERROR) << "Property '" << kContentProtectionAtomName
-               << "' does not exist";
-    ok = false;
-  } else if (success == Success && actual_type == XA_ATOM &&
-             actual_format == 32 && nitems == 1) {
-    Atom value = reinterpret_cast<Atom*>(values)[0];
-    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
-      *state = HDCP_STATE_UNDESIRED;
-    } else if (value == XInternAtom(display_, kProtectionDesiredAtomName,
-                                    False)) {
-      *state = HDCP_STATE_DESIRED;
-    } else if (value == XInternAtom(display_, kProtectionEnabledAtomName,
-                                    False)) {
-      *state = HDCP_STATE_ENABLED;
-    } else {
-      LOG(ERROR) << "Unknown " << kContentProtectionAtomName << " value: "
-                 << value;
-      ok = false;
-    }
-  } else {
-    LOG(ERROR) << "XRRGetOutputProperty failed";
-    ok = false;
-  }
-  if (values)
-    XFree(values);
-
-  VLOG(3) << "HDCP state: " << ok << "," << *state;
-  return ok;
-}
-
-bool RealOutputConfiguratorDelegate::SetHDCPState(RROutput id,
-                                                  HDCPState state) {
-  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
-  Atom value = None;
-  switch (state) {
-    case HDCP_STATE_UNDESIRED:
-      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
-      break;
-    case HDCP_STATE_DESIRED:
-      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
-      break;
-    default:
-      NOTREACHED() << "Invalid HDCP state: " << state;
-      return false;
-  }
-  base::X11ErrorTracker err_tracker;
-  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
-  XRRChangeOutputProperty(display_, id, name, XA_ATOM, 32,
-                          PropModeReplace, data, 1);
-  if (err_tracker.FoundNewError()) {
-    LOG(ERROR) << "XRRChangeOutputProperty failed";
-    return false;
-  } else {
-    return true;
-  }
-}
-
-void RealOutputConfiguratorDelegate::DestroyUnusedCrtcs(
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
-  // At the same time, turning CRTCs off and back on uses up a lot of time.
-  // This function tries to be smart to avoid too many off/on cycles:
-  // - We disable all the CRTCs we won't need after the FB resize.
-  // - We set the new modes on CRTCs, if they fit in both the old and new
-  //   FBs, and park them at (0,0)
-  // - We disable the CRTCs we will need but don't fit in the old FB. Those
-  //   will be reenabled after the resize.
-  // We don't worry about the cached state of the outputs here since we are
-  // not interested in the state we are setting - we just try to get the CRTCs
-  // out of the way so we can rebuild the frame buffer.
-  for (int i = 0; i < screen_->ncrtc; ++i) {
-    // Default config is to disable the crtcs.
-    RRCrtc crtc = screen_->crtcs[i];
-    RRMode mode = None;
-    RROutput output = None;
-    const OutputConfigurator::ModeInfo* mode_info = NULL;
-    for (std::vector<OutputConfigurator::OutputSnapshot>::const_iterator it =
-         outputs.begin(); it != outputs.end(); ++it) {
-      if (crtc == it->crtc) {
-        mode = it->current_mode;
-        output = it->output;
-        if (mode != None)
-          mode_info = OutputConfigurator::GetModeInfo(*it, mode);
-        break;
-      }
-    }
-
-    if (mode_info) {
-      // In case our CRTC doesn't fit in our current framebuffer, disable it.
-      // It'll get reenabled after we resize the framebuffer.
-      int current_width = DisplayWidth(display_, DefaultScreen(display_));
-      int current_height = DisplayHeight(display_, DefaultScreen(display_));
-      if (mode_info->width > current_width ||
-          mode_info->height > current_height) {
-        mode = None;
-        output = None;
-        mode_info = NULL;
-      }
-    }
-
-    ConfigureCrtc(crtc, mode, output, 0, 0);
-  }
-}
-
-bool RealOutputConfiguratorDelegate::IsOutputAspectPreservingScaling(
-    RROutput id) {
-  bool ret = false;
-
-  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
-  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
-  if (scaling_prop == None || full_aspect_atom == None)
-    return false;
-
-  int nprop = 0;
-  Atom* props = XRRListOutputProperties(display_, id, &nprop);
-  for (int j = 0; j < nprop && !ret; j++) {
-    Atom prop = props[j];
-    if (scaling_prop == prop) {
-      unsigned char* values = NULL;
-      int actual_format;
-      unsigned long nitems;
-      unsigned long bytes_after;
-      Atom actual_type;
-      int success;
-
-      success = XRRGetOutputProperty(display_, id, prop, 0, 100, False, False,
-          AnyPropertyType, &actual_type, &actual_format, &nitems,
-          &bytes_after, &values);
-      if (success == Success && actual_type == XA_ATOM &&
-          actual_format == 32 && nitems == 1) {
-        Atom value = reinterpret_cast<Atom*>(values)[0];
-        if (full_aspect_atom == value)
-          ret = true;
-      }
-      if (values)
-        XFree(values);
-    }
-  }
-  if (props)
-    XFree(props);
-
-  return ret;
-}
-
-void RealOutputConfiguratorDelegate::GetTouchscreens(
-    std::vector<OutputConfigurator::OutputSnapshot>* outputs) {
-  int ndevices = 0;
-  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
-  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
-  if (valuator_x == None || valuator_y == None)
-    return;
-
-  std::set<int> no_match_touchscreen;
-  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
-  for (int i = 0; i < ndevices; i++) {
-    if (!info[i].enabled || info[i].use != XIFloatingSlave)
-      continue;  // Assume all touchscreens are floating slaves
-
-    double width = -1.0;
-    double height = -1.0;
-    bool is_direct_touch = false;
-
-    for (int j = 0; j < info[i].num_classes; j++) {
-      XIAnyClassInfo* class_info = info[i].classes[j];
-
-      if (class_info->type == XIValuatorClass) {
-        XIValuatorClassInfo* valuator_info =
-            reinterpret_cast<XIValuatorClassInfo*>(class_info);
-
-        if (valuator_x == valuator_info->label) {
-          // Ignore X axis valuator with unexpected properties
-          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            width = valuator_info->max;
-          }
-        } else if (valuator_y == valuator_info->label) {
-          // Ignore Y axis valuator with unexpected properties
-          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            height = valuator_info->max;
-          }
-        }
-      }
-#if defined(USE_XI2_MT)
-      if (class_info->type == XITouchClass) {
-        XITouchClassInfo* touch_info =
-            reinterpret_cast<XITouchClassInfo*>(class_info);
-        is_direct_touch = touch_info->mode == XIDirectTouch;
-      }
-#endif
-    }
-
-    // Touchscreens should have absolute X and Y axes,
-    // and be direct touch devices.
-    if (width > 0.0 && height > 0.0 && is_direct_touch) {
-      size_t k = 0;
-      for (; k < outputs->size(); k++) {
-        OutputConfigurator::OutputSnapshot* output = &(*outputs)[k];
-        if (output->native_mode == None || output->touch_device_id != None)
-          continue;
-
-        const OutputConfigurator::ModeInfo* mode_info =
-            OutputConfigurator::GetModeInfo(*output, output->native_mode);
-        if (!mode_info)
-          continue;
-
-        // Allow 1 pixel difference between screen and touchscreen
-        // resolutions.  Because in some cases for monitor resolution
-        // 1024x768 touchscreen's resolution would be 1024x768, but for
-        // some 1023x767.  It really depends on touchscreen's firmware
-        // configuration.
-        if (std::abs(mode_info->width - width) <= 1.0 &&
-            std::abs(mode_info->height - height) <= 1.0) {
-          output->touch_device_id = info[i].deviceid;
-
-          VLOG(2) << "Found touchscreen for output #" << k
-                  << " id " << output->touch_device_id
-                  << " width " << width
-                  << " height " << height;
-          break;
-        }
-      }
-
-      if (k == outputs->size()) {
-        no_match_touchscreen.insert(info[i].deviceid);
-        VLOG(2) << "No matching output for touchscreen"
-                << " id " << info[i].deviceid
-                << " width " << width
-                << " height " << height;
-      }
-
-    }
-  }
-
-  // Sometimes we can't find a matching screen for the touchscreen, e.g.
-  // due to the touchscreen's reporting range having no correlation with the
-  // screen's resolution. In this case, we arbitrarily assign unmatched
-  // touchscreens to unmatched screens.
-  for (std::set<int>::iterator it = no_match_touchscreen.begin();
-       it != no_match_touchscreen.end();
-       it++) {
-    for (size_t i = 0; i < outputs->size(); i++) {
-      if ((*outputs)[i].is_internal == false &&
-          (*outputs)[i].native_mode != None &&
-          (*outputs)[i].touch_device_id == None ) {
-        (*outputs)[i].touch_device_id = *it;
-        VLOG(2) << "Arbitrarily matching touchscreen "
-                << (*outputs)[i].touch_device_id << " to output #" << i;
-        break;
-      }
-    }
-  }
-
-  XIFreeDeviceInfo(info);
-}
-
-}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate.h b/chromeos/display/real_output_configurator_delegate.h
deleted file mode 100644
index 26940c4..0000000
--- a/chromeos/display/real_output_configurator_delegate.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-
-#include <vector>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "chromeos/display/output_configurator.h"
-
-typedef XID Window;
-
-struct _XDisplay;
-typedef struct _XDisplay Display;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-
-namespace chromeos {
-
-class RealOutputConfiguratorDelegate : public OutputConfigurator::Delegate {
- public:
-  RealOutputConfiguratorDelegate();
-  virtual ~RealOutputConfiguratorDelegate();
-
-  // OutputConfigurator::Delegate overrides:
-  virtual void InitXRandRExtension(int* event_base) OVERRIDE;
-  virtual void UpdateXRandRConfiguration(
-      const base::NativeEvent& event) OVERRIDE;
-  virtual void GrabServer() OVERRIDE;
-  virtual void UngrabServer() OVERRIDE;
-  virtual void SyncWithServer() OVERRIDE;
-  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
-  virtual void ForceDPMSOn() OVERRIDE;
-  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
-  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
-  virtual bool ConfigureCrtc(
-      RRCrtc crtc,
-      RRMode mode,
-      RROutput output,
-      int x,
-      int y) OVERRIDE;
-  virtual void CreateFrameBuffer(
-      int width,
-      int height,
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
-  virtual void ConfigureCTM(
-      int touch_device_id,
-      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
-  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
-  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
-  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
-
- private:
-  // Initializes |mode_info| to contain details corresponding to |mode|. Returns
-  // true on success.
-  bool InitModeInfo(RRMode mode, OutputConfigurator::ModeInfo* mode_info);
-
-  // Helper method for GetOutputs() that returns an OutputSnapshot struct based
-  // on the passed-in information. Further initialization is required (e.g.
-  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
-  OutputConfigurator::OutputSnapshot InitOutputSnapshot(
-      RROutput id,
-      XRROutputInfo* info,
-      RRCrtc* last_used_crtc,
-      int index);
-
-  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
-  // framebuffer resize. This is faster than turning them off, resizing,
-  // then turning them back on.
-  void DestroyUnusedCrtcs(
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs);
-
-  // Returns whether |id| is configured to preserve aspect when scaling.
-  bool IsOutputAspectPreservingScaling(RROutput id);
-
-  // Searches for touchscreens among input devices,
-  // and tries to match them up to screens in |outputs|.
-  // |outputs| is an array of detected screens.
-  // If a touchscreen with same resolution as an output's native mode
-  // is detected, its id will be stored in this output.
-  void GetTouchscreens(
-      std::vector<OutputConfigurator::OutputSnapshot>* outputs);
-
-  Display* display_;
-  Window window_;
-
-  // Initialized when the server is grabbed and freed when it's ungrabbed.
-  XRRScreenResources* screen_;
-
-  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegate);
-};
-
-}  // namespace chromeos
-
-#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/chromeos/display/real_output_configurator_delegate_dri.cc b/chromeos/display/real_output_configurator_delegate_dri.cc
new file mode 100644
index 0000000..9f9fb7c
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_dri.cc
@@ -0,0 +1,96 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/real_output_configurator_delegate_dri.h"
+
+namespace chromeos {
+
+RealOutputConfiguratorDelegateDri::RealOutputConfiguratorDelegateDri() {
+}
+
+RealOutputConfiguratorDelegateDri::~RealOutputConfiguratorDelegateDri() {
+}
+
+int RealOutputConfiguratorDelegateDri::InitResources() {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+void RealOutputConfiguratorDelegateDri::HandleScreenChangeNotification(
+    const base::NativeEvent& event) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::GrabServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::UngrabServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SyncWithServer() {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SetBackgroundColor(uint32 color_argb) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::ForceDPMSOn() {
+  NOTIMPLEMENTED();
+}
+
+std::vector<OutputConfigurator::OutputSnapshot>
+RealOutputConfiguratorDelegateDri::GetOutputs() {
+  std::vector<OutputConfigurator::OutputSnapshot> outputs;
+  NOTIMPLEMENTED();
+  return outputs;
+}
+
+void RealOutputConfiguratorDelegateDri::AddOutputMode(RROutput output,
+                                                   RRMode mode) {
+  NOTIMPLEMENTED();
+}
+
+bool RealOutputConfiguratorDelegateDri::ConfigureCrtc(RRCrtc crtc,
+                                                      RRMode mode,
+                                                      RROutput output,
+                                                      int x,
+                                                      int y) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void RealOutputConfiguratorDelegateDri::CreateFrameBuffer(
+    int width,
+    int height,
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::ConfigureCTM(
+    int touch_device_id,
+    const OutputConfigurator::CoordinateTransformation& ctm) {
+  NOTIMPLEMENTED();
+}
+
+void RealOutputConfiguratorDelegateDri::SendProjectingStateToPowerManager(
+    bool projecting) {
+  NOTIMPLEMENTED();
+}
+
+bool RealOutputConfiguratorDelegateDri::GetHDCPState(RROutput id,
+                                                  HDCPState* state) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool RealOutputConfiguratorDelegateDri::SetHDCPState(RROutput id,
+                                                  HDCPState state) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate_dri.h b/chromeos/display/real_output_configurator_delegate_dri.h
new file mode 100644
index 0000000..7ecee82
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_dri.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "chromeos/display/output_configurator.h"
+
+namespace chromeos {
+
+class RealOutputConfiguratorDelegateDri : public OutputConfigurator::Delegate {
+ public:
+  RealOutputConfiguratorDelegateDri();
+  virtual ~RealOutputConfiguratorDelegateDri();
+
+  // OutputConfigurator::Delegate overrides:
+  virtual int InitResources() OVERRIDE;
+  virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual void GrabServer() OVERRIDE;
+  virtual void UngrabServer() OVERRIDE;
+  virtual void SyncWithServer() OVERRIDE;
+  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
+  virtual void ForceDPMSOn() OVERRIDE;
+  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
+  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
+  virtual bool ConfigureCrtc(
+      RRCrtc crtc,
+      RRMode mode,
+      RROutput output,
+      int x,
+      int y) OVERRIDE;
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
+  virtual void ConfigureCTM(
+      int touch_device_id,
+      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
+  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
+  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
+
+  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegateDri);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/chromeos/display/real_output_configurator_delegate_x11.cc b/chromeos/display/real_output_configurator_delegate_x11.cc
new file mode 100644
index 0000000..6344980
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_x11.cc
@@ -0,0 +1,616 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/real_output_configurator_delegate_x11.h"
+
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/dpms.h>
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xrandr.h>
+
+#include <cmath>
+#include <set>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/message_loop/message_pump_x11.h"
+#include "base/x11/edid_parser_x11.h"
+#include "base/x11/x11_error_tracker.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/power_manager_client.h"
+#include "chromeos/display/output_util.h"
+
+namespace chromeos {
+
+namespace {
+
+// DPI measurements.
+const float kMmInInch = 25.4;
+const float kDpi96 = 96.0;
+const float kPixelsToMmScale = kMmInInch / kDpi96;
+
+// Prefixes of output name
+const char kOutputName_VGA[] = "VGA";
+const char kOutputName_HDMI[] = "HDMI";
+const char kOutputName_DVI[] = "DVI";
+const char kOutputName_DisplayPort[] = "DP";
+
+const char kContentProtectionAtomName[] = "Content Protection";
+const char kProtectionUndesiredAtomName[] = "Undesired";
+const char kProtectionDesiredAtomName[] = "Desired";
+const char kProtectionEnabledAtomName[] = "Enabled";
+
+bool IsInternalOutput(const XRROutputInfo* output_info) {
+  return IsInternalOutputName(std::string(output_info->name));
+}
+
+RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
+  return output_info->nmode > 0 ? output_info->modes[0] : None;
+}
+
+}  // namespace
+
+RealOutputConfiguratorDelegate::RealOutputConfiguratorDelegate()
+    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
+      window_(DefaultRootWindow(display_)),
+      screen_(NULL) {
+}
+
+RealOutputConfiguratorDelegate::~RealOutputConfiguratorDelegate() {
+}
+
+int RealOutputConfiguratorDelegate::InitResources() {
+  int error_base_ignored = 0;
+  int event_base = -1;
+  XRRQueryExtension(display_, &event_base, &error_base_ignored);
+  return event_base;
+}
+
+void RealOutputConfiguratorDelegate::HandleScreenChangeNotification(
+    const base::NativeEvent& event) {
+  XRRUpdateConfiguration(event);
+}
+
+void RealOutputConfiguratorDelegate::GrabServer() {
+  CHECK(!screen_) << "Server already grabbed";
+  XGrabServer(display_);
+  screen_ = XRRGetScreenResources(display_, window_);
+  CHECK(screen_);
+}
+
+void RealOutputConfiguratorDelegate::UngrabServer() {
+  CHECK(screen_) << "Server not grabbed";
+  XRRFreeScreenResources(screen_);
+  screen_ = NULL;
+  XUngrabServer(display_);
+}
+
+void RealOutputConfiguratorDelegate::SyncWithServer() {
+  XSync(display_, 0);
+}
+
+void RealOutputConfiguratorDelegate::SetBackgroundColor(uint32 color_argb) {
+  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
+  // same background color while configuring the display to minimize the
+  // duration of black screen at boot time. The background is filled with
+  // black later in ash::DisplayManager.  crbug.com/171050.
+  XSetWindowAttributes swa = {0};
+  XColor color;
+  Colormap colormap = DefaultColormap(display_, 0);
+  // XColor uses 16 bits per color.
+  color.red = (color_argb & 0x00FF0000) >> 8;
+  color.green = (color_argb & 0x0000FF00);
+  color.blue = (color_argb & 0x000000FF) << 8;
+  color.flags = DoRed | DoGreen | DoBlue;
+  XAllocColor(display_, colormap, &color);
+  swa.background_pixel = color.pixel;
+  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
+  XFreeColors(display_, colormap, &color.pixel, 1, 0);
+}
+
+void RealOutputConfiguratorDelegate::ForceDPMSOn() {
+  CHECK(DPMSEnable(display_));
+  CHECK(DPMSForceLevel(display_, DPMSModeOn));
+}
+
+std::vector<OutputConfigurator::OutputSnapshot>
+RealOutputConfiguratorDelegate::GetOutputs() {
+  CHECK(screen_) << "Server not grabbed";
+
+  std::vector<OutputConfigurator::OutputSnapshot> outputs;
+  RRCrtc last_used_crtc = None;
+
+  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
+    RROutput output_id = screen_->outputs[i];
+    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
+    if (output_info->connection == RR_Connected) {
+      OutputConfigurator::OutputSnapshot output = InitOutputSnapshot(
+          output_id, output_info, &last_used_crtc, i);
+      VLOG(2) << "Found display " << outputs.size() << ":"
+              << " output=" << output.output
+              << " crtc=" << output.crtc
+              << " current_mode=" << output.current_mode;
+      outputs.push_back(output);
+    }
+    XRRFreeOutputInfo(output_info);
+  }
+
+  GetTouchscreens(&outputs);
+  return outputs;
+}
+
+void RealOutputConfiguratorDelegate::AddOutputMode(RROutput output,
+                                                   RRMode mode) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "AddOutputMode: output=" << output << " mode=" << mode;
+  XRRAddOutputMode(display_, output, mode);
+}
+
+bool RealOutputConfiguratorDelegate::ConfigureCrtc(
+    RRCrtc crtc,
+    RRMode mode,
+    RROutput output,
+    int x,
+    int y) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "ConfigureCrtc: crtc=" << crtc
+          << " mode=" << mode
+          << " output=" << output
+          << " x=" << x
+          << " y=" << y;
+  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
+  // Status, which is typically 0 for failure and 1 for success. In
+  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
+  return XRRSetCrtcConfig(display_,
+                          screen_,
+                          crtc,
+                          CurrentTime,
+                          x,
+                          y,
+                          mode,
+                          RR_Rotate_0,
+                          (output && mode) ? &output : NULL,
+                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
+}
+
+void RealOutputConfiguratorDelegate::CreateFrameBuffer(
+    int width,
+    int height,
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  int current_width = DisplayWidth(display_, DefaultScreen(display_));
+  int current_height = DisplayHeight(display_, DefaultScreen(display_));
+  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
+          << " current=" << current_width << "x" << current_height;
+  if (width ==  current_width && height == current_height)
+    return;
+
+  DestroyUnusedCrtcs(outputs);
+  int mm_width = width * kPixelsToMmScale;
+  int mm_height = height * kPixelsToMmScale;
+  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
+}
+
+void RealOutputConfiguratorDelegate::ConfigureCTM(
+    int touch_device_id,
+    const OutputConfigurator::CoordinateTransformation& ctm) {
+  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
+          << " scale=" << ctm.x_scale << "x" << ctm.y_scale
+          << " offset=(" << ctm.x_offset << ", " << ctm.y_offset << ")";
+  int ndevices = 0;
+  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
+  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
+  Atom float_atom = XInternAtom(display_, "FLOAT", False);
+  if (ndevices == 1 && prop != None && float_atom != None) {
+    Atom type;
+    int format;
+    unsigned long num_items;
+    unsigned long bytes_after;
+    unsigned char* data = NULL;
+    // Verify that the property exists with correct format, type, etc.
+    int status = XIGetProperty(display_, info->deviceid, prop, 0, 0, False,
+        AnyPropertyType, &type, &format, &num_items, &bytes_after, &data);
+    if (data)
+      XFree(data);
+    if (status == Success && type == float_atom && format == 32) {
+      float value[3][3] = {
+          { ctm.x_scale,         0.0, ctm.x_offset },
+          {         0.0, ctm.y_scale, ctm.y_offset },
+          {         0.0,         0.0,          1.0 }
+      };
+      XIChangeProperty(display_,
+                       info->deviceid,
+                       prop,
+                       type,
+                       format,
+                       PropModeReplace,
+                       reinterpret_cast<unsigned char*>(value),
+                       9);
+    }
+  }
+  XIFreeDeviceInfo(info);
+}
+
+void RealOutputConfiguratorDelegate::SendProjectingStateToPowerManager(
+    bool projecting) {
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->
+      SetIsProjecting(projecting);
+}
+
+bool RealOutputConfiguratorDelegate::InitModeInfo(
+    RRMode mode,
+    OutputConfigurator::ModeInfo* mode_info) {
+  DCHECK(mode_info);
+  CHECK(screen_) << "Server not grabbed";
+  // TODO: Determine if we need to organize modes in a way which provides
+  // better than O(n) lookup time.  In many call sites, for example, the
+  // "next" mode is typically what we are looking for so using this
+  // helper might be too expensive.
+  for (int i = 0; i < screen_->nmode; ++i) {
+    if (mode == screen_->modes[i].id) {
+      const XRRModeInfo& info = screen_->modes[i];
+      mode_info->width = info.width;
+      mode_info->height = info.height;
+      mode_info->interlaced = info.modeFlags & RR_Interlace;
+      if (info.hTotal && info.vTotal) {
+        mode_info->refresh_rate = static_cast<float>(info.dotClock) /
+            (static_cast<float>(info.hTotal) *
+             static_cast<float>(info.vTotal));
+      } else {
+        mode_info->refresh_rate = 0.0f;
+      }
+      return true;
+    }
+  }
+  return false;
+}
+
+OutputConfigurator::OutputSnapshot
+RealOutputConfiguratorDelegate::InitOutputSnapshot(
+    RROutput id,
+    XRROutputInfo* info,
+    RRCrtc* last_used_crtc,
+    int index) {
+  OutputConfigurator::OutputSnapshot output;
+  output.output = id;
+  output.width_mm = info->mm_width;
+  output.height_mm = info->mm_height;
+  output.has_display_id = base::GetDisplayId(id, index, &output.display_id);
+  output.is_internal = IsInternalOutput(info);
+  output.index = index;
+
+  // Use the index as a valid display ID even if the internal
+  // display doesn't have valid EDID because the index
+  // will never change.
+  if (!output.has_display_id && output.is_internal)
+    output.has_display_id = true;
+
+  if (info->crtc) {
+    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
+    output.current_mode = crtc_info->mode;
+    output.x = crtc_info->x;
+    output.y = crtc_info->y;
+    XRRFreeCrtcInfo(crtc_info);
+  }
+
+  // Assign a CRTC that isn't already in use.
+  for (int i = 0; i < info->ncrtc; ++i) {
+    if (info->crtcs[i] != *last_used_crtc) {
+      output.crtc = info->crtcs[i];
+      *last_used_crtc = output.crtc;
+      break;
+    }
+  }
+
+  output.native_mode = GetOutputNativeMode(info);
+  output.is_aspect_preserving_scaling = IsOutputAspectPreservingScaling(id);
+  output.touch_device_id = None;
+
+  for (int i = 0; i < info->nmode; ++i) {
+    const RRMode mode = info->modes[i];
+    OutputConfigurator::ModeInfo mode_info;
+    if (InitModeInfo(mode, &mode_info))
+      output.mode_infos.insert(std::make_pair(mode, mode_info));
+    else
+      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
+  }
+
+  std::string name(info->name);
+  if (output.is_internal) {
+    output.type = OUTPUT_TYPE_INTERNAL;
+  } else if (name.find(kOutputName_VGA) == 0) {
+    output.type = OUTPUT_TYPE_VGA;
+  } else if (name.find(kOutputName_HDMI) == 0) {
+    output.type = OUTPUT_TYPE_HDMI;
+  } else if (name.find(kOutputName_DVI) == 0) {
+    output.type = OUTPUT_TYPE_DVI;
+  } else if (name.find(kOutputName_DisplayPort) == 0) {
+    output.type = OUTPUT_TYPE_DISPLAYPORT;
+  } else {
+    LOG(ERROR) << "Unknown link type: " << name;
+    output.type = OUTPUT_TYPE_UNKNOWN;
+  }
+
+  return output;
+}
+
+bool RealOutputConfiguratorDelegate::GetHDCPState(RROutput id,
+                                                  HDCPState* state) {
+  unsigned char* values = NULL;
+  int actual_format = 0;
+  unsigned long nitems = 0;
+  unsigned long bytes_after = 0;
+  Atom actual_type = None;
+  int success = 0;
+  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
+  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
+
+  bool ok = true;
+  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
+  // output_util.cc)
+  success = XRRGetOutputProperty(display_, id, prop, 0, 100, False,
+                                 False, AnyPropertyType, &actual_type,
+                                 &actual_format, &nitems, &bytes_after,
+                                 &values);
+  if (actual_type == None) {
+    LOG(ERROR) << "Property '" << kContentProtectionAtomName
+               << "' does not exist";
+    ok = false;
+  } else if (success == Success && actual_type == XA_ATOM &&
+             actual_format == 32 && nitems == 1) {
+    Atom value = reinterpret_cast<Atom*>(values)[0];
+    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
+      *state = HDCP_STATE_UNDESIRED;
+    } else if (value == XInternAtom(display_, kProtectionDesiredAtomName,
+                                    False)) {
+      *state = HDCP_STATE_DESIRED;
+    } else if (value == XInternAtom(display_, kProtectionEnabledAtomName,
+                                    False)) {
+      *state = HDCP_STATE_ENABLED;
+    } else {
+      LOG(ERROR) << "Unknown " << kContentProtectionAtomName << " value: "
+                 << value;
+      ok = false;
+    }
+  } else {
+    LOG(ERROR) << "XRRGetOutputProperty failed";
+    ok = false;
+  }
+  if (values)
+    XFree(values);
+
+  VLOG(3) << "HDCP state: " << ok << "," << *state;
+  return ok;
+}
+
+bool RealOutputConfiguratorDelegate::SetHDCPState(RROutput id,
+                                                  HDCPState state) {
+  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
+  Atom value = None;
+  switch (state) {
+    case HDCP_STATE_UNDESIRED:
+      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
+      break;
+    case HDCP_STATE_DESIRED:
+      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
+      break;
+    default:
+      NOTREACHED() << "Invalid HDCP state: " << state;
+      return false;
+  }
+  base::X11ErrorTracker err_tracker;
+  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
+  XRRChangeOutputProperty(display_, id, name, XA_ATOM, 32,
+                          PropModeReplace, data, 1);
+  if (err_tracker.FoundNewError()) {
+    LOG(ERROR) << "XRRChangeOutputProperty failed";
+    return false;
+  } else {
+    return true;
+  }
+}
+
+void RealOutputConfiguratorDelegate::DestroyUnusedCrtcs(
+    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
+  // At the same time, turning CRTCs off and back on uses up a lot of time.
+  // This function tries to be smart to avoid too many off/on cycles:
+  // - We disable all the CRTCs we won't need after the FB resize.
+  // - We set the new modes on CRTCs, if they fit in both the old and new
+  //   FBs, and park them at (0,0)
+  // - We disable the CRTCs we will need but don't fit in the old FB. Those
+  //   will be reenabled after the resize.
+  // We don't worry about the cached state of the outputs here since we are
+  // not interested in the state we are setting - we just try to get the CRTCs
+  // out of the way so we can rebuild the frame buffer.
+  for (int i = 0; i < screen_->ncrtc; ++i) {
+    // Default config is to disable the crtcs.
+    RRCrtc crtc = screen_->crtcs[i];
+    RRMode mode = None;
+    RROutput output = None;
+    const OutputConfigurator::ModeInfo* mode_info = NULL;
+    for (std::vector<OutputConfigurator::OutputSnapshot>::const_iterator it =
+         outputs.begin(); it != outputs.end(); ++it) {
+      if (crtc == it->crtc) {
+        mode = it->current_mode;
+        output = it->output;
+        if (mode != None)
+          mode_info = OutputConfigurator::GetModeInfo(*it, mode);
+        break;
+      }
+    }
+
+    if (mode_info) {
+      // In case our CRTC doesn't fit in our current framebuffer, disable it.
+      // It'll get reenabled after we resize the framebuffer.
+      int current_width = DisplayWidth(display_, DefaultScreen(display_));
+      int current_height = DisplayHeight(display_, DefaultScreen(display_));
+      if (mode_info->width > current_width ||
+          mode_info->height > current_height) {
+        mode = None;
+        output = None;
+        mode_info = NULL;
+      }
+    }
+
+    ConfigureCrtc(crtc, mode, output, 0, 0);
+  }
+}
+
+bool RealOutputConfiguratorDelegate::IsOutputAspectPreservingScaling(
+    RROutput id) {
+  bool ret = false;
+
+  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
+  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
+  if (scaling_prop == None || full_aspect_atom == None)
+    return false;
+
+  int nprop = 0;
+  Atom* props = XRRListOutputProperties(display_, id, &nprop);
+  for (int j = 0; j < nprop && !ret; j++) {
+    Atom prop = props[j];
+    if (scaling_prop == prop) {
+      unsigned char* values = NULL;
+      int actual_format;
+      unsigned long nitems;
+      unsigned long bytes_after;
+      Atom actual_type;
+      int success;
+
+      success = XRRGetOutputProperty(display_, id, prop, 0, 100, False, False,
+          AnyPropertyType, &actual_type, &actual_format, &nitems,
+          &bytes_after, &values);
+      if (success == Success && actual_type == XA_ATOM &&
+          actual_format == 32 && nitems == 1) {
+        Atom value = reinterpret_cast<Atom*>(values)[0];
+        if (full_aspect_atom == value)
+          ret = true;
+      }
+      if (values)
+        XFree(values);
+    }
+  }
+  if (props)
+    XFree(props);
+
+  return ret;
+}
+
+void RealOutputConfiguratorDelegate::GetTouchscreens(
+    std::vector<OutputConfigurator::OutputSnapshot>* outputs) {
+  int ndevices = 0;
+  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
+  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
+  if (valuator_x == None || valuator_y == None)
+    return;
+
+  std::set<int> no_match_touchscreen;
+  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
+  for (int i = 0; i < ndevices; i++) {
+    if (!info[i].enabled || info[i].use != XIFloatingSlave)
+      continue;  // Assume all touchscreens are floating slaves
+
+    double width = -1.0;
+    double height = -1.0;
+    bool is_direct_touch = false;
+
+    for (int j = 0; j < info[i].num_classes; j++) {
+      XIAnyClassInfo* class_info = info[i].classes[j];
+
+      if (class_info->type == XIValuatorClass) {
+        XIValuatorClassInfo* valuator_info =
+            reinterpret_cast<XIValuatorClassInfo*>(class_info);
+
+        if (valuator_x == valuator_info->label) {
+          // Ignore X axis valuator with unexpected properties
+          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            width = valuator_info->max;
+          }
+        } else if (valuator_y == valuator_info->label) {
+          // Ignore Y axis valuator with unexpected properties
+          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            height = valuator_info->max;
+          }
+        }
+      }
+#if defined(USE_XI2_MT)
+      if (class_info->type == XITouchClass) {
+        XITouchClassInfo* touch_info =
+            reinterpret_cast<XITouchClassInfo*>(class_info);
+        is_direct_touch = touch_info->mode == XIDirectTouch;
+      }
+#endif
+    }
+
+    // Touchscreens should have absolute X and Y axes,
+    // and be direct touch devices.
+    if (width > 0.0 && height > 0.0 && is_direct_touch) {
+      size_t k = 0;
+      for (; k < outputs->size(); k++) {
+        OutputConfigurator::OutputSnapshot* output = &(*outputs)[k];
+        if (output->native_mode == None || output->touch_device_id != None)
+          continue;
+
+        const OutputConfigurator::ModeInfo* mode_info =
+            OutputConfigurator::GetModeInfo(*output, output->native_mode);
+        if (!mode_info)
+          continue;
+
+        // Allow 1 pixel difference between screen and touchscreen
+        // resolutions.  Because in some cases for monitor resolution
+        // 1024x768 touchscreen's resolution would be 1024x768, but for
+        // some 1023x767.  It really depends on touchscreen's firmware
+        // configuration.
+        if (std::abs(mode_info->width - width) <= 1.0 &&
+            std::abs(mode_info->height - height) <= 1.0) {
+          output->touch_device_id = info[i].deviceid;
+
+          VLOG(2) << "Found touchscreen for output #" << k
+                  << " id " << output->touch_device_id
+                  << " width " << width
+                  << " height " << height;
+          break;
+        }
+      }
+
+      if (k == outputs->size()) {
+        no_match_touchscreen.insert(info[i].deviceid);
+        VLOG(2) << "No matching output for touchscreen"
+                << " id " << info[i].deviceid
+                << " width " << width
+                << " height " << height;
+      }
+
+    }
+  }
+
+  // Sometimes we can't find a matching screen for the touchscreen, e.g.
+  // due to the touchscreen's reporting range having no correlation with the
+  // screen's resolution. In this case, we arbitrarily assign unmatched
+  // touchscreens to unmatched screens.
+  for (std::set<int>::iterator it = no_match_touchscreen.begin();
+       it != no_match_touchscreen.end();
+       it++) {
+    for (size_t i = 0; i < outputs->size(); i++) {
+      if ((*outputs)[i].is_internal == false &&
+          (*outputs)[i].native_mode != None &&
+          (*outputs)[i].touch_device_id == None ) {
+        (*outputs)[i].touch_device_id = *it;
+        VLOG(2) << "Arbitrarily matching touchscreen "
+                << (*outputs)[i].touch_device_id << " to output #" << i;
+        break;
+      }
+    }
+  }
+
+  XIFreeDeviceInfo(info);
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate_x11.h b/chromeos/display/real_output_configurator_delegate_x11.h
new file mode 100644
index 0000000..8130a6d
--- /dev/null
+++ b/chromeos/display/real_output_configurator_delegate_x11.h
@@ -0,0 +1,100 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
+
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "chromeos/display/output_configurator.h"
+
+typedef OUTPUTID Window;
+
+struct _XDisplay;
+typedef struct _XDisplay Display;
+struct _XRROutputInfo;
+typedef _XRROutputInfo XRROutputInfo;
+struct _XRRScreenResources;
+typedef _XRRScreenResources XRRScreenResources;
+
+namespace chromeos {
+
+class RealOutputConfiguratorDelegate : public OutputConfigurator::Delegate {
+ public:
+  RealOutputConfiguratorDelegate();
+  virtual ~RealOutputConfiguratorDelegate();
+
+  // OutputConfigurator::Delegate overrides:
+  virtual int InitResources() OVERRIDE;
+  virtual void HandleScreenChangeNotification(
+      const base::NativeEvent& event) OVERRIDE;
+  virtual void GrabServer() OVERRIDE;
+  virtual void UngrabServer() OVERRIDE;
+  virtual void SyncWithServer() OVERRIDE;
+  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
+  virtual void ForceDPMSOn() OVERRIDE;
+  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
+  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
+  virtual bool ConfigureCrtc(
+      RRCrtc crtc,
+      RRMode mode,
+      RROutput output,
+      int x,
+      int y) OVERRIDE;
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
+  virtual void ConfigureCTM(
+      int touch_device_id,
+      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
+  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
+  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
+
+ private:
+  // Initializes |mode_info| to contain details corresponding to |mode|. Returns
+  // true on success.
+  bool InitModeInfo(RRMode mode, OutputConfigurator::ModeInfo* mode_info);
+
+  // Helper method for GetOutputs() that returns an OutputSnapshot struct based
+  // on the passed-in information. Further initialization is required (e.g.
+  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
+  OutputConfigurator::OutputSnapshot InitOutputSnapshot(
+      RROutput id,
+      XRROutputInfo* info,
+      RRCrtc* last_used_crtc,
+      int index);
+
+  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
+  // framebuffer resize. This is faster than turning them off, resizing,
+  // then turning them back on.
+  void DestroyUnusedCrtcs(
+      const std::vector<OutputConfigurator::OutputSnapshot>& outputs);
+
+  // Returns whether |id| is configured to preserve aspect when scaling.
+  bool IsOutputAspectPreservingScaling(RROutput id);
+
+  // Searches for touchscreens among input devices,
+  // and tries to match them up to screens in |outputs|.
+  // |outputs| is an array of detected screens.
+  // If a touchscreen with same resolution as an output's native mode
+  // is detected, its id will be stored in this output.
+  void GetTouchscreens(
+      std::vector<OutputConfigurator::OutputSnapshot>* outputs);
+
+  Display* display_;
+  Window window_;
+
+  // Initialized when the server is grabbed and freed when it's ungrabbed.
+  XRRScreenResources* screen_;
+
+  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegate);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/ui/ozone/ozone_platform.cc b/ui/ozone/ozone_platform.cc
index a084005..49cd7c6 100644
--- a/ui/ozone/ozone_platform.cc
+++ b/ui/ozone/ozone_platform.cc
@@ -54,6 +54,10 @@ void OzonePlatform::Initialize() {
   // Inject ozone interfaces.
   gfx::SurfaceFactoryOzone::SetInstance(instance_->GetSurfaceFactoryOzone());
   ui::EventFactoryOzone::SetInstance(instance_->GetEventFactoryOzone());
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzone::SetInstance(
+      instance_->GetOutputConfiguratorOzone());
+#endif
 }
 
 // static
diff --git a/ui/ozone/ozone_platform.h b/ui/ozone/ozone_platform.h
index 519d8b2..5f9c5d4 100644
--- a/ui/ozone/ozone_platform.h
+++ b/ui/ozone/ozone_platform.h
@@ -6,6 +6,9 @@
 #define UI_OZONE_OZONE_PLATFORM_H_
 
 #include "base/memory/scoped_ptr.h"
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone.h"
+#endif
 #include "ui/events/ozone/event_factory_ozone.h"
 #include "ui/gfx/ozone/surface_factory_ozone.h"
 #include "ui/ozone/ozone_export.h"
@@ -40,6 +43,9 @@ class OZONE_EXPORT OzonePlatform {
   // inject these objects themselves. Ownership is retained by OzonePlatform.
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() = 0;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() = 0;
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone* GetOutputConfiguratorOzone() = 0;
+#endif
 
  private:
   static OzonePlatform* instance_;
diff --git a/ui/ozone/platform/dri/ozone_platform_dri.cc b/ui/ozone/platform/dri/ozone_platform_dri.cc
index 9feb9a2..3e4690f 100644
--- a/ui/ozone/platform/dri/ozone_platform_dri.cc
+++ b/ui/ozone/platform/dri/ozone_platform_dri.cc
@@ -20,6 +20,13 @@ ui::EventFactoryOzone* OzonePlatformDri::GetEventFactoryOzone() {
   return &event_factory_ozone_;
 }
 
+#if defined(OS_CHROMEOS)
+chromeos::OutputConfiguratorOzone*
+  OzonePlatformDri::GetOutputConfiguratorOzone() {
+  return &output_configurator_;
+}
+#endif
+
 OzonePlatform* CreateOzonePlatformDri() { return new OzonePlatformDri; }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/dri/ozone_platform_dri.h b/ui/ozone/platform/dri/ozone_platform_dri.h
index 64df1cc..2487a3d 100644
--- a/ui/ozone/platform/dri/ozone_platform_dri.h
+++ b/ui/ozone/platform/dri/ozone_platform_dri.h
@@ -5,6 +5,9 @@
 #ifndef UI_OZONE_PLATFORM_DRI_OZONE_PLATFORM_DRI_H_
 #define UI_OZONE_PLATFORM_DRI_OZONE_PLATFORM_DRI_H_
 
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#endif
 #include "ui/events/ozone/evdev/event_factory.h"
 #include "ui/gfx/ozone/dri/dri_surface_factory.h"
 #include "ui/ozone/ozone_platform.h"
@@ -22,10 +25,17 @@ class OzonePlatformDri : public OzonePlatform {
 
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() OVERRIDE;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() OVERRIDE;
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone*
+    GetOutputConfiguratorOzone() OVERRIDE;
+#endif
 
  private:
   gfx::DriSurfaceFactory surface_factory_ozone_;
   ui::EventFactoryEvdev event_factory_ozone_;
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzoneDri output_configurator_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformDri);
 };
diff --git a/ui/ozone/platform/test/ozone_platform_test.cc b/ui/ozone/platform/test/ozone_platform_test.cc
index 860837e..4830522 100644
--- a/ui/ozone/platform/test/ozone_platform_test.cc
+++ b/ui/ozone/platform/test/ozone_platform_test.cc
@@ -24,6 +24,13 @@ ui::EventFactoryOzone* OzonePlatformTest::GetEventFactoryOzone() {
   return &event_factory_ozone_;
 }
 
+#if defined(OS_CHROMEOS)
+chromeos::OutputConfiguratorOzone*
+  OzonePlatformTest::GetOutputConfiguratorOzone() {
+  return &output_configurator_;
+}
+#endif
+
 OzonePlatform* CreateOzonePlatformTest() {
   CommandLine* cmd = CommandLine::ForCurrentProcess();
   base::FilePath location = base::FilePath("/dev/null");
diff --git a/ui/ozone/platform/test/ozone_platform_test.h b/ui/ozone/platform/test/ozone_platform_test.h
index bb199a3..e273f52 100644
--- a/ui/ozone/platform/test/ozone_platform_test.h
+++ b/ui/ozone/platform/test/ozone_platform_test.h
@@ -6,6 +6,9 @@
 #define UI_OZONE_PLATFORM_TEST_OZONE_PLATFORM_TEST_H_
 
 #include "base/files/file_path.h"
+#if defined(OS_CHROMEOS)
+#include "chromeos/display/output_configurator_ozone_dri.h"
+#endif
 #include "ui/events/ozone/evdev/event_factory.h"
 #include "ui/gfx/ozone/impl/file_surface_factory.h"
 #include "ui/ozone/ozone_platform.h"
@@ -22,10 +25,16 @@ class OzonePlatformTest : public OzonePlatform {
 
   virtual gfx::SurfaceFactoryOzone* GetSurfaceFactoryOzone() OVERRIDE;
   virtual ui::EventFactoryOzone* GetEventFactoryOzone() OVERRIDE;
-
+#if defined(OS_CHROMEOS)
+  virtual chromeos::OutputConfiguratorOzone*
+    GetOutputConfiguratorOzone() OVERRIDE;
+#endif
  private:
   gfx::FileSurfaceFactory surface_factory_ozone_;
   ui::EventFactoryEvdev event_factory_ozone_;
+#if defined(OS_CHROMEOS)
+  chromeos::OutputConfiguratorOzoneDri output_configurator_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformTest);
 };
-- 
1.7.9.5

