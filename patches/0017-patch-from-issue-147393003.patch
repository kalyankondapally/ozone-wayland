From e9caa4be775053235ea47956d7282eb5b29217cf Mon Sep 17 00:00:00 2001
From: Kondapally Kalyan <kalyan.kondapally@intel.com>
Date: Wed, 29 Jan 2014 06:37:52 +0200
Subject: [PATCH 02/15] patch from issue 147393003

---
 ash/display/display_change_observer_chromeos.cc    |   73 +-
 ash/display/display_change_observer_chromeos.h     |    7 +-
 ash/display/display_error_observer_chromeos.cc     |    8 +-
 ash/display/display_error_observer_chromeos.h      |    2 +-
 ash/display/display_manager.cc                     |    5 +-
 ash/display/event_transformation_handler.cc        |    3 +-
 ash/display/output_configurator_animation.cc       |    4 +-
 ash/display/output_configurator_animation.h        |    5 +-
 ash/shell.cc                                       |    9 -
 ash/touch/touch_observer_hud.cc                    |    2 +-
 ash/touch/touch_observer_hud.h                     |    3 +-
 .../pepper_output_protection_message_filter.cc     |   59 +-
 chromeos/DEPS                                      |    1 +
 chromeos/chromeos.gyp                              |   10 +-
 chromeos/display/native_display_bridge_x11.cc      |  858 ++++++++++
 chromeos/display/native_display_bridge_x11.h       |  158 ++
 chromeos/display/output_configurator.cc            |  842 +++++-----
 chromeos/display/output_configurator.h             |  315 +---
 chromeos/display/output_configurator_unittest.cc   | 1739 +++++++++++---------
 chromeos/display/output_util.cc                    |   54 +-
 chromeos/display/output_util.h                     |   45 +-
 .../display/real_output_configurator_delegate.cc   |  614 -------
 .../display/real_output_configurator_delegate.h    |  100 --
 ui/gfx/display_snapshot.cc                         |  129 ++
 ui/gfx/display_snapshot.h                          |  114 ++
 ui/gfx/gfx.gyp                                     |    5 +
 ui/gfx/mode_info.cc                                |   38 +
 ui/gfx/mode_info.h                                 |   41 +
 ui/gfx/native_display_bridge.h                     |  106 ++
 29 files changed, 2977 insertions(+), 2372 deletions(-)
 create mode 100644 chromeos/display/native_display_bridge_x11.cc
 create mode 100644 chromeos/display/native_display_bridge_x11.h
 delete mode 100644 chromeos/display/real_output_configurator_delegate.cc
 delete mode 100644 chromeos/display/real_output_configurator_delegate.h
 create mode 100644 ui/gfx/display_snapshot.cc
 create mode 100644 ui/gfx/display_snapshot.h
 create mode 100644 ui/gfx/mode_info.cc
 create mode 100644 ui/gfx/mode_info.h
 create mode 100644 ui/gfx/native_display_bridge.h

diff --git a/ash/display/display_change_observer_chromeos.cc b/ash/display/display_change_observer_chromeos.cc
index 7c5780ec..8b3e1cb 100644
--- a/ash/display/display_change_observer_chromeos.cc
+++ b/ash/display/display_change_observer_chromeos.cc
@@ -22,6 +22,7 @@
 #include "ui/base/x/x11_util.h"
 #include "ui/compositor/dip_util.h"
 #include "ui/gfx/display.h"
+#include "ui/gfx/display_snapshot.h"
 
 namespace ash {
 namespace internal {
@@ -49,16 +50,19 @@ struct ResolutionSorter {
 
 // static
 std::vector<Resolution> DisplayChangeObserver::GetResolutionList(
-    const OutputConfigurator::OutputSnapshot& output) {
+    const gfx::DisplaySnapshot& output) {
   typedef std::map<std::pair<int,int>, Resolution> ResolutionMap;
   ResolutionMap resolution_map;
 
-  for (std::map<RRMode, OutputConfigurator::ModeInfo>::const_iterator it =
-       output.mode_infos.begin(); it != output.mode_infos.end(); ++it) {
-    const OutputConfigurator::ModeInfo& mode_info = it->second;
-    const std::pair<int, int> size(mode_info.width, mode_info.height);
-    const Resolution resolution(gfx::Size(mode_info.width, mode_info.height),
-                                mode_info.interlaced);
+  for (OutputConfigurator::ModeInfos::const_iterator it =
+           output.get_mode_infos().begin();
+       it != output.get_mode_infos().end();
+       ++it) {
+    const gfx::ModeInfo* mode_info = *it;
+    const std::pair<int, int> size(mode_info->get_size().width(),
+                                   mode_info->get_size().height());
+    const Resolution resolution(gfx::Size(mode_info->get_size()),
+                                mode_info->is_interlaced());
 
     // Add the resolution if it isn't already present and override interlaced
     // resolutions with non-interlaced ones.
@@ -87,19 +91,20 @@ DisplayChangeObserver::~DisplayChangeObserver() {
   Shell::GetInstance()->RemoveShellObserver(this);
 }
 
-chromeos::OutputState DisplayChangeObserver::GetStateForDisplayIds(
+gfx::NativeDisplayBridge::OutputState
+DisplayChangeObserver::GetStateForDisplayIds(
     const std::vector<int64>& display_ids) const {
   if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kAshForceMirrorMode)) {
-    return chromeos::STATE_DUAL_MIRROR;
+    return gfx::NativeDisplayBridge::STATE_DUAL_MIRROR;
   }
 
   CHECK_EQ(2U, display_ids.size());
   DisplayIdPair pair = std::make_pair(display_ids[0], display_ids[1]);
   DisplayLayout layout = Shell::GetInstance()->display_manager()->
       layout_store()->GetRegisteredDisplayLayout(pair);
-  return layout.mirrored ?
-      chromeos::STATE_DUAL_MIRROR : chromeos::STATE_DUAL_EXTENDED;
+  return layout.mirrored ? gfx::NativeDisplayBridge::STATE_DUAL_MIRROR
+                         : gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED;
 }
 
 bool DisplayChangeObserver::GetResolutionForDisplayId(int64 display_id,
@@ -117,50 +122,51 @@ bool DisplayChangeObserver::GetResolutionForDisplayId(int64 display_id,
 }
 
 void DisplayChangeObserver::OnDisplayModeChanged(
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
+    const ScopedVector<gfx::DisplaySnapshot>& outputs) {
   std::vector<DisplayInfo> displays;
   std::set<int64> ids;
   for (size_t i = 0; i < outputs.size(); ++i) {
-    const OutputConfigurator::OutputSnapshot& output = outputs[i];
+    const gfx::DisplaySnapshot* output = outputs[i];
 
-    if (output.type == chromeos::OUTPUT_TYPE_INTERNAL &&
+    if (output->get_type() == gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL &&
         gfx::Display::InternalDisplayId() == gfx::Display::kInvalidDisplayID) {
       // Fall back to output index. crbug.com/180100
       gfx::Display::SetInternalDisplayId(
-          output.display_id == gfx::Display::kInvalidDisplayID ? output.index :
-          output.display_id);
+          output->get_display_id() == gfx::Display::kInvalidDisplayID
+              ? chromeos::GetInternalDisplayId(output)
+              : output->get_display_id());
     }
 
-    const OutputConfigurator::ModeInfo* mode_info =
-        OutputConfigurator::GetModeInfo(output, output.current_mode);
+    const gfx::ModeInfo* mode_info = output->get_current_mode();
     if (!mode_info)
       continue;
 
     float device_scale_factor = 1.0f;
-    if (!ui::IsXDisplaySizeBlackListed(output.width_mm, output.height_mm) &&
-        (kInchInMm * mode_info->width / output.width_mm) >
-        kHighDensityDPIThreshold) {
+    if (!ui::IsXDisplaySizeBlackListed(output->get_physical_size().width(),
+                                       output->get_physical_size().height()) &&
+        (kInchInMm * mode_info->get_size().width() /
+         output->get_physical_size().width()) > kHighDensityDPIThreshold) {
       device_scale_factor = 2.0f;
     }
-    gfx::Rect display_bounds(
-        output.x, output.y, mode_info->width, mode_info->height);
+    gfx::Rect display_bounds(output->get_origin(), mode_info->get_size());
 
     std::vector<Resolution> resolutions;
-    if (output.type != chromeos::OUTPUT_TYPE_INTERNAL)
-      resolutions = GetResolutionList(output);
+    if (output->get_type() != gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL)
+      resolutions = GetResolutionList(*output);
 
-    std::string name = output.type == chromeos::OUTPUT_TYPE_INTERNAL ?
-        l10n_util::GetStringUTF8(IDS_ASH_INTERNAL_DISPLAY_NAME) :
-        chromeos::GetDisplayName(output.output);
+    std::string name =
+        output->get_type() == gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL
+            ? l10n_util::GetStringUTF8(IDS_ASH_INTERNAL_DISPLAY_NAME)
+            : chromeos::GetDisplayName(output);
     if (name.empty())
       name = l10n_util::GetStringUTF8(IDS_ASH_STATUS_TRAY_UNKNOWN_DISPLAY_NAME);
 
     bool has_overscan = false;
-    chromeos::GetOutputOverscanFlag(output.output, &has_overscan);
+    chromeos::GetOutputOverscanFlag(output, &has_overscan);
 
-    int64 id = output.display_id;
+    int64 id = output->get_display_id();
     if (id == gfx::Display::kInvalidDisplayID || ids.find(id) != ids.end())
-      id = output.index;
+      id = chromeos::GetInternalDisplayId(output);
     ids.insert(id);
 
     displays.push_back(DisplayInfo(id, name, has_overscan));
@@ -169,8 +175,9 @@ void DisplayChangeObserver::OnDisplayModeChanged(
     displays.back().set_native(true);
     displays.back().set_resolutions(resolutions);
     displays.back().set_touch_support(
-        output.touch_device_id == 0 ? gfx::Display::TOUCH_SUPPORT_UNAVAILABLE :
-                                      gfx::Display::TOUCH_SUPPORT_AVAILABLE);
+        output->get_touch_device_id() == 0
+            ? gfx::Display::TOUCH_SUPPORT_UNAVAILABLE
+            : gfx::Display::TOUCH_SUPPORT_AVAILABLE);
   }
 
   // DisplayManager can be null during the boot.
diff --git a/ash/display/display_change_observer_chromeos.h b/ash/display/display_change_observer_chromeos.h
index c75c00b..4d78584 100644
--- a/ash/display/display_change_observer_chromeos.h
+++ b/ash/display/display_change_observer_chromeos.h
@@ -24,13 +24,13 @@ class DisplayChangeObserver
  public:
   // Returns the resolution list.
   ASH_EXPORT static std::vector<Resolution> GetResolutionList(
-      const chromeos::OutputConfigurator::OutputSnapshot& output);
+      const gfx::DisplaySnapshot& output);
 
   DisplayChangeObserver();
   virtual ~DisplayChangeObserver();
 
   // chromeos::OutputConfigurator::StateController overrides:
-  virtual chromeos::OutputState GetStateForDisplayIds(
+  virtual gfx::NativeDisplayBridge::OutputState GetStateForDisplayIds(
       const std::vector<int64>& outputs) const OVERRIDE;
   virtual bool GetResolutionForDisplayId(int64 display_id,
                                          int* width,
@@ -38,8 +38,7 @@ class DisplayChangeObserver
 
   // Overriden from chromeos::OutputConfigurator::Observer:
   virtual void OnDisplayModeChanged(
-      const std::vector<chromeos::OutputConfigurator::OutputSnapshot>& outputs)
-      OVERRIDE;
+      const ScopedVector<gfx::DisplaySnapshot>& outputs) OVERRIDE;
 
   // Overriden from ShellObserver:
   virtual void OnAppTerminating() OVERRIDE;
diff --git a/ash/display/display_error_observer_chromeos.cc b/ash/display/display_error_observer_chromeos.cc
index 5fe543c..bbc72aa 100644
--- a/ash/display/display_error_observer_chromeos.cc
+++ b/ash/display/display_error_observer_chromeos.cc
@@ -31,15 +31,15 @@ DisplayErrorObserver::~DisplayErrorObserver() {
 }
 
 void DisplayErrorObserver::OnDisplayModeChangeFailed(
-    chromeos::OutputState new_state) {
+    gfx::NativeDisplayBridge::OutputState new_state) {
   // Always remove the notification to make sure the notification appears
   // as a popup in any situation.
   message_center::MessageCenter::Get()->RemoveNotification(
       kDisplayErrorNotificationId, false /* by_user */);
 
-  int message_id = (new_state == chromeos::STATE_DUAL_MIRROR) ?
-      IDS_ASH_DISPLAY_FAILURE_ON_MIRRORING :
-      IDS_ASH_DISPLAY_FAILURE_ON_NON_MIRRORING;
+  int message_id = (new_state == gfx::NativeDisplayBridge::STATE_DUAL_MIRROR)
+                       ? IDS_ASH_DISPLAY_FAILURE_ON_MIRRORING
+                       : IDS_ASH_DISPLAY_FAILURE_ON_NON_MIRRORING;
 
   ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
   scoped_ptr<Notification> notification(new Notification(
diff --git a/ash/display/display_error_observer_chromeos.h b/ash/display/display_error_observer_chromeos.h
index b8bb1c1..4d85d9c 100644
--- a/ash/display/display_error_observer_chromeos.h
+++ b/ash/display/display_error_observer_chromeos.h
@@ -23,7 +23,7 @@ class ASH_EXPORT DisplayErrorObserver
 
   // chromeos::OutputConfigurator::Observer overrides:
   virtual void OnDisplayModeChangeFailed(
-      chromeos::OutputState failed_new_state) OVERRIDE;
+      gfx::NativeDisplayBridge::OutputState failed_new_state) OVERRIDE;
 
  private:
   friend class DisplayErrorObserverTest;
diff --git a/ash/display/display_manager.cc b/ash/display/display_manager.cc
index fa86330..fe71007 100644
--- a/ash/display/display_manager.cc
+++ b/ash/display/display_manager.cc
@@ -850,8 +850,9 @@ void DisplayManager::SetMirrorMode(bool mirrored) {
 
 #if defined(OS_CHROMEOS)
   if (base::SysInfo::IsRunningOnChromeOS()) {
-    chromeos::OutputState new_state = mirrored ?
-        chromeos::STATE_DUAL_MIRROR : chromeos::STATE_DUAL_EXTENDED;
+    gfx::NativeDisplayBridge::OutputState new_state =
+        mirrored ? gfx::NativeDisplayBridge::STATE_DUAL_MIRROR
+                 : gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED;
     Shell::GetInstance()->output_configurator()->SetDisplayMode(new_state);
     return;
   }
diff --git a/ash/display/event_transformation_handler.cc b/ash/display/event_transformation_handler.cc
index 0c869f8..08a8af2 100644
--- a/ash/display/event_transformation_handler.cc
+++ b/ash/display/event_transformation_handler.cc
@@ -67,7 +67,8 @@ void EventTransformationHandler::OnTouchEvent(ui::TouchEvent* event) {
   // Check output_configurator's output_state instead of checking
   // DisplayManager::IsMirrored() because the compositor based mirroring
   // won't cause the scaling issue.
-  if (output_configurator->output_state() != chromeos::STATE_DUAL_MIRROR)
+  if (output_configurator->output_state() !=
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR)
     return;
 
   const std::map<int, float>& area_ratio_map =
diff --git a/ash/display/output_configurator_animation.cc b/ash/display/output_configurator_animation.cc
index 2fb5d52..39655d1 100644
--- a/ash/display/output_configurator_animation.cc
+++ b/ash/display/output_configurator_animation.cc
@@ -204,13 +204,13 @@ void OutputConfiguratorAnimation::StartFadeInAnimation() {
 }
 
 void OutputConfiguratorAnimation::OnDisplayModeChanged(
-    const std::vector<chromeos::OutputConfigurator::OutputSnapshot>& outputs) {
+    const std::vector<gfx::DisplaySnapshot>& outputs) {
   if (!hiding_layers_.empty())
     StartFadeInAnimation();
 }
 
 void OutputConfiguratorAnimation::OnDisplayModeChangeFailed(
-    chromeos::OutputState failed_new_state) {
+    gfx::NativeDisplayBridge::OutputState failed_new_state) {
   if (!hiding_layers_.empty())
     StartFadeInAnimation();
 }
diff --git a/ash/display/output_configurator_animation.h b/ash/display/output_configurator_animation.h
index f53ffa5..90ea95f 100644
--- a/ash/display/output_configurator_animation.h
+++ b/ash/display/output_configurator_animation.h
@@ -44,10 +44,9 @@ class ASH_EXPORT OutputConfiguratorAnimation
  protected:
   // chromeos::OutputConfigurator::Observer overrides:
   virtual void OnDisplayModeChanged(
-      const std::vector<chromeos::OutputConfigurator::OutputSnapshot>& outputs)
-      OVERRIDE;
+      const std::vector<gfx::DisplaySnapshot>& outputs) OVERRIDE;
   virtual void OnDisplayModeChangeFailed(
-      chromeos::OutputState failed_new_state) OVERRIDE;
+      gfx::NativeDisplayBridge::OutputState failed_new_state) OVERRIDE;
 
  private:
   // Clears all hiding layers.  Note that in case that this method is called
diff --git a/ash/shell.cc b/ash/shell.cc
index d5209fb..7687738 100644
--- a/ash/shell.cc
+++ b/ash/shell.cc
@@ -594,12 +594,6 @@ Shell::Shell(ShellDelegate* delegate)
 #if defined(OS_CHROMEOS) && defined(USE_X11)
   output_configurator_->Init(!gpu_support_->IsPanelFittingDisabled());
   user_metrics_recorder_.reset(new UserMetricsRecorder);
-
-  base::MessagePumpX11::Current()->AddDispatcherForRootWindow(
-      output_configurator());
-  // We can't do this with a root window listener because XI_HierarchyChanged
-  // messages don't have a target window.
-  base::MessagePumpX11::Current()->AddObserver(output_configurator());
 #endif  // defined(OS_CHROMEOS)
 
 #if defined(OS_CHROMEOS)
@@ -730,9 +724,6 @@ Shell::~Shell() {
     output_configurator_->RemoveObserver(output_configurator_animation_.get());
   if (display_error_observer_)
     output_configurator_->RemoveObserver(display_error_observer_.get());
-  base::MessagePumpX11::Current()->RemoveDispatcherForRootWindow(
-      output_configurator());
-  base::MessagePumpX11::Current()->RemoveObserver(output_configurator());
   display_change_observer_.reset();
 #endif  // defined(OS_CHROMEOS)
 
diff --git a/ash/touch/touch_observer_hud.cc b/ash/touch/touch_observer_hud.cc
index ff66e2c..df7d77b 100644
--- a/ash/touch/touch_observer_hud.cc
+++ b/ash/touch/touch_observer_hud.cc
@@ -104,7 +104,7 @@ void TouchObserverHUD::OnDisplayRemoved(const gfx::Display& old_display) {
 
 #if defined(OS_CHROMEOS)
 void TouchObserverHUD::OnDisplayModeChanged(
-    const std::vector<chromeos::OutputConfigurator::OutputSnapshot>& outputs) {
+    const std::vector<gfx::DisplaySnapshot>& outputs) {
   // Clear touch HUD for any change in display mode (single, dual extended, dual
   // mirrored, ...).
   Clear();
diff --git a/ash/touch/touch_observer_hud.h b/ash/touch/touch_observer_hud.h
index 4e74e76..a7c140d 100644
--- a/ash/touch/touch_observer_hud.h
+++ b/ash/touch/touch_observer_hud.h
@@ -68,8 +68,7 @@ class ASH_EXPORT TouchObserverHUD
 #if defined(OS_CHROMEOS)
   // Overriden from chromeos::OutputConfigurator::Observer.
   virtual void OnDisplayModeChanged(
-      const std::vector<chromeos::OutputConfigurator::OutputSnapshot>& outputs)
-      OVERRIDE;
+      const std::vector<gfx::DisplaySnapshot>& outputs) OVERRIDE;
 #endif  // defined(OS_CHROMEOS)
 
   // Overriden form DisplayController::Observer.
diff --git a/chrome/browser/renderer_host/pepper/pepper_output_protection_message_filter.cc b/chrome/browser/renderer_host/pepper/pepper_output_protection_message_filter.cc
index 5ffd4b2..6f2e6e7 100644
--- a/chrome/browser/renderer_host/pepper/pepper_output_protection_message_filter.cc
+++ b/chrome/browser/renderer_host/pepper/pepper_output_protection_message_filter.cc
@@ -30,46 +30,42 @@ namespace chrome {
 namespace {
 
 #if defined(OS_CHROMEOS)
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NONE) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_NONE),
-    PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NONE);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NONE) ==
+                   static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_NONE),
+               PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NONE);
 COMPILE_ASSERT(
     static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_UNKNOWN) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_UNKNOWN),
+        static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_UNKNOWN),
     PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_UNKNOWN);
 COMPILE_ASSERT(
     static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_INTERNAL) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_INTERNAL),
+        static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL),
     PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_INTERNAL);
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_VGA) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_VGA),
-    PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_VGA);
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_HDMI) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_HDMI),
-    PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_HDMI);
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DVI) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_DVI),
-    PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DVI);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_VGA) ==
+                   static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_VGA),
+               PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_VGA);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_HDMI) ==
+                   static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI),
+               PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_HDMI);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DVI) ==
+                   static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_DVI),
+               PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DVI);
 COMPILE_ASSERT(
     static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DISPLAYPORT) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_DISPLAYPORT),
+        static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_DISPLAYPORT),
     PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_DISPLAYPORT);
 COMPILE_ASSERT(
     static_cast<int>(PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NETWORK) ==
-    static_cast<int>(chromeos::OUTPUT_TYPE_NETWORK),
+        static_cast<int>(gfx::NativeDisplayBridge::OUTPUT_TYPE_NETWORK),
     PP_OUTPUT_PROTECTION_LINK_TYPE_PRIVATE_NETWORK);
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_METHOD_PRIVATE_NONE) ==
-    static_cast<int>(chromeos::OUTPUT_PROTECTION_METHOD_NONE),
-    PP_OUTPUT_PROTECTION_METHOD_PRIVATE_NONE);
-COMPILE_ASSERT(
-    static_cast<int>(PP_OUTPUT_PROTECTION_METHOD_PRIVATE_HDCP) ==
-    static_cast<int>(chromeos::OUTPUT_PROTECTION_METHOD_HDCP),
-    PP_OUTPUT_PROTECTION_METHOD_PRIVATE_HDCP);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_METHOD_PRIVATE_NONE) ==
+                   static_cast<int>(
+                       gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE),
+               PP_OUTPUT_PROTECTION_METHOD_PRIVATE_NONE);
+COMPILE_ASSERT(static_cast<int>(PP_OUTPUT_PROTECTION_METHOD_PRIVATE_HDCP) ==
+                   static_cast<int>(
+                       gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP),
+               PP_OUTPUT_PROTECTION_METHOD_PRIVATE_HDCP);
 
 bool GetCurrentDisplayId(content::RenderFrameHost* rfh, int64* display_id) {
   DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));
@@ -187,7 +183,7 @@ int32_t PepperOutputProtectionMessageFilter::Delegate::OnQueryStatus(
         MediaCaptureDevicesDispatcher::GetInstance()
             ->IsDesktopCaptureInProgress();
     if (capture_detected)
-      *link_mask |= chromeos::OUTPUT_TYPE_NETWORK;
+      *link_mask |= gfx::NativeDisplayBridge::OUTPUT_TYPE_NETWORK;
   }
 
   return result ? PP_OK : PP_ERROR_FAILED;
@@ -220,7 +216,8 @@ void PepperOutputProtectionMessageFilter::Delegate::OnWindowHierarchyChanged(
   if (display_id_ == new_display_id)
     return;
 
-  if (desired_method_mask_ != chromeos::OUTPUT_PROTECTION_METHOD_NONE) {
+  if (desired_method_mask_ !=
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE) {
     // Display changed and should enable output protections on new display.
     chromeos::OutputConfigurator* configurator =
         ash::Shell::GetInstance()->output_configurator();
@@ -229,7 +226,7 @@ void PepperOutputProtectionMessageFilter::Delegate::OnWindowHierarchyChanged(
     configurator->EnableOutputProtection(
         GetClientId(),
         display_id_,
-        chromeos::OUTPUT_PROTECTION_METHOD_NONE);
+        gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE);
   }
   display_id_ = new_display_id;
 }
diff --git a/chromeos/DEPS b/chromeos/DEPS
index a88fc06..ef13ab8 100644
--- a/chromeos/DEPS
+++ b/chromeos/DEPS
@@ -3,4 +3,5 @@ include_rules = [
   "+net",
   "+third_party/cros_system_api",
   "+third_party/libxml",
+  "+ui/gfx",
 ]
diff --git a/chromeos/chromeos.gyp b/chromeos/chromeos.gyp
index de1fa56..3324221 100644
--- a/chromeos/chromeos.gyp
+++ b/chromeos/chromeos.gyp
@@ -204,12 +204,12 @@
         'dbus/volume_state.h',
         'disks/disk_mount_manager.cc',
         'disks/disk_mount_manager.h',
+        'display/native_display_bridge_x11.cc',
+        'display/native_display_bridge_x11.h',
         'display/output_configurator.cc',
         'display/output_configurator.h',
         'display/output_util.cc',
         'display/output_util.h',
-        'display/real_output_configurator_delegate.cc',
-        'display/real_output_configurator_delegate.h',
         'ime/component_extension_ime_manager.cc',
         'ime/component_extension_ime_manager.h',
         'ime/extension_ime_util.cc',
@@ -359,12 +359,12 @@
           'sources!': [
             'ime/xkeyboard.cc',
             'ime/xkeyboard.h',
+            'display/display_configurator_x11.cc',
+            'display/display_configurator_x11.h',
             'display/output_configurator.cc',
             'display/output_configurator.h',
             'display/output_util.cc',
             'display/output_util.h',
-            'display/real_output_configurator_delegate.cc',
-            'display/real_output_configurator_delegate.h',
             'ime/xkeyboard.cc',
             'ime/xkeyboard.h',
           ],
@@ -463,6 +463,8 @@
         '../net/net.gyp:net_test_support',
         '../testing/gmock.gyp:gmock',
         '../testing/gtest.gyp:gtest',
+        '../ui/gfx/gfx.gyp:gfx',
+        '../ui/gfx/gfx.gyp:gfx_geometry',
         '../url/url.gyp:url_lib',
         'chromeos_test_support',
         'power_manager_proto',
diff --git a/chromeos/display/native_display_bridge_x11.cc b/chromeos/display/native_display_bridge_x11.cc
new file mode 100644
index 0000000..a21721b
--- /dev/null
+++ b/chromeos/display/native_display_bridge_x11.cc
@@ -0,0 +1,858 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chromeos/display/native_display_bridge_x11.h"
+
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/dpms.h>
+#include <X11/extensions/XInput.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xrandr.h>
+
+#include <cmath>
+#include <set>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/message_loop/message_pump_x11.h"
+#include "base/strings/stringprintf.h"
+#include "base/x11/edid_parser_x11.h"
+#include "base/x11/x11_error_tracker.h"
+#include "chromeos/display/output_util.h"
+#include "ui/gfx/mode_info.h"
+
+namespace chromeos {
+
+namespace {
+
+// DPI measurements.
+const float kMmInInch = 25.4;
+const float kDpi96 = 96.0;
+const float kPixelsToMmScale = kMmInInch / kDpi96;
+
+// Prefixes of output name
+const char kOutputName_VGA[] = "VGA";
+const char kOutputName_HDMI[] = "HDMI";
+const char kOutputName_DVI[] = "DVI";
+const char kOutputName_DisplayPort[] = "DP";
+
+const char kContentProtectionAtomName[] = "Content Protection";
+const char kProtectionUndesiredAtomName[] = "Undesired";
+const char kProtectionDesiredAtomName[] = "Desired";
+const char kProtectionEnabledAtomName[] = "Enabled";
+
+bool IsInternalOutput(const XRROutputInfo* output_info) {
+  return IsInternalOutputName(std::string(output_info->name));
+}
+
+RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
+  return output_info->nmode > 0 ? output_info->modes[0] : None;
+}
+
+class X11ModeInfo : public gfx::ModeInfo {
+ public:
+  X11ModeInfo(int width,
+              int height,
+              bool interlaced,
+              float refresh_rate,
+              RRMode mode_id)
+      : ModeInfo(width, height, interlaced, refresh_rate), mode_id_(mode_id) {}
+
+  virtual ~X11ModeInfo() {}
+
+  virtual bool Equals(const gfx::ModeInfo& mode) const OVERRIDE {
+    const X11ModeInfo& x11_mode = static_cast<const X11ModeInfo&>(mode);
+    return x11_mode.get_mode_id() == mode_id_;
+  }
+
+  virtual ModeInfo* Clone() const OVERRIDE {
+    return new X11ModeInfo(get_size().width(),
+                           get_size().height(),
+                           is_interlaced(),
+                           get_refresh_rate(),
+                           get_mode_id());
+  }
+
+  RRMode get_mode_id() const { return mode_id_; }
+
+ private:
+  RRMode mode_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11ModeInfo);
+};
+
+}  // namespace
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeDisplayBridgeX11::X11MessagePumpObserver
+
+class NativeDisplayBridgeX11::X11MessagePumpObserver
+    : public base::MessagePumpObserver {
+ public:
+  X11MessagePumpObserver(int xrandr_event_base,
+                         NativeDisplayBridgeX11* delegate);
+  virtual ~X11MessagePumpObserver();
+
+  // Called when an RRNotify event is received.  The implementation is
+  // interested in the cases of RRNotify events which correspond to output
+  // add/remove events.  Note that Output add/remove events are sent in response
+  // to our own reconfiguration operations so spurious events are common.
+  virtual base::EventStatus WillProcessEvent(const base::NativeEvent& event)
+      OVERRIDE;
+  virtual void DidProcessEvent(const base::NativeEvent& event) OVERRIDE;
+
+ private:
+  // The base of the event numbers used to represent XRandr events used in
+  // decoding events regarding output add/remove.
+  int xrandr_event_base_;
+
+  NativeDisplayBridgeX11* delegate_;
+};
+
+NativeDisplayBridgeX11::X11MessagePumpObserver::X11MessagePumpObserver(
+    int xrandr_event_base,
+    NativeDisplayBridgeX11* delegate)
+    : xrandr_event_base_(xrandr_event_base), delegate_(delegate) {
+  base::MessagePumpX11::Current()->AddObserver(this);
+}
+
+NativeDisplayBridgeX11::X11MessagePumpObserver::~X11MessagePumpObserver() {
+  base::MessagePumpX11::Current()->RemoveObserver(this);
+}
+
+base::EventStatus
+NativeDisplayBridgeX11::X11MessagePumpObserver::WillProcessEvent(
+    const base::NativeEvent& event) {
+  // XI_HierarchyChanged events are special. There is no window associated with
+  // these events. So process them directly from here.
+  if (event->type == GenericEvent &&
+      event->xgeneric.evtype == XI_HierarchyChanged) {
+    VLOG(1) << "Received XI_HierarchyChanged event";
+    // Defer configuring outputs to not stall event processing.
+    // This also takes care of same event being received twice.
+    FOR_EACH_OBSERVER(gfx::NativeDisplayBridge::Observer,
+                      delegate_->observer_list_,
+                      OnDisplayChanged());
+
+    // TODO(dnicoara) Shouldn't this be EVENT_HANDLED?
+    return base::EVENT_CONTINUE;
+  }
+
+  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
+    VLOG(1) << "Received RRScreenChangeNotify event";
+    delegate_->UpdateXRandRConfiguration(event);
+    return base::EVENT_CONTINUE;
+  }
+
+  // Bail out early for everything except RRNotify_OutputChange events
+  // about an output getting connected or disconnected.
+  if (event->type - xrandr_event_base_ != RRNotify)
+    return base::EVENT_CONTINUE;
+  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
+  if (notify_event->subtype != RRNotify_OutputChange)
+    return base::EVENT_CONTINUE;
+  const XRROutputChangeNotifyEvent* output_change_event =
+      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
+  const int action = output_change_event->connection;
+  if (action != RR_Connected && action != RR_Disconnected)
+    return base::EVENT_CONTINUE;
+
+  const bool connected = (action == RR_Connected);
+  VLOG(1) << "Received RRNotify_OutputChange event:"
+          << " output=" << output_change_event->output
+          << " crtc=" << output_change_event->crtc
+          << " mode=" << output_change_event->mode
+          << " action=" << (connected ? "connected" : "disconnected");
+
+  // TODO(dnicoara) We should cache all the modes so we can use the RRMode to
+  // populate all the fields here.
+  X11ModeInfo mode_info(0, 0, false, 0.0, output_change_event->mode);
+  X11DisplaySnapshot display;
+  display.set_crtc(output_change_event->crtc);
+  display.set_output(output_change_event->output);
+  display.set_current_mode(&mode_info);
+
+  if (connected) {
+    FOR_EACH_OBSERVER(gfx::NativeDisplayBridge::Observer,
+                      delegate_->observer_list_,
+                      OnDisplayAdded(display));
+  } else {
+    FOR_EACH_OBSERVER(gfx::NativeDisplayBridge::Observer,
+                      delegate_->observer_list_,
+                      OnDisplayRemoved(display));
+  }
+
+  return base::EVENT_HANDLED;
+}
+
+void NativeDisplayBridgeX11::X11MessagePumpObserver::DidProcessEvent(
+    const base::NativeEvent& event) {}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeDisplayBridgeX11::X11DisplaySnapshot
+
+NativeDisplayBridgeX11::X11DisplaySnapshot::X11DisplaySnapshot()
+    : output_(None), crtc_(None), index_(0) {}
+
+NativeDisplayBridgeX11::X11DisplaySnapshot::~X11DisplaySnapshot() {}
+
+NativeDisplayBridgeX11::X11DisplaySnapshot::X11DisplaySnapshot(
+    const X11DisplaySnapshot& other)
+    : DisplaySnapshot(other),
+      output_(other.output_),
+      crtc_(other.crtc_),
+      index_(other.index_) {}
+
+gfx::DisplaySnapshot* NativeDisplayBridgeX11::X11DisplaySnapshot::Clone()
+    const {
+  return new X11DisplaySnapshot(*this);
+}
+
+// Returns a string representation of X11DisplaySnapshot.
+std::string NativeDisplayBridgeX11::X11DisplaySnapshot::ToString() const {
+  const X11ModeInfo* x11_mode =
+      static_cast<const X11ModeInfo*>(get_current_mode());
+  return base::StringPrintf(
+      "[type=%d, output=%ld, crtc=%ld, mode=%ld, dim=%dx%d]",
+      get_type(),
+      output_,
+      crtc_,
+      x11_mode ? x11_mode->get_mode_id() : None,
+      get_physical_size().width(),
+      get_physical_size().height());
+}
+
+bool NativeDisplayBridgeX11::X11DisplaySnapshot::SameAs(
+    const DisplaySnapshot& display) const {
+  const X11DisplaySnapshot& x11_state =
+      static_cast<const X11DisplaySnapshot&>(display);
+  return output_ == x11_state.output_ && crtc_ == x11_state.crtc_;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeDisplayBridgeX11
+
+NativeDisplayBridgeX11::NativeDisplayBridgeX11()
+    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
+      window_(DefaultRootWindow(display_)),
+      screen_(NULL) {}
+
+NativeDisplayBridgeX11::~NativeDisplayBridgeX11() {}
+
+void NativeDisplayBridgeX11::Initialize() {
+  int error_base_ignored = 0;
+  int xrandr_event_base = 0;
+  XRRQueryExtension(display_, &xrandr_event_base, &error_base_ignored);
+
+  message_pump_observer_.reset(
+      new X11MessagePumpObserver(xrandr_event_base, this));
+}
+
+void NativeDisplayBridgeX11::UpdateXRandRConfiguration(
+    const base::NativeEvent& event) {
+  XRRUpdateConfiguration(event);
+}
+
+void NativeDisplayBridgeX11::Lock() {
+  CHECK(!screen_) << "Server already grabbed";
+  XGrabServer(display_);
+  screen_ = XRRGetScreenResources(display_, window_);
+  CHECK(screen_);
+}
+
+void NativeDisplayBridgeX11::Unlock() {
+  CHECK(screen_) << "Server not grabbed";
+  XRRFreeScreenResources(screen_);
+  screen_ = NULL;
+  XUngrabServer(display_);
+}
+
+void NativeDisplayBridgeX11::Flush() { XSync(display_, 0); }
+
+void NativeDisplayBridgeX11::SetBackgroundColor(uint32 color_argb) {
+  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
+  // same background color while configuring the display to minimize the
+  // duration of black screen at boot time. The background is filled with
+  // black later in ash::DisplayManager.  crbug.com/171050.
+  XSetWindowAttributes swa = {0};
+  XColor color;
+  Colormap colormap = DefaultColormap(display_, 0);
+  // XColor uses 16 bits per color.
+  color.red = (color_argb & 0x00FF0000) >> 8;
+  color.green = (color_argb & 0x0000FF00);
+  color.blue = (color_argb & 0x000000FF) << 8;
+  color.flags = DoRed | DoGreen | DoBlue;
+  XAllocColor(display_, colormap, &color);
+  swa.background_pixel = color.pixel;
+  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
+  XFreeColors(display_, colormap, &color.pixel, 1, 0);
+}
+
+void NativeDisplayBridgeX11::SetDPMS(DPMSState state) {
+  switch (state) {
+    case DPMS_ON:
+      CHECK(DPMSEnable(display_));
+      CHECK(DPMSForceLevel(display_, DPMSModeOn));
+      break;
+    default:
+      break;
+  }
+}
+
+void NativeDisplayBridgeX11::GetOutputs(
+    ScopedVector<gfx::DisplaySnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+
+  RRCrtc last_used_crtc = None;
+
+  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
+    RROutput output_id = screen_->outputs[i];
+    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
+    if (output_info->connection == RR_Connected) {
+      X11DisplaySnapshot* output =
+          InitX11DisplaySnapshot(output_id, output_info, &last_used_crtc, i);
+      const X11ModeInfo* mode =
+          static_cast<const X11ModeInfo*>(output->get_current_mode());
+      VLOG(2) << "Found display " << outputs.size() << ":"
+              << " output=" << output->get_output()
+              << " crtc=" << output->get_crtc()
+              << " current_mode=" << (mode ? mode->ToString() : "0");
+      outputs.push_back(output);
+    }
+    XRRFreeOutputInfo(output_info);
+  }
+
+  GetTouchscreens(&outputs);
+}
+
+void NativeDisplayBridgeX11::AddMode(const gfx::DisplaySnapshot& output,
+                                     const gfx::ModeInfo& mode) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "AddMode: output=" << output.ToString()
+          << " mode=" << mode.ToString();
+  XRRAddOutputMode(display_,
+                   static_cast<const X11DisplaySnapshot&>(output).get_output(),
+                   static_cast<const X11ModeInfo&>(mode).get_mode_id());
+}
+
+bool NativeDisplayBridgeX11::Configure(const gfx::DisplaySnapshot& output) {
+  const X11DisplaySnapshot& actual =
+      static_cast<const X11DisplaySnapshot&>(output);
+  const X11ModeInfo* mode =
+      static_cast<const X11ModeInfo*>(actual.get_current_mode());
+  return ConfigureCrtc(actual.get_crtc(),
+                       mode ? mode->get_mode_id() : None,
+                       actual.get_output(),
+                       actual.get_origin().x(),
+                       actual.get_origin().y());
+}
+
+bool NativeDisplayBridgeX11::ConfigureCrtc(RRCrtc crtc,
+                                           RRMode mode,
+                                           RROutput output,
+                                           int x,
+                                           int y) {
+  CHECK(screen_) << "Server not grabbed";
+  VLOG(1) << "ConfigureCrtc: crtc=" << crtc << " mode=" << mode
+          << " output=" << output << " x=" << x << " y=" << y;
+  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
+  // Status, which is typically 0 for failure and 1 for success. In
+  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
+  return XRRSetCrtcConfig(display_,
+                          screen_,
+                          crtc,
+                          CurrentTime,
+                          x,
+                          y,
+                          mode,
+                          RR_Rotate_0,
+                          (output && mode) ? &output : NULL,
+                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
+}
+
+void NativeDisplayBridgeX11::CreateFrameBuffer(
+    int width,
+    int height,
+    const ScopedVector<gfx::DisplaySnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  int current_width = DisplayWidth(display_, DefaultScreen(display_));
+  int current_height = DisplayHeight(display_, DefaultScreen(display_));
+  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
+          << " current=" << current_width << "x" << current_height;
+  if (width == current_width && height == current_height)
+    return;
+
+  DestroyUnusedCrtcs(outputs);
+  int mm_width = width * kPixelsToMmScale;
+  int mm_height = height * kPixelsToMmScale;
+  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
+}
+
+void NativeDisplayBridgeX11::ConfigureCTM(int touch_device_id,
+                                          const gfx::Matrix3F& ctm) {
+  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
+          << " scale=" << ctm.get(0, 0) << "x" << ctm.get(1, 1) << " offset=("
+          << ctm.get(0, 2) << ", " << ctm.get(1, 2) << ")";
+  int ndevices = 0;
+  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
+  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
+  Atom float_atom = XInternAtom(display_, "FLOAT", False);
+  if (ndevices == 1 && prop != None && float_atom != None) {
+    Atom type;
+    int format;
+    unsigned long num_items;
+    unsigned long bytes_after;
+    unsigned char* data = NULL;
+    // Verify that the property exists with correct format, type, etc.
+    int status = XIGetProperty(display_,
+                               info->deviceid,
+                               prop,
+                               0,
+                               0,
+                               False,
+                               AnyPropertyType,
+                               &type,
+                               &format,
+                               &num_items,
+                               &bytes_after,
+                               &data);
+    if (data)
+      XFree(data);
+    if (status == Success && type == float_atom && format == 32) {
+      float value[3][3];
+      for (int i = 0; i < 3; ++i)
+        for (int j = 0; j < 3; ++j)
+          value[i][j] = ctm.get(i, j);
+
+      XIChangeProperty(display_,
+                       info->deviceid,
+                       prop,
+                       type,
+                       format,
+                       PropModeReplace,
+                       reinterpret_cast<unsigned char*>(value),
+                       9);
+    }
+  }
+  XIFreeDeviceInfo(info);
+}
+
+gfx::ModeInfo* NativeDisplayBridgeX11::InitModeInfo(RRMode mode) {
+  CHECK(screen_) << "Server not grabbed";
+  // TODO: Determine if we need to organize modes in a way which provides
+  // better than O(n) lookup time.  In many call sites, for example, the
+  // "next" mode is typically what we are looking for so using this
+  // helper might be too expensive.
+  for (int i = 0; i < screen_->nmode; ++i) {
+    if (mode == screen_->modes[i].id) {
+      const XRRModeInfo& info = screen_->modes[i];
+
+      float refresh_rate = 0.0f;
+      if (info.hTotal && info.vTotal) {
+        refresh_rate =
+            static_cast<float>(info.dotClock) /
+            (static_cast<float>(info.hTotal) * static_cast<float>(info.vTotal));
+      }
+
+      gfx::ModeInfo* mode_info = new X11ModeInfo(info.width,
+                                                 info.height,
+                                                 info.modeFlags & RR_Interlace,
+                                                 refresh_rate,
+                                                 mode);
+
+      return mode_info;
+    }
+  }
+  return NULL;
+}
+
+NativeDisplayBridgeX11::X11DisplaySnapshot*
+NativeDisplayBridgeX11::InitX11DisplaySnapshot(RROutput id,
+                                               XRROutputInfo* info,
+                                               RRCrtc* last_used_crtc,
+                                               int index) {
+  X11DisplaySnapshot* output = new X11DisplaySnapshot();
+  output->set_output(id);
+  output->set_physical_size(gfx::Size(info->mm_width, info->mm_height));
+  output->set_index(index);
+  bool is_internal = IsInternalOutput(info);
+  int64 display_id = 0;
+  output->set_has_display_id(base::GetDisplayId(id, index, &display_id));
+
+  // Use the index as a valid display ID even if the internal
+  // display doesn't have valid EDID because the index
+  // will never change.
+  if (!output->has_display_id() && is_internal)
+    output->set_display_id(display_id);
+
+  RRMode current_mode = None;
+  if (info->crtc) {
+    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
+    current_mode = crtc_info->mode;
+    output->get_origin().SetPoint(crtc_info->x, crtc_info->y);
+    XRRFreeCrtcInfo(crtc_info);
+  }
+
+  // Assign a CRTC that isn't already in use.
+  for (int i = 0; i < info->ncrtc; ++i) {
+    if (info->crtcs[i] != *last_used_crtc) {
+      output->set_crtc(info->crtcs[i]);
+      *last_used_crtc = output->get_crtc();
+      break;
+    }
+  }
+
+  RRMode native_mode = GetOutputNativeMode(info);
+  output->set_is_aspect_preserving_scaling(IsOutputAspectPreservingScaling(id));
+  output->set_touch_device_id(None);
+
+  for (int i = 0; i < info->nmode; ++i) {
+    const RRMode mode = info->modes[i];
+    gfx::ModeInfo* mode_info = InitModeInfo(mode);
+    if (mode_info) {
+      output->get_mode_infos().push_back(mode_info);
+      if (mode == current_mode)
+        output->set_current_mode(mode_info);
+
+      if (mode == native_mode)
+        output->set_native_mode(mode_info);
+    } else {
+      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
+    }
+  }
+
+  std::string name(info->name);
+  if (is_internal) {
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL);
+  } else if (name.find(kOutputName_VGA) == 0) {
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_VGA);
+  } else if (name.find(kOutputName_HDMI) == 0) {
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI);
+  } else if (name.find(kOutputName_DVI) == 0) {
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_DVI);
+  } else if (name.find(kOutputName_DisplayPort) == 0) {
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_DISPLAYPORT);
+  } else {
+    LOG(ERROR) << "Unknown link type: " << name;
+    output->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_UNKNOWN);
+  }
+
+  return output;
+}
+
+bool NativeDisplayBridgeX11::GetHDCPState(
+    const gfx::DisplaySnapshot& output,
+    gfx::NativeDisplayBridge::HDCPState* state) {
+  unsigned char* values = NULL;
+  int actual_format = 0;
+  unsigned long nitems = 0;
+  unsigned long bytes_after = 0;
+  Atom actual_type = None;
+  int success = 0;
+  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
+  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
+
+  bool ok = true;
+  const X11DisplaySnapshot& actual =
+      static_cast<const X11DisplaySnapshot&>(output);
+  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
+  // output_util.cc)
+  success = XRRGetOutputProperty(display_,
+                                 actual.get_output(),
+                                 prop,
+                                 0,
+                                 100,
+                                 False,
+                                 False,
+                                 AnyPropertyType,
+                                 &actual_type,
+                                 &actual_format,
+                                 &nitems,
+                                 &bytes_after,
+                                 &values);
+  if (actual_type == None) {
+    LOG(ERROR) << "Property '" << kContentProtectionAtomName
+               << "' does not exist";
+    ok = false;
+  } else if (success == Success && actual_type == XA_ATOM &&
+             actual_format == 32 && nitems == 1) {
+    Atom value = reinterpret_cast<Atom*>(values)[0];
+    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
+      *state = gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED;
+    } else if (value ==
+               XInternAtom(display_, kProtectionDesiredAtomName, False)) {
+      *state = gfx::NativeDisplayBridge::HDCP_STATE_DESIRED;
+    } else if (value ==
+               XInternAtom(display_, kProtectionEnabledAtomName, False)) {
+      *state = gfx::NativeDisplayBridge::HDCP_STATE_ENABLED;
+    } else {
+      LOG(ERROR) << "Unknown " << kContentProtectionAtomName
+                 << " value: " << value;
+      ok = false;
+    }
+  } else {
+    LOG(ERROR) << "XRRGetOutputProperty failed";
+    ok = false;
+  }
+  if (values)
+    XFree(values);
+
+  VLOG(3) << "HDCP state: " << ok << "," << *state;
+  return ok;
+}
+
+bool NativeDisplayBridgeX11::SetHDCPState(
+    const gfx::DisplaySnapshot& output,
+    gfx::NativeDisplayBridge::HDCPState state) {
+  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
+  Atom value = None;
+  switch (state) {
+    case gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED:
+      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
+      break;
+    case gfx::NativeDisplayBridge::HDCP_STATE_DESIRED:
+      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
+      break;
+    default:
+      NOTREACHED() << "Invalid HDCP state: " << state;
+      return false;
+  }
+  base::X11ErrorTracker err_tracker;
+  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
+  const X11DisplaySnapshot& actual =
+      static_cast<const X11DisplaySnapshot&>(output);
+  XRRChangeOutputProperty(display_,
+                          actual.get_output(),
+                          name,
+                          XA_ATOM,
+                          32,
+                          PropModeReplace,
+                          data,
+                          1);
+  if (err_tracker.FoundNewError()) {
+    LOG(ERROR) << "XRRChangeOutputProperty failed";
+    return false;
+  } else {
+    return true;
+  }
+}
+
+void NativeDisplayBridgeX11::AddObserver(Observer* observer) {
+  observer_list_.AddObserver(observer);
+}
+
+void NativeDisplayBridgeX11::RemoveObserver(Observer* observer) {
+  observer_list_.RemoveObserver(observer);
+}
+
+void NativeDisplayBridgeX11::DestroyUnusedCrtcs(
+    const ScopedVector<gfx::DisplaySnapshot>& outputs) {
+  CHECK(screen_) << "Server not grabbed";
+  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
+  // At the same time, turning CRTCs off and back on uses up a lot of time.
+  // This function tries to be smart to avoid too many off/on cycles:
+  // - We disable all the CRTCs we won't need after the FB resize.
+  // - We set the new modes on CRTCs, if they fit in both the old and new
+  //   FBs, and park them at (0,0)
+  // - We disable the CRTCs we will need but don't fit in the old FB. Those
+  //   will be reenabled after the resize.
+  // We don't worry about the cached state of the outputs here since we are
+  // not interested in the state we are setting - we just try to get the CRTCs
+  // out of the way so we can rebuild the frame buffer.
+  for (int i = 0; i < screen_->ncrtc; ++i) {
+    // Default config is to disable the crtcs.
+    RRCrtc crtc = screen_->crtcs[i];
+    RRMode mode = None;
+    RROutput output = None;
+    const gfx::ModeInfo* mode_info = NULL;
+    for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+             outputs.begin();
+         it != outputs.end();
+         ++it) {
+      X11DisplaySnapshot* actual = static_cast<X11DisplaySnapshot*>(*it);
+      if (crtc == actual->get_crtc()) {
+        mode_info = (*it)->get_current_mode();
+        output = actual->get_output();
+        break;
+      }
+    }
+
+    if (mode_info) {
+      mode = static_cast<const X11ModeInfo*>(mode_info)->get_mode_id();
+      // In case our CRTC doesn't fit in our current framebuffer, disable it.
+      // It'll get reenabled after we resize the framebuffer.
+      int current_width = DisplayWidth(display_, DefaultScreen(display_));
+      int current_height = DisplayHeight(display_, DefaultScreen(display_));
+      if (mode_info->get_size().width() > current_width ||
+          mode_info->get_size().height() > current_height) {
+        mode = None;
+        output = None;
+        mode_info = NULL;
+      }
+    }
+
+    ConfigureCrtc(crtc, mode, output, 0, 0);
+  }
+}
+
+bool NativeDisplayBridgeX11::IsOutputAspectPreservingScaling(RROutput id) {
+  bool ret = false;
+
+  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
+  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
+  if (scaling_prop == None || full_aspect_atom == None)
+    return false;
+
+  int nprop = 0;
+  Atom* props = XRRListOutputProperties(display_, id, &nprop);
+  for (int j = 0; j < nprop && !ret; j++) {
+    Atom prop = props[j];
+    if (scaling_prop == prop) {
+      unsigned char* values = NULL;
+      int actual_format;
+      unsigned long nitems;
+      unsigned long bytes_after;
+      Atom actual_type;
+      int success;
+
+      success = XRRGetOutputProperty(display_,
+                                     id,
+                                     prop,
+                                     0,
+                                     100,
+                                     False,
+                                     False,
+                                     AnyPropertyType,
+                                     &actual_type,
+                                     &actual_format,
+                                     &nitems,
+                                     &bytes_after,
+                                     &values);
+      if (success == Success && actual_type == XA_ATOM && actual_format == 32 &&
+          nitems == 1) {
+        Atom value = reinterpret_cast<Atom*>(values)[0];
+        if (full_aspect_atom == value)
+          ret = true;
+      }
+      if (values)
+        XFree(values);
+    }
+  }
+  if (props)
+    XFree(props);
+
+  return ret;
+}
+
+void NativeDisplayBridgeX11::GetTouchscreens(
+    ScopedVector<gfx::DisplaySnapshot>* outputs) {
+  int ndevices = 0;
+  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
+  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
+  if (valuator_x == None || valuator_y == None)
+    return;
+
+  std::set<int> no_match_touchscreen;
+  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
+  for (int i = 0; i < ndevices; i++) {
+    if (!info[i].enabled || info[i].use != XIFloatingSlave)
+      continue;  // Assume all touchscreens are floating slaves
+
+    double width = -1.0;
+    double height = -1.0;
+    bool is_direct_touch = false;
+
+    for (int j = 0; j < info[i].num_classes; j++) {
+      XIAnyClassInfo* class_info = info[i].classes[j];
+
+      if (class_info->type == XIValuatorClass) {
+        XIValuatorClassInfo* valuator_info =
+            reinterpret_cast<XIValuatorClassInfo*>(class_info);
+
+        if (valuator_x == valuator_info->label) {
+          // Ignore X axis valuator with unexpected properties
+          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            width = valuator_info->max;
+          }
+        } else if (valuator_y == valuator_info->label) {
+          // Ignore Y axis valuator with unexpected properties
+          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
+              valuator_info->min == 0.0) {
+            height = valuator_info->max;
+          }
+        }
+      }
+#if defined(USE_XI2_MT)
+      if (class_info->type == XITouchClass) {
+        XITouchClassInfo* touch_info =
+            reinterpret_cast<XITouchClassInfo*>(class_info);
+        is_direct_touch = touch_info->mode == XIDirectTouch;
+      }
+#endif
+    }
+
+    // Touchscreens should have absolute X and Y axes,
+    // and be direct touch devices.
+    if (width > 0.0 && height > 0.0 && is_direct_touch) {
+      size_t k = 0;
+      for (; k < outputs->size(); k++) {
+        gfx::DisplaySnapshot* output = (*outputs)[k];
+        if (!output->get_native_mode() || output->get_touch_device_id() != None)
+          continue;
+
+        const gfx::ModeInfo* mode_info = output->get_native_mode();
+        if (!mode_info)
+          continue;
+
+        // Allow 1 pixel difference between screen and touchscreen
+        // resolutions.  Because in some cases for monitor resolution
+        // 1024x768 touchscreen's resolution would be 1024x768, but for
+        // some 1023x767.  It really depends on touchscreen's firmware
+        // configuration.
+        if (std::abs(mode_info->get_size().width() - width) <= 1.0 &&
+            std::abs(mode_info->get_size().height() - height) <= 1.0) {
+          output->set_touch_device_id(info[i].deviceid);
+
+          VLOG(2) << "Found touchscreen for output #" << k << " id "
+                  << output->get_touch_device_id() << " width " << width
+                  << " height " << height;
+          break;
+        }
+      }
+
+      if (k == outputs->size()) {
+        no_match_touchscreen.insert(info[i].deviceid);
+        VLOG(2) << "No matching output for touchscreen"
+                << " id " << info[i].deviceid << " width " << width
+                << " height " << height;
+      }
+    }
+  }
+
+  // Sometimes we can't find a matching screen for the touchscreen, e.g.
+  // due to the touchscreen's reporting range having no correlation with the
+  // screen's resolution. In this case, we arbitrarily assign unmatched
+  // touchscreens to unmatched screens.
+  for (std::set<int>::iterator it = no_match_touchscreen.begin();
+       it != no_match_touchscreen.end();
+       it++) {
+    for (size_t i = 0; i < outputs->size(); i++) {
+      if ((*outputs)[i]->get_type() !=
+              gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL &&
+          (*outputs)[i]->get_native_mode() &&
+          (*outputs)[i]->get_touch_device_id() == None) {
+        (*outputs)[i]->set_touch_device_id(*it);
+        VLOG(2) << "Arbitrarily matching touchscreen "
+                << (*outputs)[i]->get_touch_device_id() << " to output #" << i;
+        break;
+      }
+    }
+  }
+
+  XIFreeDeviceInfo(info);
+}
+
+}  // namespace chromeos
diff --git a/chromeos/display/native_display_bridge_x11.h b/chromeos/display/native_display_bridge_x11.h
new file mode 100644
index 0000000..3cfa691
--- /dev/null
+++ b/chromeos/display/native_display_bridge_x11.h
@@ -0,0 +1,158 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROMEOS_DISPLAY_NATIVE_DISPLAY_BRIDGE_X11_H_
+#define CHROMEOS_DISPLAY_NATIVE_DISPLAY_BRIDGE_X11_H_
+
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/event_types.h"
+#include "base/message_loop/message_loop.h"
+#include "base/observer_list.h"
+#include "ui/gfx/display_snapshot.h"
+#include "ui/gfx/native_display_bridge.h"
+
+// Forward declarations for Xlib and Xrandr.
+// This is so unused X definitions don't pollute the namespace.
+typedef unsigned long XID;
+typedef XID RROutput;
+typedef XID RRCrtc;
+typedef XID RRMode;
+
+typedef XID Window;
+
+struct _XDisplay;
+typedef struct _XDisplay Display;
+struct _XRROutputInfo;
+typedef _XRROutputInfo XRROutputInfo;
+struct _XRRScreenResources;
+typedef _XRRScreenResources XRRScreenResources;
+
+namespace gfx {
+class ModeInfo;
+}
+
+namespace chromeos {
+
+class NativeDisplayBridgeX11 : public gfx::NativeDisplayBridge {
+ public:
+  NativeDisplayBridgeX11();
+  virtual ~NativeDisplayBridgeX11();
+
+  virtual void Initialize() OVERRIDE;
+  virtual void Lock() OVERRIDE;
+  virtual void Unlock() OVERRIDE;
+  virtual void Flush() OVERRIDE;
+  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
+  virtual void SetDPMS(DPMSState state) OVERRIDE;
+  virtual void GetOutputs(ScopedVector<gfx::DisplaySnapshot>& outputs) OVERRIDE;
+  virtual void AddMode(const gfx::DisplaySnapshot& output,
+                       const gfx::ModeInfo& mode) OVERRIDE;
+  virtual bool Configure(const gfx::DisplaySnapshot& output) OVERRIDE;
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const ScopedVector<gfx::DisplaySnapshot>& outputs) OVERRIDE;
+  virtual void ConfigureCTM(int touch_device_id,
+                            const gfx::Matrix3F& ctm) OVERRIDE;
+  virtual bool GetHDCPState(const gfx::DisplaySnapshot& output,
+                            gfx::NativeDisplayBridge::HDCPState* state)
+      OVERRIDE;
+  virtual bool SetHDCPState(const gfx::DisplaySnapshot& output,
+                            gfx::NativeDisplayBridge::HDCPState state) OVERRIDE;
+
+  virtual void AddObserver(gfx::NativeDisplayBridge::Observer* observer)
+      OVERRIDE;
+  virtual void RemoveObserver(gfx::NativeDisplayBridge::Observer* observer)
+      OVERRIDE;
+
+  // Tells XRandR to update its configuration in response to |event|, an
+  // RRScreenChangeNotify event.
+  void UpdateXRandRConfiguration(const base::NativeEvent& event);
+
+  // Information about an output's current state.
+  class X11DisplaySnapshot : public gfx::DisplaySnapshot {
+   public:
+    X11DisplaySnapshot();
+    virtual ~X11DisplaySnapshot();
+
+    virtual gfx::DisplaySnapshot* Clone() const OVERRIDE;
+    virtual std::string ToString() const OVERRIDE;
+
+    virtual bool SameAs(const DisplaySnapshot& display) const OVERRIDE;
+
+    RROutput get_output() const { return output_; }
+    void set_output(RROutput output) { output_ = output; }
+
+    RRCrtc get_crtc() const { return crtc_; }
+    void set_crtc(RRCrtc crtc) { crtc_ = crtc; }
+
+    int get_index() const { return index_; }
+    void set_index(int index) { index_ = index; }
+
+   private:
+    X11DisplaySnapshot(const X11DisplaySnapshot& other);
+
+    RROutput output_;
+
+    // CRTC that should be used for this output. Not necessarily the CRTC
+    // that XRandR reports is currently being used.
+    RRCrtc crtc_;
+
+    // This output's index in the array returned by XRandR. Stable even as
+    // outputs are connected or disconnected.
+    int index_;
+  };
+
+ private:
+  class X11MessagePumpObserver;
+
+  // Create a gfx::ModeInfo to contain details corresponding to |mode|. Returns
+  // NULL on failure.
+  gfx::ModeInfo* InitModeInfo(RRMode mode);
+
+  // Helper method for GetOutputs() that returns an X11DisplaySnapshot struct
+  // based
+  // on the passed-in information. Further initialization is required (e.g.
+  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
+  X11DisplaySnapshot* InitX11DisplaySnapshot(RROutput id,
+                                             XRROutputInfo* info,
+                                             RRCrtc* last_used_crtc,
+                                             int index);
+
+  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
+  // framebuffer resize. This is faster than turning them off, resizing,
+  // then turning them back on.
+  void DestroyUnusedCrtcs(const ScopedVector<gfx::DisplaySnapshot>& outputs);
+
+  bool ConfigureCrtc(RRCrtc crtc, RRMode mode, RROutput output, int x, int y);
+
+  // Returns whether |id| is configured to preserve aspect when scaling.
+  bool IsOutputAspectPreservingScaling(RROutput id);
+
+  // Searches for touchscreens among input devices,
+  // and tries to match them up to screens in |outputs|.
+  // |outputs| is an array of detected screens.
+  // If a touchscreen with same resolution as an output's native mode
+  // is detected, its id will be stored in this output.
+  void GetTouchscreens(ScopedVector<gfx::DisplaySnapshot>* outputs);
+
+  Display* display_;
+  Window window_;
+
+  // Initialized when the server is grabbed and freed when it's ungrabbed.
+  XRRScreenResources* screen_;
+
+  scoped_ptr<X11MessagePumpObserver> message_pump_observer_;
+
+  ObserverList<gfx::NativeDisplayBridge::Observer> observer_list_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeDisplayBridgeX11);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROMEOS_DISPLAY_NATIVE_DISPLAY_BRIDGE_X11_H_
diff --git a/chromeos/display/output_configurator.cc b/chromeos/display/output_configurator.cc
index 852b794..0c27367 100644
--- a/chromeos/display/output_configurator.cc
+++ b/chromeos/display/output_configurator.cc
@@ -14,8 +14,10 @@
 #include "base/strings/stringprintf.h"
 #include "base/sys_info.h"
 #include "base/time/time.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/power_manager_client.h"
+#include "chromeos/display/native_display_bridge_x11.h"
 #include "chromeos/display/output_util.h"
-#include "chromeos/display/real_output_configurator_delegate.h"
 
 namespace chromeos {
 
@@ -42,59 +44,36 @@ std::string DisplayPowerStateToString(DisplayPowerState state) {
 }
 
 // Returns a string describing |state|.
-std::string OutputStateToString(OutputState state) {
+std::string OutputStateToString(gfx::NativeDisplayBridge::OutputState state) {
   switch (state) {
-    case STATE_INVALID:
+    case gfx::NativeDisplayBridge::STATE_INVALID:
       return "INVALID";
-    case STATE_HEADLESS:
+    case gfx::NativeDisplayBridge::STATE_HEADLESS:
       return "HEADLESS";
-    case STATE_SINGLE:
+    case gfx::NativeDisplayBridge::STATE_SINGLE:
       return "SINGLE";
-    case STATE_DUAL_MIRROR:
+    case gfx::NativeDisplayBridge::STATE_DUAL_MIRROR:
       return "DUAL_MIRROR";
-    case STATE_DUAL_EXTENDED:
+    case gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED:
       return "DUAL_EXTENDED";
   }
   NOTREACHED() << "Unknown state " << state;
   return "INVALID";
 }
 
-// Returns a string representation of OutputSnapshot.
-std::string OutputSnapshotToString(
-    const OutputConfigurator::OutputSnapshot* output) {
-  return base::StringPrintf(
-      "[type=%d, output=%ld, crtc=%ld, mode=%ld, dim=%dx%d]",
-      output->type,
-      output->output,
-      output->crtc,
-      output->current_mode,
-      static_cast<int>(output->width_mm),
-      static_cast<int>(output->height_mm));
-}
-
-// Returns a string representation of ModeInfo.
-std::string ModeInfoToString(const OutputConfigurator::ModeInfo* mode) {
-  return base::StringPrintf("[%dx%d %srate=%f]",
-                            mode->width,
-                            mode->height,
-                            mode->interlaced ? "interlaced " : "",
-                            mode->refresh_rate);
-
-}
-
 // Returns the number of outputs in |outputs| that should be turned on, per
 // |state|.  If |output_power| is non-NULL, it is updated to contain the
 // on/off state of each corresponding entry in |outputs|.
-int GetOutputPower(
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs,
-    DisplayPowerState state,
-    std::vector<bool>* output_power) {
+int GetOutputPower(const ScopedVector<gfx::DisplaySnapshot>& outputs,
+                   DisplayPowerState state,
+                   std::vector<bool>* output_power) {
   int num_on_outputs = 0;
   if (output_power)
     output_power->resize(outputs.size());
 
   for (size_t i = 0; i < outputs.size(); ++i) {
-    bool internal = outputs[i].type == OUTPUT_TYPE_INTERNAL;
+    bool internal = outputs[i]->get_type() ==
+                    gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL;
     bool on = state == DISPLAY_POWER_ALL_ON ||
         (state == DISPLAY_POWER_INTERNAL_OFF_EXTERNAL_ON && !internal) ||
         (state == DISPLAY_POWER_INTERNAL_ON_EXTERNAL_OFF && internal);
@@ -106,69 +85,34 @@ int GetOutputPower(
   return num_on_outputs;
 }
 
-}  // namespace
+bool HasSameCurrentMode(const gfx::ModeInfo* lhs, const gfx::ModeInfo* rhs) {
+  if (!lhs && !rhs)
+    return true;
 
-OutputConfigurator::ModeInfo::ModeInfo()
-    : width(0),
-      height(0),
-      interlaced(false),
-      refresh_rate(0.0) {}
-
-OutputConfigurator::ModeInfo::ModeInfo(int width,
-                                       int height,
-                                       bool interlaced,
-                                       float refresh_rate)
-    : width(width),
-      height(height),
-      interlaced(interlaced),
-      refresh_rate(refresh_rate) {}
-
-OutputConfigurator::CoordinateTransformation::CoordinateTransformation()
-    : x_scale(1.0),
-      x_offset(0.0),
-      y_scale(1.0),
-      y_offset(0.0) {}
-
-OutputConfigurator::OutputSnapshot::OutputSnapshot()
-    : output(None),
-      crtc(None),
-      current_mode(None),
-      native_mode(None),
-      mirror_mode(None),
-      selected_mode(None),
-      x(0),
-      y(0),
-      width_mm(0),
-      height_mm(0),
-      is_aspect_preserving_scaling(false),
-      type(OUTPUT_TYPE_UNKNOWN),
-      touch_device_id(0),
-      display_id(0),
-      has_display_id(false),
-      index(0) {}
-
-OutputConfigurator::OutputSnapshot::~OutputSnapshot() {}
-
-void OutputConfigurator::TestApi::SendScreenChangeEvent() {
-  XRRScreenChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRScreenChangeNotify;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
-}
+  if ((lhs && !rhs) || (!lhs && rhs))
+    return false;
 
-void OutputConfigurator::TestApi::SendOutputChangeEvent(RROutput output,
-                                                        RRCrtc crtc,
-                                                        RRMode mode,
-                                                        bool connected) {
-  XRROutputChangeNotifyEvent event = {0};
-  event.type = xrandr_event_base_ + RRNotify;
-  event.subtype = RRNotify_OutputChange;
-  event.output = output;
-  event.crtc = crtc;
-  event.mode = mode;
-  event.connection = connected ? RR_Connected : RR_Disconnected;
-  configurator_->Dispatch(reinterpret_cast<const base::NativeEvent>(&event));
+  return lhs->Equals(*rhs);
 }
 
+class DBusProjectionDelegate
+    : public chromeos::OutputConfigurator::ProjectionDelegate {
+ public:
+  DBusProjectionDelegate() {}
+  virtual ~DBusProjectionDelegate() {}
+
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE {
+    chromeos::DBusThreadManager::Get()
+        ->GetPowerManagerClient()
+        ->SetIsProjecting(projecting);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DBusProjectionDelegate);
+};
+
+}  // namespace
+
 bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
   if (configurator_->configure_timer_.get() &&
       configurator_->configure_timer_->IsRunning()) {
@@ -180,77 +124,38 @@ bool OutputConfigurator::TestApi::TriggerConfigureTimeout() {
   }
 }
 
-// static
-const OutputConfigurator::ModeInfo* OutputConfigurator::GetModeInfo(
-    const OutputSnapshot& output,
-    RRMode mode) {
-  if (mode == None)
-    return NULL;
-
-  ModeInfoMap::const_iterator it = output.mode_infos.find(mode);
-  if (it == output.mode_infos.end()) {
-    LOG(WARNING) << "Unable to find info about mode " << mode
-                 << " for output " << output.output;
-    return NULL;
-  }
-  return &it->second;
-}
-
-// static
-RRMode OutputConfigurator::FindOutputModeMatchingSize(
-    const OutputSnapshot& output,
-    int width,
-    int height) {
-  RRMode found = None;
-  float best_rate = 0;
-  bool non_interlaced_found = false;
-  for (ModeInfoMap::const_iterator it = output.mode_infos.begin();
-       it != output.mode_infos.end(); ++it) {
-    RRMode mode = it->first;
-    const ModeInfo& info = it->second;
-
-    if (info.width == width && info.height == height) {
-      if (info.interlaced) {
-        if (non_interlaced_found)
-          continue;
-      } else {
-        // Reset the best rate if the non interlaced is
-        // found the first time.
-        if (!non_interlaced_found)
-          best_rate = info.refresh_rate;
-        non_interlaced_found = true;
-      }
-      if (info.refresh_rate < best_rate)
-        continue;
-
-      found = mode;
-      best_rate = info.refresh_rate;
-    }
-  }
-  return found;
-}
-
 OutputConfigurator::OutputConfigurator()
     : state_controller_(NULL),
       mirroring_controller_(NULL),
       is_panel_fitting_enabled_(false),
       configure_display_(base::SysInfo::IsRunningOnChromeOS()),
-      xrandr_event_base_(0),
-      output_state_(STATE_INVALID),
+      output_state_(gfx::NativeDisplayBridge::STATE_INVALID),
       power_state_(DISPLAY_POWER_ALL_ON),
       next_output_protection_client_id_(1),
-      casting_session_count_(0) {
+      casting_session_count_(0) {}
+
+OutputConfigurator::~OutputConfigurator() {
+  if (delegate_)
+    delegate_->RemoveObserver(this);
 }
 
-OutputConfigurator::~OutputConfigurator() {}
+void OutputConfigurator::SetDelegateForTesting(
+    scoped_ptr<gfx::NativeDisplayBridge> delegate) {
+  if (delegate_)
+    delegate_->RemoveObserver(this);
 
-void OutputConfigurator::SetDelegateForTesting(scoped_ptr<Delegate> delegate) {
   delegate_ = delegate.Pass();
+  delegate_->AddObserver(this);
   configure_display_ = true;
 }
 
+void OutputConfigurator::SetProjectionDelegateForTesting(
+    scoped_ptr<ProjectionDelegate> delegate) {
+  projection_delegate_ = delegate.Pass();
+}
+
 void OutputConfigurator::SetInitialDisplayPower(DisplayPowerState power_state) {
-  DCHECK_EQ(output_state_, STATE_INVALID);
+  DCHECK_EQ(output_state_, gfx::NativeDisplayBridge::STATE_INVALID);
   power_state_ = power_state;
 }
 
@@ -259,61 +164,70 @@ void OutputConfigurator::Init(bool is_panel_fitting_enabled) {
   if (!configure_display_)
     return;
 
-  if (!delegate_)
-    delegate_.reset(new RealOutputConfiguratorDelegate());
+  if (!delegate_) {
+    delegate_.reset(new NativeDisplayBridgeX11());
+    delegate_->AddObserver(this);
+  }
+
+  if (!projection_delegate_)
+    projection_delegate_.reset(new DBusProjectionDelegate());
 }
 
 void OutputConfigurator::Start(uint32 background_color_argb) {
   if (!configure_display_)
     return;
 
-  delegate_->GrabServer();
-  delegate_->InitXRandRExtension(&xrandr_event_base_);
+  delegate_->Lock();
+  delegate_->Initialize();
 
   UpdateCachedOutputs();
   if (cached_outputs_.size() > 1 && background_color_argb)
     delegate_->SetBackgroundColor(background_color_argb);
-  const OutputState new_state = ChooseOutputState(power_state_);
+  const gfx::NativeDisplayBridge::OutputState new_state =
+      ChooseOutputState(power_state_);
   const bool success = EnterStateOrFallBackToSoftwareMirroring(
       new_state, power_state_);
 
   // Force the DPMS on chrome startup as the driver doesn't always detect
   // that all displays are on when signing out.
-  delegate_->ForceDPMSOn();
-  delegate_->UngrabServer();
+  delegate_->SetDPMS(gfx::NativeDisplayBridge::DPMS_ON);
+  delegate_->Unlock();
   SendProjectingStateToPowerManager();
   NotifyObservers(success, new_state);
 }
 
 bool OutputConfigurator::ApplyProtections(const DisplayProtections& requests) {
-  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs_.begin();
-       it != cached_outputs_.end(); ++it) {
-    RROutput this_id = it->output;
+  for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+           cached_outputs_.begin();
+       it != cached_outputs_.end();
+       ++it) {
     uint32_t all_desired = 0;
-    DisplayProtections::const_iterator request_it = requests.find(
-        it->display_id);
+    DisplayProtections::const_iterator request_it =
+        requests.find((*it)->get_display_id());
     if (request_it != requests.end())
       all_desired = request_it->second;
-    switch (it->type) {
-      case OUTPUT_TYPE_UNKNOWN:
+    switch ((*it)->get_type()) {
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_UNKNOWN:
         return false;
       // DisplayPort, DVI, and HDMI all support HDCP.
-      case OUTPUT_TYPE_DISPLAYPORT:
-      case OUTPUT_TYPE_DVI:
-      case OUTPUT_TYPE_HDMI: {
-        HDCPState new_desired_state =
-            (all_desired & OUTPUT_PROTECTION_METHOD_HDCP) ?
-            HDCP_STATE_DESIRED : HDCP_STATE_UNDESIRED;
-        if (!delegate_->SetHDCPState(this_id, new_desired_state))
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_DISPLAYPORT:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_DVI:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI: {
+        gfx::NativeDisplayBridge::HDCPState new_desired_state =
+            (all_desired &
+             gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP)
+                ? gfx::NativeDisplayBridge::HDCP_STATE_DESIRED
+                : gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED;
+        if (!delegate_->SetHDCPState(**it, new_desired_state))
           return false;
         break;
       }
-      case OUTPUT_TYPE_INTERNAL:
-      case OUTPUT_TYPE_VGA:
-      case OUTPUT_TYPE_NETWORK:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_VGA:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_NETWORK:
         // No protections for these types. Do nothing.
         break;
-      case OUTPUT_TYPE_NONE:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_NONE:
         NOTREACHED();
         break;
     }
@@ -326,7 +240,8 @@ void OutputConfigurator::SendProjectingStateToPowerManager() {
   bool has_internal_output = false;
   int connected_output_count = cached_outputs_.size() + casting_session_count_;
   for (size_t i = 0; i < cached_outputs_.size(); ++i) {
-    if (cached_outputs_[i].type == OUTPUT_TYPE_INTERNAL) {
+    if (cached_outputs_[i]->get_type() ==
+        gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL) {
       has_internal_output = true;
       break;
     }
@@ -335,7 +250,7 @@ void OutputConfigurator::SendProjectingStateToPowerManager() {
   // "Projecting" is defined as having more than 1 output connected while at
   // least one of them is an internal output.
   bool is_projecting = has_internal_output && (connected_output_count > 1);
-  delegate_->SendProjectingStateToPowerManager(is_projecting);
+  projection_delegate_->SendProjectingStateToPowerManager(is_projecting);
 }
 
 OutputConfigurator::OutputProtectionClientId
@@ -375,34 +290,36 @@ bool OutputConfigurator::QueryOutputProtectionStatus(
   uint32_t enabled = 0;
   uint32_t unfulfilled = 0;
   *link_mask = 0;
-  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs_.begin();
-       it != cached_outputs_.end(); ++it) {
-    RROutput this_id = it->output;
-    if (it->display_id != display_id)
+  for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+           cached_outputs_.begin();
+       it != cached_outputs_.end();
+       ++it) {
+    if ((*it)->get_display_id() != display_id)
       continue;
-    *link_mask |= it->type;
-    switch (it->type) {
-      case OUTPUT_TYPE_UNKNOWN:
+    *link_mask |= (*it)->get_type();
+    switch ((*it)->get_type()) {
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_UNKNOWN:
         return false;
       // DisplayPort, DVI, and HDMI all support HDCP.
-      case OUTPUT_TYPE_DISPLAYPORT:
-      case OUTPUT_TYPE_DVI:
-      case OUTPUT_TYPE_HDMI: {
-        HDCPState state;
-        if (!delegate_->GetHDCPState(this_id, &state))
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_DISPLAYPORT:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_DVI:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI: {
+        gfx::NativeDisplayBridge::HDCPState state;
+        if (!delegate_->GetHDCPState(**it, &state))
           return false;
-        if (state == HDCP_STATE_ENABLED)
-          enabled |= OUTPUT_PROTECTION_METHOD_HDCP;
+        if (state == gfx::NativeDisplayBridge::HDCP_STATE_ENABLED)
+          enabled |= gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP;
         else
-          unfulfilled |= OUTPUT_PROTECTION_METHOD_HDCP;
+          unfulfilled |=
+              gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP;
         break;
       }
-      case OUTPUT_TYPE_INTERNAL:
-      case OUTPUT_TYPE_VGA:
-      case OUTPUT_TYPE_NETWORK:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_VGA:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_NETWORK:
         // No protections for these types. Do nothing.
         break;
-      case OUTPUT_TYPE_NONE:
+      case gfx::NativeDisplayBridge::OUTPUT_TYPE_NONE:
         NOTREACHED();
         break;
     }
@@ -445,7 +362,8 @@ bool OutputConfigurator::EnableOutputProtection(
   if (!ApplyProtections(protections))
     return false;
 
-  if (desired_method_mask == OUTPUT_PROTECTION_METHOD_NONE) {
+  if (desired_method_mask ==
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE) {
     if (client_protection_requests_.find(client_id) !=
         client_protection_requests_.end()) {
       client_protection_requests_[client_id].erase(display_id);
@@ -476,10 +394,11 @@ bool OutputConfigurator::SetDisplayPower(DisplayPowerState power_state,
   if (power_state == power_state_ && !(flags & kSetDisplayPowerForceProbe))
     return true;
 
-  delegate_->GrabServer();
+  delegate_->Lock();
   UpdateCachedOutputs();
 
-  const OutputState new_state = ChooseOutputState(power_state);
+  const gfx::NativeDisplayBridge::OutputState new_state =
+      ChooseOutputState(power_state);
   bool attempted_change = false;
   bool success = false;
 
@@ -487,7 +406,8 @@ bool OutputConfigurator::SetDisplayPower(DisplayPowerState power_state,
       flags & kSetDisplayPowerOnlyIfSingleInternalDisplay;
   bool single_internal_display =
       cached_outputs_.size() == 1 &&
-      cached_outputs_[0].type == OUTPUT_TYPE_INTERNAL;
+      cached_outputs_[0]->get_type() ==
+          gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL;
   if (single_internal_display || !only_if_single_internal_display) {
     success = EnterStateOrFallBackToSoftwareMirroring(new_state, power_state);
     attempted_change = true;
@@ -495,16 +415,17 @@ bool OutputConfigurator::SetDisplayPower(DisplayPowerState power_state,
     // Force the DPMS on since the driver doesn't always detect that it
     // should turn on. This is needed when coming back from idle suspend.
     if (success && power_state != DISPLAY_POWER_ALL_OFF)
-      delegate_->ForceDPMSOn();
+      delegate_->SetDPMS(gfx::NativeDisplayBridge::DPMS_ON);
   }
 
-  delegate_->UngrabServer();
+  delegate_->Unlock();
   if (attempted_change)
     NotifyObservers(success, new_state);
   return true;
 }
 
-bool OutputConfigurator::SetDisplayMode(OutputState new_state) {
+bool OutputConfigurator::SetDisplayMode(
+    gfx::NativeDisplayBridge::OutputState new_state) {
   if (!configure_display_)
     return false;
 
@@ -512,96 +433,23 @@ bool OutputConfigurator::SetDisplayMode(OutputState new_state) {
   if (output_state_ == new_state) {
     // Cancel software mirroring if the state is moving from
     // STATE_DUAL_EXTENDED to STATE_DUAL_EXTENDED.
-    if (mirroring_controller_ && new_state == STATE_DUAL_EXTENDED)
+    if (mirroring_controller_ &&
+        new_state == gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED)
       mirroring_controller_->SetSoftwareMirroring(false);
     NotifyObservers(true, new_state);
     return true;
   }
 
-  delegate_->GrabServer();
+  delegate_->Lock();
   UpdateCachedOutputs();
   const bool success = EnterStateOrFallBackToSoftwareMirroring(
       new_state, power_state_);
-  delegate_->UngrabServer();
+  delegate_->Unlock();
 
   NotifyObservers(success, new_state);
   return success;
 }
 
-bool OutputConfigurator::Dispatch(const base::NativeEvent& event) {
-  if (!configure_display_)
-    return true;
-
-  if (event->type - xrandr_event_base_ == RRScreenChangeNotify) {
-    VLOG(1) << "Received RRScreenChangeNotify event";
-    delegate_->UpdateXRandRConfiguration(event);
-    return true;
-  }
-
-  // Bail out early for everything except RRNotify_OutputChange events
-  // about an output getting connected or disconnected.
-  if (event->type - xrandr_event_base_ != RRNotify)
-    return true;
-  const XRRNotifyEvent* notify_event = reinterpret_cast<XRRNotifyEvent*>(event);
-  if (notify_event->subtype != RRNotify_OutputChange)
-    return true;
-  const XRROutputChangeNotifyEvent* output_change_event =
-      reinterpret_cast<XRROutputChangeNotifyEvent*>(event);
-  const int action = output_change_event->connection;
-  if (action != RR_Connected && action != RR_Disconnected)
-    return true;
-
-  const bool connected = (action == RR_Connected);
-  VLOG(1) << "Received RRNotify_OutputChange event:"
-          << " output=" << output_change_event->output
-          << " crtc=" << output_change_event->crtc
-          << " mode=" << output_change_event->mode
-          << " action=" << (connected ? "connected" : "disconnected");
-
-  bool found_changed_output = false;
-  for (std::vector<OutputSnapshot>::const_iterator it = cached_outputs_.begin();
-       it != cached_outputs_.end(); ++it) {
-    if (it->output == output_change_event->output) {
-      if (connected && it->crtc == output_change_event->crtc &&
-          it->current_mode == output_change_event->mode) {
-        VLOG(1) << "Ignoring event describing already-cached state";
-        return true;
-      }
-      found_changed_output = true;
-      break;
-    }
-  }
-
-  if (!connected && !found_changed_output) {
-    VLOG(1) << "Ignoring event describing already-disconnected output";
-    return true;
-  }
-
-  // Connecting/disconnecting a display may generate multiple events. Defer
-  // configuring outputs to avoid grabbing X and configuring displays
-  // multiple times.
-  ScheduleConfigureOutputs();
-  return true;
-}
-
-base::EventStatus OutputConfigurator::WillProcessEvent(
-    const base::NativeEvent& event) {
-  // XI_HierarchyChanged events are special. There is no window associated with
-  // these events. So process them directly from here.
-  if (configure_display_ && event->type == GenericEvent &&
-      event->xgeneric.evtype == XI_HierarchyChanged) {
-    VLOG(1) << "Received XI_HierarchyChanged event";
-    // Defer configuring outputs to not stall event processing.
-    // This also takes care of same event being received twice.
-    ScheduleConfigureOutputs();
-  }
-
-  return base::EVENT_CONTINUE;
-}
-
-void OutputConfigurator::DidProcessEvent(const base::NativeEvent& event) {
-}
-
 void OutputConfigurator::OnCastingSessionStartedOrStopped(bool started) {
   if (started) {
     ++casting_session_count_;
@@ -635,7 +483,7 @@ void OutputConfigurator::SuspendDisplays() {
     // We need to make sure that the monitor configuration we just did actually
     // completes before we return, because otherwise the X message could be
     // racing with the HandleSuspendReadiness message.
-    delegate_->SyncWithServer();
+    delegate_->Flush();
   }
 }
 
@@ -659,29 +507,31 @@ void OutputConfigurator::ScheduleConfigureOutputs() {
 }
 
 void OutputConfigurator::UpdateCachedOutputs() {
-  cached_outputs_ = delegate_->GetOutputs();
+  cached_outputs_.clear();
+  delegate_->GetOutputs(cached_outputs_);
 
   // Set |selected_mode| fields.
   for (size_t i = 0; i < cached_outputs_.size(); ++i) {
-    OutputSnapshot* output = &cached_outputs_[i];
-    if (output->has_display_id) {
+    gfx::DisplaySnapshot* output = cached_outputs_[i];
+    if (output->has_display_id()) {
       int width = 0, height = 0;
-      if (state_controller_ &&
-          state_controller_->GetResolutionForDisplayId(
-              output->display_id, &width, &height)) {
-        output->selected_mode =
-            FindOutputModeMatchingSize(*output, width, height);
+      if (state_controller_ && state_controller_->GetResolutionForDisplayId(
+                                   output->get_display_id(), &width, &height)) {
+        output->set_selected_mode(
+            output->FindOutputModeMatchingSize(width, height));
       }
     }
     // Fall back to native mode.
-    if (output->selected_mode == None)
-      output->selected_mode = output->native_mode;
+    if (!output->get_selected_mode())
+      output->set_selected_mode(output->get_native_mode());
   }
 
   // Set |mirror_mode| fields.
   if (cached_outputs_.size() == 2) {
-    bool one_is_internal = cached_outputs_[0].type == OUTPUT_TYPE_INTERNAL;
-    bool two_is_internal = cached_outputs_[1].type == OUTPUT_TYPE_INTERNAL;
+    bool one_is_internal = cached_outputs_[0]->get_type() ==
+                           gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL;
+    bool two_is_internal = cached_outputs_[1]->get_type() ==
+                           gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL;
     int internal_outputs = (one_is_internal ? 1 : 0) +
         (two_is_internal ? 1 : 0);
     DCHECK_LT(internal_outputs, 2);
@@ -696,64 +546,70 @@ void OutputConfigurator::UpdateCachedOutputs() {
 
       if (internal_outputs == 1) {
         if (one_is_internal) {
-          can_mirror = FindMirrorMode(&cached_outputs_[0], &cached_outputs_[1],
-              is_panel_fitting_enabled_, preserve_aspect);
+          can_mirror = FindMirrorMode(cached_outputs_[0],
+                                      cached_outputs_[1],
+                                      is_panel_fitting_enabled_,
+                                      preserve_aspect);
         } else {
           DCHECK(two_is_internal);
-          can_mirror = FindMirrorMode(&cached_outputs_[1], &cached_outputs_[0],
-              is_panel_fitting_enabled_, preserve_aspect);
+          can_mirror = FindMirrorMode(cached_outputs_[1],
+                                      cached_outputs_[0],
+                                      is_panel_fitting_enabled_,
+                                      preserve_aspect);
         }
       } else {  // if (internal_outputs == 0)
         // No panel fitting for external outputs, so fall back to exact match.
-        can_mirror = FindMirrorMode(&cached_outputs_[0], &cached_outputs_[1],
-                                    false, preserve_aspect);
+        can_mirror = FindMirrorMode(
+            cached_outputs_[0], cached_outputs_[1], false, preserve_aspect);
         if (!can_mirror && preserve_aspect) {
           // FindMirrorMode() will try to preserve aspect ratio of what it
           // thinks is external display, so if it didn't succeed with one, maybe
           // it will succeed with the other.  This way we will have the correct
           // aspect ratio on at least one of them.
-          can_mirror = FindMirrorMode(&cached_outputs_[1], &cached_outputs_[0],
-                                      false, preserve_aspect);
+          can_mirror = FindMirrorMode(
+              cached_outputs_[1], cached_outputs_[0], false, preserve_aspect);
         }
       }
     }
   }
 }
 
-bool OutputConfigurator::FindMirrorMode(OutputSnapshot* internal_output,
-                                        OutputSnapshot* external_output,
+bool OutputConfigurator::FindMirrorMode(gfx::DisplaySnapshot* internal_output,
+                                        gfx::DisplaySnapshot* external_output,
                                         bool try_panel_fitting,
                                         bool preserve_aspect) {
-  const ModeInfo* internal_native_info =
-      GetModeInfo(*internal_output, internal_output->native_mode);
-  const ModeInfo* external_native_info =
-      GetModeInfo(*external_output, external_output->native_mode);
+  const gfx::ModeInfo* internal_native_info =
+      internal_output->get_native_mode();
+  const gfx::ModeInfo* external_native_info =
+      external_output->get_native_mode();
   if (!internal_native_info || !external_native_info)
     return false;
 
   // Check if some external output resolution can be mirrored on internal.
   // Prefer the modes in the order that X sorts them, assuming this is the order
   // in which they look better on the monitor.
-  for (ModeInfoMap::const_iterator external_it =
-       external_output->mode_infos.begin();
-       external_it != external_output->mode_infos.end(); ++external_it) {
-    const ModeInfo& external_info = external_it->second;
-    bool is_native_aspect_ratio =
-        external_native_info->width * external_info.height ==
-        external_native_info->height * external_info.width;
+  for (ModeInfos::iterator external_it =
+           external_output->get_mode_infos().begin();
+       external_it != external_output->get_mode_infos().end();
+       ++external_it) {
+    gfx::ModeInfo* external_info = *external_it;
+    bool is_native_aspect_ratio = external_native_info->get_size().width() *
+                                      external_info->get_size().height() ==
+                                  external_native_info->get_size().height() *
+                                      external_info->get_size().width();
     if (preserve_aspect && !is_native_aspect_ratio)
       continue;  // Allow only aspect ratio preserving modes for mirroring.
 
     // Try finding an exact match.
-    for (ModeInfoMap::const_iterator internal_it =
-         internal_output->mode_infos.begin();
-         internal_it != internal_output->mode_infos.end(); ++internal_it) {
-      const ModeInfo& internal_info = internal_it->second;
-      if (internal_info.width == external_info.width &&
-          internal_info.height == external_info.height &&
-          internal_info.interlaced == external_info.interlaced) {
-        internal_output->mirror_mode = internal_it->first;
-        external_output->mirror_mode = external_it->first;
+    for (ModeInfos::iterator internal_it =
+             internal_output->get_mode_infos().begin();
+         internal_it != internal_output->get_mode_infos().end();
+         ++internal_it) {
+      gfx::ModeInfo* internal_info = *internal_it;
+      if (internal_info->get_size() == external_info->get_size() &&
+          internal_info->is_interlaced() == external_info->is_interlaced()) {
+        internal_output->set_mirror_mode(internal_info);
+        external_output->set_mirror_mode(external_info);
         return true;  // Mirror mode found.
       }
     }
@@ -763,16 +619,17 @@ bool OutputConfigurator::FindMirrorMode(OutputSnapshot* internal_output,
       // We can downscale by 1.125, and upscale indefinitely. Downscaling looks
       // ugly, so, can fit == can upscale. Also, internal panels don't support
       // fitting interlaced modes.
-      bool can_fit =
-          internal_native_info->width >= external_info.width &&
-          internal_native_info->height >= external_info.height &&
-          !external_info.interlaced;
+      bool can_fit = internal_native_info->get_size().width() >=
+                         external_info->get_size().width() &&
+                     internal_native_info->get_size().height() >=
+                         external_info->get_size().height() &&
+                     !external_info->is_interlaced();
       if (can_fit) {
-        RRMode mode = external_it->first;
-        delegate_->AddOutputMode(internal_output->output, mode);
-        internal_output->mode_infos.insert(std::make_pair(mode, external_info));
-        internal_output->mirror_mode = mode;
-        external_output->mirror_mode = mode;
+        delegate_->AddMode(*internal_output, *external_info);
+        gfx::ModeInfo* new_mode = external_info->Clone();
+        internal_output->get_mode_infos().push_back(new_mode);
+        internal_output->set_mirror_mode(new_mode);
+        external_output->set_mirror_mode(external_info);
         return true;  // Mirror mode created.
       }
     }
@@ -784,19 +641,21 @@ bool OutputConfigurator::FindMirrorMode(OutputSnapshot* internal_output,
 void OutputConfigurator::ConfigureOutputs() {
   configure_timer_.reset();
 
-  delegate_->GrabServer();
+  delegate_->Lock();
   UpdateCachedOutputs();
-  const OutputState new_state = ChooseOutputState(power_state_);
+  const gfx::NativeDisplayBridge::OutputState new_state =
+      ChooseOutputState(power_state_);
   const bool success = EnterStateOrFallBackToSoftwareMirroring(
       new_state, power_state_);
-  delegate_->UngrabServer();
+  delegate_->Unlock();
 
   NotifyObservers(success, new_state);
   SendProjectingStateToPowerManager();
 }
 
-void OutputConfigurator::NotifyObservers(bool success,
-                                         OutputState attempted_state) {
+void OutputConfigurator::NotifyObservers(
+    bool success,
+    gfx::NativeDisplayBridge::OutputState attempted_state) {
   if (success) {
     FOR_EACH_OBSERVER(Observer, observers_,
                       OnDisplayModeChanged(cached_outputs_));
@@ -807,16 +666,18 @@ void OutputConfigurator::NotifyObservers(bool success,
 }
 
 bool OutputConfigurator::EnterStateOrFallBackToSoftwareMirroring(
-    OutputState output_state,
+    gfx::NativeDisplayBridge::OutputState output_state,
     DisplayPowerState power_state) {
   bool success = EnterState(output_state, power_state);
   if (mirroring_controller_) {
     bool enable_software_mirroring = false;
-    if (!success && output_state == STATE_DUAL_MIRROR) {
-      if (output_state_ != STATE_DUAL_EXTENDED || power_state_ != power_state)
-        EnterState(STATE_DUAL_EXTENDED, power_state);
+    if (!success &&
+        output_state == gfx::NativeDisplayBridge::STATE_DUAL_MIRROR) {
+      if (output_state_ != gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED ||
+          power_state_ != power_state)
+        EnterState(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED, power_state);
       enable_software_mirroring = success =
-          output_state_ == STATE_DUAL_EXTENDED;
+          output_state_ == gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED;
     }
     mirroring_controller_->SetSoftwareMirroring(enable_software_mirroring);
   }
@@ -824,7 +685,7 @@ bool OutputConfigurator::EnterStateOrFallBackToSoftwareMirroring(
 }
 
 bool OutputConfigurator::EnterState(
-    OutputState output_state,
+    gfx::NativeDisplayBridge::OutputState output_state,
     DisplayPowerState power_state) {
   std::vector<bool> output_power;
   int num_on_outputs = GetOutputPower(
@@ -834,21 +695,24 @@ bool OutputConfigurator::EnterState(
 
   // Framebuffer dimensions.
   int width = 0, height = 0;
-  std::vector<OutputSnapshot> updated_outputs = cached_outputs_;
+  ScopedVector<gfx::DisplaySnapshot> updated_outputs;
+  for (unsigned int i = 0; i < cached_outputs_.size(); ++i) {
+    updated_outputs.push_back(cached_outputs_[i]->Clone());
+  }
 
   switch (output_state) {
-    case STATE_INVALID:
+    case gfx::NativeDisplayBridge::STATE_INVALID:
       NOTREACHED() << "Ignoring request to enter invalid state with "
                    << updated_outputs.size() << " connected output(s)";
       return false;
-    case STATE_HEADLESS:
+    case gfx::NativeDisplayBridge::STATE_HEADLESS:
       if (updated_outputs.size() != 0) {
         LOG(WARNING) << "Ignoring request to enter headless mode with "
                      << updated_outputs.size() << " connected output(s)";
         return false;
       }
       break;
-    case STATE_SINGLE: {
+    case gfx::NativeDisplayBridge::STATE_SINGLE: {
       // If there are multiple outputs connected, only one should be turned on.
       if (updated_outputs.size() != 1 && num_on_outputs != 1) {
         LOG(WARNING) << "Ignoring request to enter single mode with "
@@ -858,32 +722,34 @@ bool OutputConfigurator::EnterState(
       }
 
       for (size_t i = 0; i < updated_outputs.size(); ++i) {
-        OutputSnapshot* output = &updated_outputs[i];
-        output->x = 0;
-        output->y = 0;
-        output->current_mode = output_power[i] ? output->selected_mode : None;
+        gfx::DisplaySnapshot* output = updated_outputs[i];
+        output->get_origin().SetPoint(0, 0);
+        if (output_power[i]) {
+          output->set_current_mode(output->get_selected_mode());
+        } else {
+          output->set_current_mode(NULL);
+        }
 
         if (output_power[i] || updated_outputs.size() == 1) {
-          const ModeInfo* mode_info =
-              GetModeInfo(*output, output->selected_mode);
+          const gfx::ModeInfo* mode_info = output->get_selected_mode();
           if (!mode_info)
             return false;
-          if (mode_info->width == 1024 && mode_info->height == 768) {
+          if (mode_info->get_size().width() == 1024 &&
+              mode_info->get_size().height() == 768) {
             VLOG(1) << "Potentially misdetecting display(1024x768):"
                     << " outputs size=" << updated_outputs.size()
                     << ", num_on_outputs=" << num_on_outputs
                     << ", current size:" << width << "x" << height
-                    << ", i=" << i
-                    << ", output=" << OutputSnapshotToString(output)
-                    << ", mode_info=" << ModeInfoToString(mode_info);
+                    << ", i=" << i << ", output=" << output->ToString()
+                    << ", mode_info=" << mode_info->ToString();
           }
-          width = mode_info->width;
-          height = mode_info->height;
+          width = mode_info->get_size().width();
+          height = mode_info->get_size().height();
         }
       }
       break;
     }
-    case STATE_DUAL_MIRROR: {
+    case gfx::NativeDisplayBridge::STATE_DUAL_MIRROR: {
       if (updated_outputs.size() != 2 ||
           (num_on_outputs != 0 && num_on_outputs != 2)) {
         LOG(WARNING) << "Ignoring request to enter mirrored mode with "
@@ -892,34 +758,37 @@ bool OutputConfigurator::EnterState(
         return false;
       }
 
-      if (!updated_outputs[0].mirror_mode)
+      if (!updated_outputs[0]->get_mirror_mode())
         return false;
-      const ModeInfo* mode_info =
-          GetModeInfo(updated_outputs[0], updated_outputs[0].mirror_mode);
+      const gfx::ModeInfo* mode_info = updated_outputs[0]->get_mirror_mode();
       if (!mode_info)
         return false;
-      width = mode_info->width;
-      height = mode_info->height;
+      width = mode_info->get_size().width();
+      height = mode_info->get_size().height();
 
       for (size_t i = 0; i < updated_outputs.size(); ++i) {
-        OutputSnapshot* output = &updated_outputs[i];
-        output->x = 0;
-        output->y = 0;
-        output->current_mode = output_power[i] ? output->mirror_mode : None;
-        if (output->touch_device_id) {
+        gfx::DisplaySnapshot* output = updated_outputs[i];
+        output->get_origin().SetPoint(0, 0);
+        if (output_power[i]) {
+          output->set_current_mode(output->get_mirror_mode());
+        } else {
+          output->set_current_mode(NULL);
+        }
+
+        if (output->get_touch_device_id()) {
           // CTM needs to be calculated if aspect preserving scaling is used.
           // Otherwise, assume it is full screen, and use identity CTM.
-          if (output->mirror_mode != output->native_mode &&
-              output->is_aspect_preserving_scaling) {
-            output->transform = GetMirrorModeCTM(*output);
-            mirrored_display_area_ratio_map_[output->touch_device_id] =
+          if (output->get_mirror_mode() != output->get_native_mode() &&
+              output->get_is_aspect_preserving_scaling()) {
+            output->set_transform(GetMirrorModeCTM(*output));
+            mirrored_display_area_ratio_map_[output->get_touch_device_id()] =
                 GetMirroredDisplayAreaRatio(*output);
           }
         }
       }
       break;
     }
-    case STATE_DUAL_EXTENDED: {
+    case gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED: {
       if (updated_outputs.size() != 2 ||
           (num_on_outputs != 0 && num_on_outputs != 2)) {
         LOG(WARNING) << "Ignoring request to enter extended mode with "
@@ -929,26 +798,29 @@ bool OutputConfigurator::EnterState(
       }
 
       for (size_t i = 0; i < updated_outputs.size(); ++i) {
-        OutputSnapshot* output = &updated_outputs[i];
-        output->x = 0;
-        output->y = height ? height + kVerticalGap : 0;
-        output->current_mode = output_power[i] ? output->selected_mode : None;
+        gfx::DisplaySnapshot* output = updated_outputs[i];
+        output->get_origin().SetPoint(0, height ? height + kVerticalGap : 0);
+        if (output_power[i]) {
+          output->set_current_mode(output->get_selected_mode());
+        } else {
+          output->set_current_mode(NULL);
+        }
 
         // Retain the full screen size even if all outputs are off so the
         // same desktop configuration can be restored when the outputs are
         // turned back on.
-        const ModeInfo* mode_info =
-            GetModeInfo(updated_outputs[i], updated_outputs[i].selected_mode);
+        const gfx::ModeInfo* mode_info =
+            updated_outputs[i]->get_selected_mode();
         if (!mode_info)
           return false;
-        width = std::max<int>(width, mode_info->width);
-        height += (height ? kVerticalGap : 0) + mode_info->height;
+        width = std::max<int>(width, mode_info->get_size().width());
+        height += (height ? kVerticalGap : 0) + mode_info->get_size().height();
       }
 
       for (size_t i = 0; i < updated_outputs.size(); ++i) {
-        OutputSnapshot* output = &updated_outputs[i];
-        if (output->touch_device_id)
-          output->transform = GetExtendedModeCTM(*output, width, height);
+        gfx::DisplaySnapshot* output = updated_outputs[i];
+        if (output->get_touch_device_id())
+          output->set_transform(GetExtendedModeCTM(*output, width, height));
       }
       break;
     }
@@ -960,23 +832,17 @@ bool OutputConfigurator::EnterState(
   if (!updated_outputs.empty()) {
     delegate_->CreateFrameBuffer(width, height, updated_outputs);
     for (size_t i = 0; i < updated_outputs.size(); ++i) {
-      const OutputSnapshot& output = updated_outputs[i];
-      bool configure_succeeded =false;
+      const gfx::DisplaySnapshot* output = updated_outputs[i];
+      bool configure_succeeded = false;
 
       while (true) {
-        if (delegate_->ConfigureCrtc(output.crtc, output.current_mode,
-                                       output.output, output.x, output.y)) {
+        if (delegate_->Configure(*output)) {
           configure_succeeded = true;
           break;
         }
 
-        LOG(WARNING) << "Unable to configure CRTC " << output.crtc << ":"
-                     << " mode=" << output.current_mode
-                     << " output=" << output.output
-                     << " x=" << output.x
-                     << " y=" << output.y;
-
-        const ModeInfo* mode_info = GetModeInfo(output, output.current_mode);
+        LOG(WARNING) << "Unable to configure output " << output->ToString();
+        const gfx::ModeInfo* mode_info = output->get_current_mode();
         if (!mode_info)
           break;
 
@@ -984,13 +850,16 @@ bool OutputConfigurator::EnterState(
         // be set.
         int best_mode_pixels = 0;
 
-        int current_mode_pixels = mode_info->width * mode_info->height;
-        for (ModeInfoMap::const_iterator it = output.mode_infos.begin();
-             it != output.mode_infos.end(); it++) {
-          int pixel_count = it->second.width * it->second.height;
+        int current_mode_pixels =
+            mode_info->get_size().width() * mode_info->get_size().height();
+        for (ModeInfos::const_iterator it = output->get_mode_infos().begin();
+             it != output->get_mode_infos().end();
+             it++) {
+          int pixel_count =
+              (*it)->get_size().width() * (*it)->get_size().height();
           if ((pixel_count < current_mode_pixels) &&
               (pixel_count > best_mode_pixels)) {
-            updated_outputs[i].current_mode = it->first;
+            updated_outputs[i]->set_current_mode(*it);
             best_mode_pixels = pixel_count;
           }
         }
@@ -1000,9 +869,10 @@ bool OutputConfigurator::EnterState(
       }
 
       if (configure_succeeded) {
-        if (output.touch_device_id)
-          delegate_->ConfigureCTM(output.touch_device_id, output.transform);
-        cached_outputs_[i] = updated_outputs[i];
+        if (output->get_touch_device_id())
+          delegate_->ConfigureCTM(output->get_touch_device_id(),
+                                  output->get_transform());
+        std::swap(cached_outputs_[i], updated_outputs[i]);
       } else {
         all_succeeded = false;
       }
@@ -1010,9 +880,9 @@ bool OutputConfigurator::EnterState(
       // If we are trying to set mirror mode and one of the modesets fails,
       // then the two monitors will be mis-matched.  In this case, return
       // false to let the observers be aware.
-      if (output_state == STATE_DUAL_MIRROR &&
+      if (output_state == gfx::NativeDisplayBridge::STATE_DUAL_MIRROR &&
           output_power[i] &&
-          output.current_mode != output.mirror_mode)
+          output->get_current_mode() != output->get_mirror_mode())
         all_succeeded = false;
 
     }
@@ -1025,28 +895,28 @@ bool OutputConfigurator::EnterState(
   return all_succeeded;
 }
 
-OutputState OutputConfigurator::ChooseOutputState(
+gfx::NativeDisplayBridge::OutputState OutputConfigurator::ChooseOutputState(
     DisplayPowerState power_state) const {
   int num_on_outputs = GetOutputPower(cached_outputs_, power_state, NULL);
   switch (cached_outputs_.size()) {
     case 0:
-      return STATE_HEADLESS;
+      return gfx::NativeDisplayBridge::STATE_HEADLESS;
     case 1:
-      return STATE_SINGLE;
+      return gfx::NativeDisplayBridge::STATE_SINGLE;
     case 2: {
       if (num_on_outputs == 1) {
         // If only one output is currently turned on, return the "single"
         // state so that its native mode will be used.
-        return STATE_SINGLE;
+        return gfx::NativeDisplayBridge::STATE_SINGLE;
       } else {
         // With either both outputs on or both outputs off, use one of the
         // dual modes.
         std::vector<int64> display_ids;
         for (size_t i = 0; i < cached_outputs_.size(); ++i) {
           // If display id isn't available, switch to extended mode.
-          if (!cached_outputs_[i].has_display_id)
-            return STATE_DUAL_EXTENDED;
-          display_ids.push_back(cached_outputs_[i].display_id);
+          if (!cached_outputs_[i]->has_display_id())
+            return gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED;
+          display_ids.push_back(cached_outputs_[i]->get_display_id());
         }
         return state_controller_->GetStateForDisplayIds(display_ids);
       }
@@ -1054,51 +924,53 @@ OutputState OutputConfigurator::ChooseOutputState(
     default:
       NOTREACHED();
   }
-  return STATE_INVALID;
+  return gfx::NativeDisplayBridge::STATE_INVALID;
 }
 
-OutputConfigurator::CoordinateTransformation
-OutputConfigurator::GetMirrorModeCTM(
-    const OutputConfigurator::OutputSnapshot& output) {
-  CoordinateTransformation ctm;  // Default to identity
-  const ModeInfo* native_mode_info = GetModeInfo(output, output.native_mode);
-  const ModeInfo* mirror_mode_info = GetModeInfo(output, output.mirror_mode);
+gfx::Matrix3F OutputConfigurator::GetMirrorModeCTM(
+    const gfx::DisplaySnapshot& output) {
+  gfx::Matrix3F ctm = gfx::Matrix3F::Identity();  // Default to identity
+  const gfx::ModeInfo* native_mode_info = output.get_native_mode();
+  const gfx::ModeInfo* mirror_mode_info = output.get_mirror_mode();
 
   if (!native_mode_info || !mirror_mode_info ||
-      native_mode_info->height == 0 || mirror_mode_info->height == 0 ||
-      native_mode_info->width == 0 || mirror_mode_info->width == 0)
+      native_mode_info->get_size().height() == 0 ||
+      mirror_mode_info->get_size().height() == 0 ||
+      native_mode_info->get_size().width() == 0 ||
+      mirror_mode_info->get_size().width() == 0)
     return ctm;
 
-  float native_mode_ar = static_cast<float>(native_mode_info->width) /
-      static_cast<float>(native_mode_info->height);
-  float mirror_mode_ar = static_cast<float>(mirror_mode_info->width) /
-      static_cast<float>(mirror_mode_info->height);
+  float native_mode_ar =
+      static_cast<float>(native_mode_info->get_size().width()) /
+      static_cast<float>(native_mode_info->get_size().height());
+  float mirror_mode_ar =
+      static_cast<float>(mirror_mode_info->get_size().width()) /
+      static_cast<float>(mirror_mode_info->get_size().height());
 
   if (mirror_mode_ar > native_mode_ar) {  // Letterboxing
-    ctm.x_scale = 1.0;
-    ctm.x_offset = 0.0;
-    ctm.y_scale = mirror_mode_ar / native_mode_ar;
-    ctm.y_offset = (native_mode_ar / mirror_mode_ar - 1.0) * 0.5;
+    // Set y scale
+    ctm.set(1, 1, mirror_mode_ar / native_mode_ar);
+    // Set y offset
+    ctm.set(1, 2, (native_mode_ar / mirror_mode_ar - 1.0) * 0.5);
     return ctm;
   }
   if (native_mode_ar > mirror_mode_ar) {  // Pillarboxing
-    ctm.y_scale = 1.0;
-    ctm.y_offset = 0.0;
-    ctm.x_scale = native_mode_ar / mirror_mode_ar;
-    ctm.x_offset = (mirror_mode_ar / native_mode_ar - 1.0) * 0.5;
+    // Set x scale
+    ctm.set(0, 0, native_mode_ar / mirror_mode_ar);
+    // Set x offset
+    ctm.set(0, 2, (mirror_mode_ar / native_mode_ar - 1.0) * 0.5);
     return ctm;
   }
 
   return ctm;  // Same aspect ratio - return identity
 }
 
-OutputConfigurator::CoordinateTransformation
-OutputConfigurator::GetExtendedModeCTM(
-    const OutputConfigurator::OutputSnapshot& output,
+gfx::Matrix3F OutputConfigurator::GetExtendedModeCTM(
+    const gfx::DisplaySnapshot& output,
     int framebuffer_width,
     int framebuffer_height) {
-  CoordinateTransformation ctm;  // Default to identity
-  const ModeInfo* mode_info = GetModeInfo(output, output.selected_mode);
+  gfx::Matrix3F ctm = gfx::Matrix3F::Identity();
+  const gfx::ModeInfo* mode_info = output.get_selected_mode();
   DCHECK(mode_info);
   if (!mode_info)
     return ctm;
@@ -1122,33 +994,93 @@ OutputConfigurator::GetExtendedModeCTM(
   // y_scale = (1600 - 1) / (2428 - 1)
   // y_offset = 828 / (2428 -1)
   // See the unittest OutputConfiguratorTest.CTMForMultiScreens.
-  ctm.x_scale =
-      static_cast<float>(mode_info->width - 1) / (framebuffer_width - 1);
-  ctm.x_offset = static_cast<float>(output.x) / (framebuffer_width - 1);
-  ctm.y_scale =
-      static_cast<float>(mode_info->height - 1) / (framebuffer_height - 1);
-  ctm.y_offset = static_cast<float>(output.y) / (framebuffer_height - 1);
+  //
+  // Set x scale
+  ctm.set(0,
+          0,
+          static_cast<float>(mode_info->get_size().width() - 1) /
+              (framebuffer_width - 1));
+  // Set x offset
+  ctm.set(
+      0,
+      2,
+      static_cast<float>(output.get_origin().x()) / (framebuffer_width - 1));
+  // Set y scale
+  ctm.set(1,
+          1,
+          static_cast<float>(mode_info->get_size().height() - 1) /
+              (framebuffer_height - 1));
+  // Set y offset
+  ctm.set(
+      1,
+      2,
+      static_cast<float>(output.get_origin().y()) / (framebuffer_height - 1));
   return ctm;
 }
 
 float OutputConfigurator::GetMirroredDisplayAreaRatio(
-    const OutputConfigurator::OutputSnapshot& output) {
+    const gfx::DisplaySnapshot& output) {
   float area_ratio = 1.0f;
-  const ModeInfo* native_mode_info = GetModeInfo(output, output.native_mode);
-  const ModeInfo* mirror_mode_info = GetModeInfo(output, output.mirror_mode);
+  const gfx::ModeInfo* native_mode_info = output.get_native_mode();
+  const gfx::ModeInfo* mirror_mode_info = output.get_mirror_mode();
 
   if (!native_mode_info || !mirror_mode_info ||
-      native_mode_info->height == 0 || mirror_mode_info->height == 0 ||
-      native_mode_info->width == 0 || mirror_mode_info->width == 0)
+      native_mode_info->get_size().height() == 0 ||
+      mirror_mode_info->get_size().height() == 0 ||
+      native_mode_info->get_size().width() == 0 ||
+      mirror_mode_info->get_size().width() == 0)
     return area_ratio;
 
-  float width_ratio = static_cast<float>(mirror_mode_info->width) /
-      static_cast<float>(native_mode_info->width);
-  float height_ratio = static_cast<float>(mirror_mode_info->height) /
-      static_cast<float>(native_mode_info->height);
+  float width_ratio = static_cast<float>(mirror_mode_info->get_size().width()) /
+                      static_cast<float>(native_mode_info->get_size().width());
+  float height_ratio =
+      static_cast<float>(mirror_mode_info->get_size().height()) /
+      static_cast<float>(native_mode_info->get_size().height());
 
   area_ratio = width_ratio * height_ratio;
   return area_ratio;
 }
 
+void OutputConfigurator::OnDisplayChanged() {
+  if (!configure_display_)
+    return;
+
+  ScheduleConfigureOutputs();
+}
+
+void OutputConfigurator::OnDisplayAdded(const gfx::DisplaySnapshot& display) {
+  if (!configure_display_)
+    return;
+
+  for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+           cached_outputs_.begin();
+       it != cached_outputs_.end();
+       ++it) {
+    if ((*it)->SameAs(display) &&
+        HasSameCurrentMode((*it)->get_current_mode(),
+                           display.get_current_mode())) {
+      VLOG(1) << "Ignoring event describing already-cached state";
+      return;
+    }
+  }
+
+  ScheduleConfigureOutputs();
+}
+
+void OutputConfigurator::OnDisplayRemoved(const gfx::DisplaySnapshot& display) {
+  if (!configure_display_)
+    return;
+
+  for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+           cached_outputs_.begin();
+       it != cached_outputs_.end();
+       ++it) {
+    if ((*it)->SameAs(display)) {
+      ScheduleConfigureOutputs();
+      return;
+    }
+  }
+  VLOG(1) << "Ignoring event describing already-disconnected output";
+}
+
 }  // namespace chromeos
diff --git a/chromeos/display/output_configurator.h b/chromeos/display/output_configurator.h
index 8a8b36d..74b81e8 100644
--- a/chromeos/display/output_configurator.h
+++ b/chromeos/display/output_configurator.h
@@ -12,140 +12,32 @@
 #include "base/basictypes.h"
 #include "base/event_types.h"
 #include "base/memory/scoped_ptr.h"
+#include "base/memory/scoped_vector.h"
 #include "base/message_loop/message_loop.h"
 #include "base/message_loop/message_pump_dispatcher.h"
 #include "base/observer_list.h"
 #include "base/timer/timer.h"
 #include "chromeos/chromeos_export.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
+#include "ui/gfx/geometry/matrix3_f.h"
+#include "ui/gfx/mode_info.h"
+#include "ui/gfx/native_display_bridge.h"
 
-// Forward declarations for Xlib and Xrandr.
-// This is so unused X definitions don't pollute the namespace.
-typedef unsigned long XID;
-typedef XID RROutput;
-typedef XID RRCrtc;
-typedef XID RRMode;
+namespace gfx {
+class DisplaySnapshot;
+}
 
 namespace chromeos {
 
-// Used to describe the state of a multi-display configuration.
-enum OutputState {
-  STATE_INVALID,
-  STATE_HEADLESS,
-  STATE_SINGLE,
-  STATE_DUAL_MIRROR,
-  STATE_DUAL_EXTENDED,
-};
-
-// Video output types.
-enum OutputType {
-  OUTPUT_TYPE_NONE = 0,
-  OUTPUT_TYPE_UNKNOWN = 1 << 0,
-  OUTPUT_TYPE_INTERNAL = 1 << 1,
-  OUTPUT_TYPE_VGA = 1 << 2,
-  OUTPUT_TYPE_HDMI = 1 << 3,
-  OUTPUT_TYPE_DVI = 1 << 4,
-  OUTPUT_TYPE_DISPLAYPORT = 1 << 5,
-  OUTPUT_TYPE_NETWORK = 1 << 6,
-};
-
-// Content protection methods applied on video output.
-enum OutputProtectionMethod {
-  OUTPUT_PROTECTION_METHOD_NONE = 0,
-  OUTPUT_PROTECTION_METHOD_HDCP = 1 << 0,
-};
-
-// HDCP protection state.
-enum HDCPState {
-  HDCP_STATE_UNDESIRED,
-  HDCP_STATE_DESIRED,
-  HDCP_STATE_ENABLED
-};
-
 // This class interacts directly with the underlying Xrandr API to manipulate
 // CTRCs and Outputs.
 class CHROMEOS_EXPORT OutputConfigurator
-    : public base::MessagePumpDispatcher,
-      public base::MessagePumpObserver {
+    : public gfx::NativeDisplayBridge::Observer {
  public:
   typedef uint64_t OutputProtectionClientId;
   static const OutputProtectionClientId kInvalidClientId = 0;
 
-  struct ModeInfo {
-    ModeInfo();
-    ModeInfo(int width, int height, bool interlaced, float refresh_rate);
-
-    int width;
-    int height;
-    bool interlaced;
-    float refresh_rate;
-  };
-
-  typedef std::map<RRMode, ModeInfo> ModeInfoMap;
-
-  struct CoordinateTransformation {
-    // Initialized to the identity transformation.
-    CoordinateTransformation();
-
-    float x_scale;
-    float x_offset;
-    float y_scale;
-    float y_offset;
-  };
-
-  // Information about an output's current state.
-  struct OutputSnapshot {
-    OutputSnapshot();
-    ~OutputSnapshot();
-
-    RROutput output;
-
-    // CRTC that should be used for this output. Not necessarily the CRTC
-    // that XRandR reports is currently being used.
-    RRCrtc crtc;
-
-    // Mode currently being used by the output.
-    RRMode current_mode;
-
-    // "Best" mode supported by the output.
-    RRMode native_mode;
-
-    // Mode used when displaying the same desktop on multiple outputs.
-    RRMode mirror_mode;
-
-    // User-selected mode for the output.
-    RRMode selected_mode;
-
-    // Output's origin on the framebuffer.
-    int x;
-    int y;
-
-    // Output's physical dimensions.
-    uint64 width_mm;
-    uint64 height_mm;
-
-    bool is_aspect_preserving_scaling;
-
-    // The type of output.
-    OutputType type;
-
-    // Map from mode IDs to details about the corresponding modes.
-    ModeInfoMap mode_infos;
-
-    // XInput device ID or 0 if this output isn't a touchscreen.
-    int touch_device_id;
-
-    CoordinateTransformation transform;
-
-    // Display id for this output.
-    int64 display_id;
-
-    bool has_display_id;
-
-    // This output's index in the array returned by XRandR. Stable even as
-    // outputs are connected or disconnected.
-    int index;
-  };
+  typedef ScopedVector<gfx::ModeInfo> ModeInfos;
 
   class Observer {
    public:
@@ -156,11 +48,12 @@ class CHROMEOS_EXPORT OutputConfigurator
     // when this method is called, so the actual configuration could've changed
     // already.
     virtual void OnDisplayModeChanged(
-        const std::vector<OutputSnapshot>& outputs) {}
+        const ScopedVector<gfx::DisplaySnapshot>& outputs) {}
 
     // Called after a display mode change attempt failed. |failed_new_state| is
     // the new state which the system failed to enter.
-    virtual void OnDisplayModeChangeFailed(OutputState failed_new_state) {}
+    virtual void OnDisplayModeChangeFailed(
+        gfx::NativeDisplayBridge::OutputState failed_new_state) {}
   };
 
   // Interface for classes that make decisions about which output state
@@ -170,7 +63,7 @@ class CHROMEOS_EXPORT OutputConfigurator
     virtual ~StateController() {}
 
     // Called when displays are detected.
-    virtual OutputState GetStateForDisplayIds(
+    virtual gfx::NativeDisplayBridge::OutputState GetStateForDisplayIds(
         const std::vector<int64>& display_ids) const = 0;
 
     // Queries the resolution (|width|x|height|) in pixels
@@ -189,112 +82,37 @@ class CHROMEOS_EXPORT OutputConfigurator
     virtual void SetSoftwareMirroring(bool enabled) = 0;
   };
 
-  // Interface for classes that perform actions on behalf of OutputController.
-  class Delegate {
-   public:
-    virtual ~Delegate() {}
-
-    // Initializes the XRandR extension, saving the base event ID to
-    // |event_base|.
-    virtual void InitXRandRExtension(int* event_base) = 0;
-
-    // Tells XRandR to update its configuration in response to |event|, an
-    // RRScreenChangeNotify event.
-    virtual void UpdateXRandRConfiguration(const base::NativeEvent& event) = 0;
-
-    // Grabs the X server and refreshes XRandR-related resources.  While
-    // the server is grabbed, other clients are blocked.  Must be balanced
-    // by a call to UngrabServer().
-    virtual void GrabServer() = 0;
-
-    // Ungrabs the server and frees XRandR-related resources.
-    virtual void UngrabServer() = 0;
-
-    // Flushes all pending requests and waits for replies.
-    virtual void SyncWithServer() = 0;
-
-    // Sets the window's background color to |color_argb|.
-    virtual void SetBackgroundColor(uint32 color_argb) = 0;
-
-    // Enables DPMS and forces it to the "on" state.
-    virtual void ForceDPMSOn() = 0;
-
-    // Returns information about the current outputs. This method may block for
-    // 60 milliseconds or more. The returned outputs are not fully initialized;
-    // the rest of the work happens in
-    // OutputConfigurator::UpdateCachedOutputs().
-    virtual std::vector<OutputSnapshot> GetOutputs() = 0;
-
-    // Adds |mode| to |output|.
-    virtual void AddOutputMode(RROutput output, RRMode mode) = 0;
-
-    // Calls XRRSetCrtcConfig() with the given options but some of our default
-    // output count and rotation arguments. Returns true on success.
-    virtual bool ConfigureCrtc(RRCrtc crtc,
-                               RRMode mode,
-                               RROutput output,
-                               int x,
-                               int y) = 0;
-
-    // Called to set the frame buffer (underlying XRR "screen") size.  Has
-    // a side-effect of disabling all CRTCs.
-    virtual void CreateFrameBuffer(
-        int width,
-        int height,
-        const std::vector<OutputConfigurator::OutputSnapshot>& outputs) = 0;
-
-    // Configures XInput's Coordinate Transformation Matrix property.
-    // |touch_device_id| the ID of the touchscreen device to configure.
-    // |ctm| contains the desired transformation parameters.  The offsets
-    // in it should be normalized so that 1 corresponds to the X or Y axis
-    // size for the corresponding offset.
-    virtual void ConfigureCTM(int touch_device_id,
-                              const CoordinateTransformation& ctm) = 0;
-
-    // Sends a D-Bus message to the power manager telling it that the
-    // machine is or is not projecting.
-    virtual void SendProjectingStateToPowerManager(bool projecting) = 0;
-
-    // Gets HDCP state of output.
-    virtual bool GetHDCPState(RROutput id, HDCPState* state) = 0;
-
-    // Sets HDCP state of output.
-    virtual bool SetHDCPState(RROutput id, HDCPState state) = 0;
-  };
-
   // Helper class used by tests.
   class TestApi {
    public:
-    TestApi(OutputConfigurator* configurator, int xrandr_event_base)
-        : configurator_(configurator),
-          xrandr_event_base_(xrandr_event_base) {}
+    TestApi(OutputConfigurator* configurator) : configurator_(configurator) {}
     ~TestApi() {}
 
-    const std::vector<OutputSnapshot>& cached_outputs() const {
+    const ScopedVector<gfx::DisplaySnapshot>& cached_outputs() const {
       return configurator_->cached_outputs_;
     }
 
-    // Dispatches an RRScreenChangeNotify event to |configurator_|.
-    void SendScreenChangeEvent();
-
-    // Dispatches an RRNotify_OutputChange event to |configurator_|.
-    void SendOutputChangeEvent(RROutput output,
-                               RRCrtc crtc,
-                               RRMode mode,
-                               bool connected);
-
     // If |configure_timer_| is started, stops the timer, runs
     // ConfigureOutputs(), and returns true; returns false otherwise.
     bool TriggerConfigureTimeout();
 
-   private:
+   protected:
     OutputConfigurator* configurator_;  // not owned
 
-    int xrandr_event_base_;
-
     DISALLOW_COPY_AND_ASSIGN(TestApi);
   };
 
+  class ProjectionDelegate {
+   public:
+    ProjectionDelegate() {}
+    virtual ~ProjectionDelegate() {}
+
+    virtual void SendProjectingStateToPowerManager(bool projecting) = 0;
+
+   private:
+    DISALLOW_COPY_AND_ASSIGN(ProjectionDelegate);
+  };
+
   // Flags that can be passed to SetDisplayPower().
   static const int kSetDisplayPowerNoFlags                     = 0;
   // Configure displays even if the passed-in state matches |power_state_|.
@@ -312,21 +130,17 @@ class CHROMEOS_EXPORT OutputConfigurator
   // See crbug.com/130188 for initial discussion.
   static const int kVerticalGap = 60;
 
-  // Returns a pointer to the ModeInfo struct in |output| corresponding to
-  // |mode|, or NULL if the struct isn't present.
-  static const ModeInfo* GetModeInfo(const OutputSnapshot& output,
-                                     RRMode mode);
-
-  // Returns the mode within |output| that matches the given size with highest
-  // refresh rate. Returns None if no matching output was found.
-  static RRMode FindOutputModeMatchingSize(const OutputSnapshot& output,
-                                           int width,
-                                           int height);
-
   OutputConfigurator();
   virtual ~OutputConfigurator();
 
-  OutputState output_state() const { return output_state_; }
+  // Override for gfx::NativeDisplayBridge::Observer
+  virtual void OnDisplayChanged() OVERRIDE;
+  virtual void OnDisplayAdded(const gfx::DisplaySnapshot& display) OVERRIDE;
+  virtual void OnDisplayRemoved(const gfx::DisplaySnapshot& display) OVERRIDE;
+
+  gfx::NativeDisplayBridge::OutputState output_state() const {
+    return output_state_;
+  }
   DisplayPowerState power_state() const { return power_state_; }
 
   void set_state_controller(StateController* controller) {
@@ -338,7 +152,9 @@ class CHROMEOS_EXPORT OutputConfigurator
 
   // Replaces |delegate_| with |delegate| and sets |configure_display_| to
   // true.  Should be called before Init().
-  void SetDelegateForTesting(scoped_ptr<Delegate> delegate);
+  void SetDelegateForTesting(scoped_ptr<gfx::NativeDisplayBridge> delegate);
+
+  void SetProjectionDelegateForTesting(scoped_ptr<ProjectionDelegate> delegate);
 
   // Sets the initial value of |power_state_|.  Must be called before Start().
   void SetInitialDisplayPower(DisplayPowerState power_state);
@@ -365,19 +181,7 @@ class CHROMEOS_EXPORT OutputConfigurator
   // Force switching the display mode to |new_state|. Returns false if
   // switching failed (possibly because |new_state| is invalid for the
   // current set of connected outputs).
-  bool SetDisplayMode(OutputState new_state);
-
-  // Called when an RRNotify event is received.  The implementation is
-  // interested in the cases of RRNotify events which correspond to output
-  // add/remove events.  Note that Output add/remove events are sent in response
-  // to our own reconfiguration operations so spurious events are common.
-  // Spurious events will have no effect.
-  virtual bool Dispatch(const base::NativeEvent& event) OVERRIDE;
-
-  // Overridden from base::MessagePumpObserver:
-  virtual base::EventStatus WillProcessEvent(
-      const base::NativeEvent& event) OVERRIDE;
-  virtual void DidProcessEvent(const base::NativeEvent& event) OVERRIDE;
+  bool SetDisplayMode(gfx::NativeDisplayBridge::OutputState new_state);
 
   // Called when a casting session is started or stopped.
   void OnCastingSessionStartedOrStopped(bool started);
@@ -453,8 +257,8 @@ class CHROMEOS_EXPORT OutputConfigurator
   //
   // |preserve_aspect| limits the search/creation only to the modes having the
   // native aspect ratio of |external_output|.
-  bool FindMirrorMode(OutputSnapshot* internal_output,
-                      OutputSnapshot* external_output,
+  bool FindMirrorMode(gfx::DisplaySnapshot* internal_output,
+                      gfx::DisplaySnapshot* external_output,
                       bool try_panel_fitting,
                       bool preserve_aspect);
 
@@ -462,7 +266,8 @@ class CHROMEOS_EXPORT OutputConfigurator
   void ConfigureOutputs();
 
   // Notifies observers about an attempted state change.
-  void NotifyObservers(bool success, OutputState attempted_state);
+  void NotifyObservers(bool success,
+                       gfx::NativeDisplayBridge::OutputState attempted_state);
 
   // Switches to the state specified in |output_state| and |power_state|.
   // If the hardware mirroring failed and |mirroring_controller_| is set,
@@ -471,37 +276,36 @@ class CHROMEOS_EXPORT OutputConfigurator
   // On success, updates |output_state_|, |power_state_|, and |cached_outputs_|
   // and returns true.
   bool EnterStateOrFallBackToSoftwareMirroring(
-      OutputState output_state,
+      gfx::NativeDisplayBridge::OutputState output_state,
       DisplayPowerState power_state);
 
   // Switches to the state specified in |output_state| and |power_state|.
   // On success, updates |output_state_|, |power_state_|, and
   // |cached_outputs_| and returns true.
-  bool EnterState(OutputState output_state, DisplayPowerState power_state);
+  bool EnterState(gfx::NativeDisplayBridge::OutputState output_state,
+                  DisplayPowerState power_state);
 
   // Returns the output state that should be used with |cached_outputs_| while
   // in |power_state|.
-  OutputState ChooseOutputState(DisplayPowerState power_state) const;
+  gfx::NativeDisplayBridge::OutputState ChooseOutputState(
+      DisplayPowerState power_state) const;
 
   // Computes the relevant transformation for mirror mode.
   // |output| is the output on which mirror mode is being applied.
   // Returns the transformation or identity if computations fail.
-  CoordinateTransformation GetMirrorModeCTM(
-      const OutputConfigurator::OutputSnapshot& output);
+  gfx::Matrix3F GetMirrorModeCTM(const gfx::DisplaySnapshot& output);
 
   // Computes the relevant transformation for extended mode.
   // |output| is the output on which extended mode is being applied.
   // |width| and |height| are the width and height of the combined framebuffer.
   // Returns the transformation or identity if computations fail.
-  CoordinateTransformation GetExtendedModeCTM(
-      const OutputConfigurator::OutputSnapshot& output,
-      int framebuffer_width,
-      int frame_buffer_height);
+  gfx::Matrix3F GetExtendedModeCTM(const gfx::DisplaySnapshot& output,
+                                   int framebuffer_width,
+                                   int frame_buffer_height);
 
   // Returns the ratio between mirrored mode area and native mode area:
   // (mirror_mode_width * mirrow_mode_height) / (native_width * native_height)
-  float GetMirroredDisplayAreaRatio(
-      const OutputConfigurator::OutputSnapshot& output);
+  float GetMirroredDisplayAreaRatio(const gfx::DisplaySnapshot& output);
 
   // Applies output protections according to requests.
   bool ApplyProtections(const DisplayProtections& requests);
@@ -511,7 +315,8 @@ class CHROMEOS_EXPORT OutputConfigurator
 
   StateController* state_controller_;
   SoftwareMirroringController* mirroring_controller_;
-  scoped_ptr<Delegate> delegate_;
+  scoped_ptr<gfx::NativeDisplayBridge> delegate_;
+  scoped_ptr<ProjectionDelegate> projection_delegate_;
 
   // Used to enable modes which rely on panel fitting.
   bool is_panel_fitting_enabled_;
@@ -531,19 +336,15 @@ class CHROMEOS_EXPORT OutputConfigurator
   // configuration to immediately fail without changing the state.
   bool configure_display_;
 
-  // The base of the event numbers used to represent XRandr events used in
-  // decoding events regarding output add/remove.
-  int xrandr_event_base_;
-
   // The current display state.
-  OutputState output_state_;
+  gfx::NativeDisplayBridge::OutputState output_state_;
 
   // The current power state.
   DisplayPowerState power_state_;
 
   // Most-recently-used output configuration. Note that the actual
   // configuration changes asynchronously.
-  std::vector<OutputSnapshot> cached_outputs_;
+  ScopedVector<gfx::DisplaySnapshot> cached_outputs_;
 
   ObserverList<Observer> observers_;
 
@@ -563,8 +364,6 @@ class CHROMEOS_EXPORT OutputConfigurator
   DISALLOW_COPY_AND_ASSIGN(OutputConfigurator);
 };
 
-typedef std::vector<OutputConfigurator::OutputSnapshot> OutputSnapshotList;
-
 }  // namespace chromeos
 
 #endif  // CHROMEOS_DISPLAY_OUTPUT_CONFIGURATOR_H_
diff --git a/chromeos/display/output_configurator_unittest.cc b/chromeos/display/output_configurator_unittest.cc
index 7c74bd3..531b9a4 100644
--- a/chromeos/display/output_configurator_unittest.cc
+++ b/chromeos/display/output_configurator_unittest.cc
@@ -15,15 +15,16 @@
 #include "base/message_loop/message_loop.h"
 #include "base/strings/stringprintf.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/display_snapshot.h"
 
 namespace chromeos {
 
 namespace {
 
-// Strings returned by TestDelegate::GetActionsAndClear() to describe various
+// Strings returned by TestNativeDisplayBridge::GetActionsAndClear() to describe
+// various
 // actions that were performed.
 const char kInitXRandR[] = "init";
-const char kUpdateXRandR[] = "update";
 const char kGrab[] = "grab";
 const char kUngrab[] = "ungrab";
 const char kSync[] = "sync";
@@ -31,56 +32,68 @@ const char kForceDPMS[] = "dpms";
 const char kProjectingOn[] = "projecting";
 const char kProjectingOff[] = "not_projecting";
 
-// String returned by TestDelegate::GetActionsAndClear() if no actions were
+// String returned by TestNativeDisplayBridge::GetActionsAndClear() if no
+// actions were
 // requested.
 const char kNoActions[] = "";
 
-// Returns a string describing a TestDelegate::SetBackgroundColor() call.
+// Returns a string describing a TestNativeDisplayBridge::SetBackgroundColor()
+// call.
 std::string GetBackgroundAction(uint32 color_argb) {
   return base::StringPrintf("background(0x%x)", color_argb);
 }
 
-// Returns a string describing a TestDelegate::AddOutputMode() call.
-std::string GetAddOutputModeAction(RROutput output, RRMode mode) {
-  return base::StringPrintf("add_mode(output=%lu,mode=%lu)", output, mode);
+// Returns a string describing a TestNativeDisplayBridge::AddOutputMode() call.
+std::string GetAddOutputModeAction(const gfx::DisplaySnapshot& output,
+                                   const gfx::ModeInfo& mode) {
+  return base::StringPrintf("add_mode(display=%lu,mode=(%s))",
+                            output.get_display_id(),
+                            mode.ToString().c_str());
 }
 
-// Returns a string describing a TestDelegate::ConfigureCrtc() call.
-std::string GetCrtcAction(RRCrtc crtc,
-                          int x,
-                          int y,
-                          RRMode mode,
-                          RROutput output) {
-  return base::StringPrintf("crtc(crtc=%lu,x=%d,y=%d,mode=%lu,output=%lu)",
-                            crtc, x, y, mode, output);
+// Returns a string describing a TestNativeDisplayBridge::ConfigureCrtc() call.
+std::string GetConfigureAction(const gfx::DisplaySnapshot& output,
+                               int x,
+                               int y,
+                               const gfx::ModeInfo* mode) {
+  return base::StringPrintf("display(display_id=%lu,x=%d,y=%d,mode=%s)",
+                            output.get_display_id(),
+                            x,
+                            y,
+                            mode ? mode->ToString().c_str() : "0");
 }
 
-// Returns a string describing a TestDelegate::CreateFramebuffer() call.
+// Returns a string describing a TestNativeDisplayBridge::CreateFramebuffer()
+// call.
 std::string GetFramebufferAction(int width,
                                  int height,
-                                 RRCrtc crtc1,
-                                 RRCrtc crtc2) {
+                                 uint64_t crtc1,
+                                 uint64_t crtc2) {
   return base::StringPrintf(
       "framebuffer(width=%d,height=%d,crtc1=%lu,crtc2=%lu)",
       width, height, crtc1, crtc2);
 }
 
-// Returns a string describing a TestDelegate::ConfigureCTM() call.
-std::string GetCTMAction(
-    int device_id,
-    const OutputConfigurator::CoordinateTransformation& ctm) {
-  return base::StringPrintf("ctm(id=%d,transform=(%f,%f,%f,%f))", device_id,
-      ctm.x_scale, ctm.x_offset, ctm.y_scale, ctm.y_offset);
+// Returns a string describing a TestNativeDisplayBridge::ConfigureCTM() call.
+std::string GetCTMAction(int device_id, const gfx::Matrix3F& ctm) {
+  return base::StringPrintf("ctm(id=%d,transform=(%f,%f,%f,%f))",
+                            device_id,
+                            ctm.get(0, 0),
+                            ctm.get(0, 2),
+                            ctm.get(1, 1),
+                            ctm.get(1, 2));
 }
 
-// Returns a string describing a TestDelegate::SetHDCPState() call.
-std::string GetSetHDCPStateAction(RROutput id, HDCPState state) {
-  return base::StringPrintf("set_hdcp(id=%lu,state=%d)", id, state);
+// Returns a string describing a TestNativeDisplayBridge::SetHDCPState() call.
+std::string GetSetHDCPStateAction(const gfx::DisplaySnapshot& output,
+                                  gfx::NativeDisplayBridge::HDCPState state) {
+  return base::StringPrintf(
+      "set_hdcp(id=%lu,state=%d)", output.get_display_id(), state);
 }
 
 // Joins a sequence of strings describing actions (e.g. kScreenDim) such
 // that they can be compared against a string returned by
-// TestDelegate::GetActionsAndClear().  The list of actions must be
+// TestNativeDisplayBridge::GetActionsAndClear().  The list of actions must be
 // terminated by a NULL pointer.
 std::string JoinActions(const char* action, ...) {
   std::string actions;
@@ -97,29 +110,16 @@ std::string JoinActions(const char* action, ...) {
   return actions;
 }
 
-class TestDelegate : public OutputConfigurator::Delegate {
+class TestAction {
  public:
-  static const int kXRandREventBase = 10;
-
-  TestDelegate()
-      : max_configurable_pixels_(0),
-        hdcp_state_(HDCP_STATE_UNDESIRED) {}
-  virtual ~TestDelegate() {}
-
-  const std::vector<OutputConfigurator::OutputSnapshot>& outputs() const {
-    return outputs_;
-  }
-  void set_outputs(
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-    outputs_ = outputs;
-  }
+  TestAction() {}
 
-  void set_max_configurable_pixels(int pixels) {
-    max_configurable_pixels_ = pixels;
+  void AppendAction(const std::string& action) {
+    if (!actions_.empty())
+      actions_ += ",";
+    actions_ += action;
   }
 
-  void set_hdcp_state(HDCPState state) { hdcp_state_ = state; }
-
   // Returns a comma-separated string describing the actions that were
   // requested since the previous call to GetActionsAndClear() (i.e.
   // results are non-repeatable).
@@ -129,120 +129,154 @@ class TestDelegate : public OutputConfigurator::Delegate {
     return actions;
   }
 
-  const OutputConfigurator::CoordinateTransformation& get_ctm(
-      int touch_device_id) {
-    return ctms_[touch_device_id];
+ private:
+  std::string actions_;
+  DISALLOW_COPY_AND_ASSIGN(TestAction);
+};
+
+class TestProjectionDelegate
+    : public chromeos::OutputConfigurator::ProjectionDelegate {
+ public:
+  TestProjectionDelegate(TestAction* actions) : actions_(actions) {}
+  virtual ~TestProjectionDelegate() {}
+
+  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE {
+    actions_->AppendAction(projecting ? kProjectingOn : kProjectingOff);
   }
 
-  // OutputConfigurator::Delegate overrides:
-  virtual void InitXRandRExtension(int* event_base) OVERRIDE {
-    AppendAction(kInitXRandR);
-    *event_base = kXRandREventBase;
+ private:
+  TestAction* actions_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestProjectionDelegate);
+};
+
+class TestNativeDisplayBridge : public gfx::NativeDisplayBridge {
+ public:
+  static const int kXRandREventBase = 10;
+
+  TestNativeDisplayBridge(TestAction* actions)
+      : max_configurable_pixels_(0),
+        hdcp_state_(gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED),
+        actions_(actions) {}
+  virtual ~TestNativeDisplayBridge() {}
+
+  void set_outputs(const std::vector<gfx::DisplaySnapshot*>& outputs) {
+    outputs_.clear();
+    for (std::vector<gfx::DisplaySnapshot*>::const_iterator it =
+             outputs.begin();
+         it != outputs.end();
+         ++it)
+      outputs_.push_back((*it)->Clone());
+  }
+
+  void set_max_configurable_pixels(int pixels) {
+    max_configurable_pixels_ = pixels;
   }
-  virtual void UpdateXRandRConfiguration(
-      const base::NativeEvent& event) OVERRIDE { AppendAction(kUpdateXRandR); }
-  virtual void GrabServer() OVERRIDE { AppendAction(kGrab); }
-  virtual void UngrabServer() OVERRIDE { AppendAction(kUngrab); }
-  virtual void SyncWithServer() OVERRIDE { AppendAction(kSync); }
+
+  void set_hdcp_state(gfx::NativeDisplayBridge::HDCPState state) {
+    hdcp_state_ = state;
+  }
+
+  const gfx::Matrix3F& get_ctm(int touch_device_id) {
+    return ctms_.at(touch_device_id);
+  }
+
+  // OutputConfigurator::Delegate overrides:
+  virtual void Initialize() OVERRIDE { actions_->AppendAction(kInitXRandR); }
+  virtual void Lock() OVERRIDE { actions_->AppendAction(kGrab); }
+  virtual void Unlock() OVERRIDE { actions_->AppendAction(kUngrab); }
+  virtual void Flush() OVERRIDE { actions_->AppendAction(kSync); }
   virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE {
-    AppendAction(GetBackgroundAction(color_argb));
+    actions_->AppendAction(GetBackgroundAction(color_argb));
   }
-  virtual void ForceDPMSOn() OVERRIDE { AppendAction(kForceDPMS); }
-  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs()
+  virtual void SetDPMS(gfx::NativeDisplayBridge::DPMSState state) OVERRIDE {
+    actions_->AppendAction(kForceDPMS);
+  }
+  virtual void GetOutputs(ScopedVector<gfx::DisplaySnapshot>& outputs)
       OVERRIDE {
-    return outputs_;
+    for (ScopedVector<gfx::DisplaySnapshot>::iterator it = outputs_.begin();
+         it != outputs_.end();
+         ++it) {
+      outputs.push_back((*it)->Clone());
+    }
   }
-  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE {
-    AppendAction(GetAddOutputModeAction(output, mode));
+  virtual void AddMode(const gfx::DisplaySnapshot& output,
+                       const gfx::ModeInfo& mode) OVERRIDE {
+    actions_->AppendAction(GetAddOutputModeAction(output, mode));
   }
-  virtual bool ConfigureCrtc(RRCrtc crtc,
-                             RRMode mode,
-                             RROutput output,
-                             int x,
-                             int y) OVERRIDE {
-    AppendAction(GetCrtcAction(crtc, x, y, mode, output));
+  virtual bool Configure(const gfx::DisplaySnapshot& output) OVERRIDE {
+    actions_->AppendAction(GetConfigureAction(output,
+                                              output.get_origin().x(),
+                                              output.get_origin().y(),
+                                              output.get_current_mode()));
 
     if (max_configurable_pixels_ == 0)
       return true;
 
-    OutputConfigurator::OutputSnapshot* snapshot = GetOutputFromId(output);
-    if (!snapshot)
-      return false;
-
-    const OutputConfigurator::ModeInfo* mode_info =
-        OutputConfigurator::GetModeInfo(*snapshot, mode);
+    const gfx::ModeInfo* mode_info = output.get_current_mode();
     if (!mode_info)
       return false;
 
-    return mode_info->width * mode_info->height <= max_configurable_pixels_;
-
+    return mode_info->get_size().width() * mode_info->get_size().height() <=
+           max_configurable_pixels_;
   }
   virtual void CreateFrameBuffer(
       int width,
       int height,
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE {
-    AppendAction(
-        GetFramebufferAction(width,
-                             height,
-                             outputs.size() >= 1 ? outputs[0].crtc : 0,
-                             outputs.size() >= 2 ? outputs[1].crtc : 0));
-  }
-  virtual void ConfigureCTM(
-      int touch_device_id,
-      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE {
-    AppendAction(GetCTMAction(touch_device_id, ctm));
-    ctms_[touch_device_id] = ctm;
+      const ScopedVector<gfx::DisplaySnapshot>& outputs) OVERRIDE {
+    actions_->AppendAction(GetFramebufferAction(
+        width,
+        height,
+        outputs.size() >= 1 ? outputs[0]->get_display_id() : 0,
+        outputs.size() >= 2 ? outputs[1]->get_display_id() : 0));
   }
-  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE {
-    AppendAction(projecting ? kProjectingOn : kProjectingOff);
+  virtual void ConfigureCTM(int touch_device_id,
+                            const gfx::Matrix3F& ctm) OVERRIDE {
+    actions_->AppendAction(GetCTMAction(touch_device_id, ctm));
+    ctms_.insert(std::pair<int, gfx::Matrix3F>(touch_device_id, ctm));
   }
 
-  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE {
+  virtual bool GetHDCPState(const gfx::DisplaySnapshot& output,
+                            gfx::NativeDisplayBridge::HDCPState* state)
+      OVERRIDE {
     *state = hdcp_state_;
     return true;
   }
 
-  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE {
-    AppendAction(GetSetHDCPStateAction(id, state));
+  virtual bool SetHDCPState(const gfx::DisplaySnapshot& output,
+                            gfx::NativeDisplayBridge::HDCPState state)
+      OVERRIDE {
+    actions_->AppendAction(GetSetHDCPStateAction(output, state));
     return true;
   }
 
- private:
-  struct ModeDetails {
-    ModeDetails() : width(0), height(0), interlaced(false) {}
-    ModeDetails(int width, int height, bool interlaced)
-        : width(width),
-          height(height),
-          interlaced(interlaced) {}
-
-    int width;
-    int height;
-    bool interlaced;
-  };
+  virtual void AddObserver(gfx::NativeDisplayBridge::Observer* o) OVERRIDE {
+    observer_list_.AddObserver(o);
+  }
 
-  void AppendAction(const std::string& action) {
-    if (!actions_.empty())
-      actions_ += ",";
-    actions_ += action;
+  virtual void RemoveObserver(gfx::NativeDisplayBridge::Observer* o) OVERRIDE {
+    observer_list_.RemoveObserver(o);
   }
 
-  OutputConfigurator::OutputSnapshot* GetOutputFromId(RROutput output_id) {
-    for (unsigned int i = 0; i < outputs_.size(); i++) {
-      if (outputs_[i].output == output_id)
-        return &outputs_[i];
+  void SendOutputChangeEvent(const gfx::DisplaySnapshot& display,
+                             bool connected) {
+    if (connected) {
+      FOR_EACH_OBSERVER(gfx::NativeDisplayBridge::Observer,
+                        observer_list_,
+                        OnDisplayAdded(display));
+    } else {
+      FOR_EACH_OBSERVER(gfx::NativeDisplayBridge::Observer,
+                        observer_list_,
+                        OnDisplayRemoved(display));
     }
-    return NULL;
   }
 
-  std::map<RRMode, ModeDetails> modes_;
-
+ private:
   // Most-recently-configured transformation matrices, keyed by touch device ID.
-  std::map<int, OutputConfigurator::CoordinateTransformation> ctms_;
+  std::map<int, gfx::Matrix3F> ctms_;
 
   // Outputs to be returned by GetOutputs().
-  std::vector<OutputConfigurator::OutputSnapshot> outputs_;
-
-  std::string actions_;
+  ScopedVector<gfx::DisplaySnapshot> outputs_;
 
   // |max_configurable_pixels_| represents the maximum number of pixels that
   // ConfigureCrtc will support.  Tests can use this to force ConfigureCrtc
@@ -253,9 +287,13 @@ class TestDelegate : public OutputConfigurator::Delegate {
   int  max_configurable_pixels_;
 
   // Result value of GetHDCPState().
-  HDCPState hdcp_state_;
+  gfx::NativeDisplayBridge::HDCPState hdcp_state_;
+
+  TestAction* actions_;
 
-  DISALLOW_COPY_AND_ASSIGN(TestDelegate);
+  ObserverList<gfx::NativeDisplayBridge::Observer> observer_list_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestNativeDisplayBridge);
 };
 
 class TestObserver : public OutputConfigurator::Observer {
@@ -271,28 +309,34 @@ class TestObserver : public OutputConfigurator::Observer {
 
   int num_changes() const { return num_changes_; }
   int num_failures() const { return num_failures_; }
-  const std::vector<OutputConfigurator::OutputSnapshot>& latest_outputs()
-      const {
+  const std::vector<gfx::DisplaySnapshot*>& latest_outputs() const {
     return latest_outputs_;
   }
-  OutputState latest_failed_state() const { return latest_failed_state_; }
+  gfx::NativeDisplayBridge::OutputState latest_failed_state() const {
+    return latest_failed_state_;
+  }
 
   void Reset() {
     num_changes_ = 0;
     num_failures_ = 0;
     latest_outputs_.clear();
-    latest_failed_state_ = STATE_INVALID;
+    latest_failed_state_ = gfx::NativeDisplayBridge::STATE_INVALID;
   }
 
   // OutputConfigurator::Observer overrides:
   virtual void OnDisplayModeChanged(
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE {
+      const ScopedVector<gfx::DisplaySnapshot>& outputs) OVERRIDE {
     num_changes_++;
-    latest_outputs_ = outputs;
+    for (ScopedVector<gfx::DisplaySnapshot>::const_iterator it =
+             outputs.begin();
+         it != outputs.end();
+         ++it) {
+      latest_outputs_.push_back(*it);
+    }
   }
 
-  virtual void OnDisplayModeChangeFailed(OutputState failed_new_state)
-      OVERRIDE {
+  virtual void OnDisplayModeChangeFailed(
+      gfx::NativeDisplayBridge::OutputState failed_new_state) OVERRIDE {
     num_failures_++;
     latest_failed_state_ = failed_new_state;
   }
@@ -305,22 +349,27 @@ class TestObserver : public OutputConfigurator::Observer {
   int num_failures_;
 
   // Parameters most recently passed to OnDisplayMode*().
-  std::vector<OutputConfigurator::OutputSnapshot> latest_outputs_;
-  OutputState latest_failed_state_;
+  std::vector<gfx::DisplaySnapshot*> latest_outputs_;
+  gfx::NativeDisplayBridge::OutputState latest_failed_state_;
 
   DISALLOW_COPY_AND_ASSIGN(TestObserver);
 };
 
 class TestStateController : public OutputConfigurator::StateController {
  public:
-  TestStateController() : state_(STATE_DUAL_EXTENDED) {}
+  TestStateController()
+      : state_(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED) {}
   virtual ~TestStateController() {}
 
-  void set_state(OutputState state) { state_ = state; }
+  void set_state(gfx::NativeDisplayBridge::OutputState state) {
+    state_ = state;
+  }
 
   // OutputConfigurator::StateController overrides:
-  virtual OutputState GetStateForDisplayIds(
-      const std::vector<int64>& outputs) const OVERRIDE { return state_; }
+  virtual gfx::NativeDisplayBridge::OutputState GetStateForDisplayIds(
+      const std::vector<int64>& outputs) const OVERRIDE {
+    return state_;
+  }
   virtual bool GetResolutionForDisplayId(
       int64 display_id,
       int *width,
@@ -329,7 +378,7 @@ class TestStateController : public OutputConfigurator::StateController {
   }
 
  private:
-  OutputState state_;
+  gfx::NativeDisplayBridge::OutputState state_;
 
   DISALLOW_COPY_AND_ASSIGN(TestStateController);
 };
@@ -357,58 +406,42 @@ class TestMirroringController
 class OutputConfiguratorTest : public testing::Test {
  public:
   // Predefined modes that can be used by outputs.
-  static const RRMode kSmallModeId;
-  static const int kSmallModeWidth;
-  static const int kSmallModeHeight;
-
-  static const RRMode kBigModeId;
-  static const int kBigModeWidth;
-  static const int kBigModeHeight;
+  static const gfx::ModeInfo kSmallMode;
+  static const gfx::ModeInfo kBigMode;
 
   OutputConfiguratorTest()
-      : observer_(&configurator_),
-        test_api_(&configurator_, TestDelegate::kXRandREventBase) {}
+      : observer_(&configurator_), test_api_(&configurator_) {}
   virtual ~OutputConfiguratorTest() {}
 
   virtual void SetUp() OVERRIDE {
-    delegate_ = new TestDelegate();
+    actions_.reset(new TestAction());
+    delegate_ = new TestNativeDisplayBridge(actions_.get());
     configurator_.SetDelegateForTesting(
-        scoped_ptr<OutputConfigurator::Delegate>(delegate_));
+        scoped_ptr<gfx::NativeDisplayBridge>(delegate_));
+    configurator_.SetProjectionDelegateForTesting(
+        scoped_ptr<chromeos::OutputConfigurator::ProjectionDelegate>(
+            new TestProjectionDelegate(actions_.get())));
     configurator_.set_state_controller(&state_controller_);
     configurator_.set_mirroring_controller(&mirroring_controller_);
 
-    OutputConfigurator::ModeInfo small_mode_info;
-    small_mode_info.width = kSmallModeWidth;
-    small_mode_info.height = kSmallModeHeight;
-
-    OutputConfigurator::ModeInfo big_mode_info;
-    big_mode_info.width = kBigModeWidth;
-    big_mode_info.height = kBigModeHeight;
-
-    OutputConfigurator::OutputSnapshot* o = &outputs_[0];
-    o->output = 1;
-    o->crtc = 10;
-    o->current_mode = kSmallModeId;
-    o->native_mode = kSmallModeId;
-    o->type = OUTPUT_TYPE_INTERNAL;
-    o->is_aspect_preserving_scaling = true;
-    o->mode_infos[kSmallModeId] = small_mode_info;
-    o->has_display_id = true;
-    o->display_id = 123;
-    o->index = 0;
+    gfx::DisplaySnapshot* o = &outputs_[0];
+    o->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL);
+    o->set_is_aspect_preserving_scaling(true);
+    o->get_mode_infos().push_back(kSmallMode.Clone());
+    o->set_current_mode(o->get_mode_infos().back());
+    o->set_native_mode(o->get_mode_infos().back());
+    o->set_display_id(123);
+    o->set_has_display_id(true);
 
     o = &outputs_[1];
-    o->output = 2;
-    o->crtc = 11;
-    o->current_mode = kBigModeId;
-    o->native_mode = kBigModeId;
-    o->type = OUTPUT_TYPE_HDMI;
-    o->is_aspect_preserving_scaling = true;
-    o->mode_infos[kSmallModeId] = small_mode_info;
-    o->mode_infos[kBigModeId] = big_mode_info;
-    o->has_display_id = true;
-    o->display_id = 456;
-    o->index = 1;
+    o->set_type(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI);
+    o->set_is_aspect_preserving_scaling(true);
+    o->get_mode_infos().push_back(kSmallMode.Clone());
+    o->get_mode_infos().push_back(kBigMode.Clone());
+    o->set_current_mode(o->get_mode_infos().back());
+    o->set_native_mode(o->get_mode_infos().back());
+    o->set_display_id(456);
+    o->set_has_display_id(true);
 
     UpdateOutputs(2, false);
   }
@@ -420,18 +453,15 @@ class OutputConfiguratorTest : public testing::Test {
   // timeout if one was scheduled.
   void UpdateOutputs(size_t num_outputs, bool send_events) {
     ASSERT_LE(num_outputs, arraysize(outputs_));
-    std::vector<OutputConfigurator::OutputSnapshot> outputs;
+    std::vector<gfx::DisplaySnapshot*> outputs;
     for (size_t i = 0; i < num_outputs; ++i)
-      outputs.push_back(outputs_[i]);
+      outputs.push_back(&outputs_[i]);
     delegate_->set_outputs(outputs);
 
     if (send_events) {
-      test_api_.SendScreenChangeEvent();
       for (size_t i = 0; i < arraysize(outputs_); ++i) {
-        const OutputConfigurator::OutputSnapshot output = outputs_[i];
         bool connected = i < num_outputs;
-        test_api_.SendOutputChangeEvent(
-            output.output, output.crtc, output.current_mode, connected);
+        delegate_->SendOutputChangeEvent(outputs_[i], connected);
       }
       test_api_.TriggerConfigureTimeout();
     }
@@ -440,17 +470,23 @@ class OutputConfiguratorTest : public testing::Test {
   // Initializes |configurator_| with a single internal display.
   void InitWithSingleOutput() {
     UpdateOutputs(1, false);
-    EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+    EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
     configurator_.Init(false);
-    EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+    EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
     configurator_.Start(0);
-    EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
-                          GetFramebufferAction(kSmallModeWidth,
-                              kSmallModeHeight, outputs_[0].crtc, 0).c_str(),
-                          GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                                        outputs_[0].output).c_str(),
-                          kForceDPMS, kUngrab, kProjectingOff, NULL),
-              delegate_->GetActionsAndClear());
+    EXPECT_EQ(
+        JoinActions(kGrab,
+                    kInitXRandR,
+                    GetFramebufferAction(kSmallMode.get_size().width(),
+                                         kSmallMode.get_size().height(),
+                                         outputs_[0].get_display_id(),
+                                         0).c_str(),
+                    GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                    kForceDPMS,
+                    kUngrab,
+                    kProjectingOff,
+                    NULL),
+        actions_->GetActionsAndClear());
   }
 
   base::MessageLoop message_loop_;
@@ -458,83 +494,79 @@ class OutputConfiguratorTest : public testing::Test {
   TestMirroringController mirroring_controller_;
   OutputConfigurator configurator_;
   TestObserver observer_;
-  TestDelegate* delegate_;  // not owned
+  TestNativeDisplayBridge* delegate_;  // not owned
   OutputConfigurator::TestApi test_api_;
+  scoped_ptr<TestAction> actions_;
 
-  OutputConfigurator::OutputSnapshot outputs_[2];
+  gfx::DisplaySnapshot outputs_[2];
 
  private:
   DISALLOW_COPY_AND_ASSIGN(OutputConfiguratorTest);
 };
 
-const RRMode OutputConfiguratorTest::kSmallModeId = 20;
-const int OutputConfiguratorTest::kSmallModeWidth = 1366;
-const int OutputConfiguratorTest::kSmallModeHeight = 768;
-
-const RRMode OutputConfiguratorTest::kBigModeId = 21;
-const int OutputConfiguratorTest::kBigModeWidth = 2560;
-const int OutputConfiguratorTest::kBigModeHeight = 1600;
+const gfx::ModeInfo OutputConfiguratorTest::kSmallMode(1366, 768, false, 0.0);
+const gfx::ModeInfo OutputConfiguratorTest::kBigMode(2560, 1600, false, 0.0);
 
 }  // namespace
 
 TEST_F(OutputConfiguratorTest, FindOutputModeMatchingSize) {
-  OutputConfigurator::OutputSnapshot output;
+  gfx::DisplaySnapshot output;
 
+  int index = output.get_mode_infos().size();
   // Fields are width, height, interlaced, refresh rate.
-  output.mode_infos[11] = OutputConfigurator::ModeInfo(1920, 1200, false, 60.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1920, 1200, false, 60.0));
   // Different rates.
-  output.mode_infos[12] = OutputConfigurator::ModeInfo(1920, 1080, false, 30.0);
-  output.mode_infos[13] = OutputConfigurator::ModeInfo(1920, 1080, false, 50.0);
-  output.mode_infos[14] = OutputConfigurator::ModeInfo(1920, 1080, false, 40.0);
-  output.mode_infos[15] = OutputConfigurator::ModeInfo(1920, 1080, false, 0.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1920, 1080, false, 30.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1920, 1080, false, 50.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1920, 1080, false, 40.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1920, 1080, false, 0.0));
   // Interlaced vs non-interlaced.
-  output.mode_infos[16] = OutputConfigurator::ModeInfo(1280, 720, true, 60.0);
-  output.mode_infos[17] = OutputConfigurator::ModeInfo(1280, 720, false, 40.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1280, 720, true, 60.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1280, 720, false, 40.0));
   // Interlaced only.
-  output.mode_infos[18] = OutputConfigurator::ModeInfo(1024, 768, true, 0.0);
-  output.mode_infos[19] = OutputConfigurator::ModeInfo(1024, 768, true, 40.0);
-  output.mode_infos[20] = OutputConfigurator::ModeInfo(1024, 768, true, 60.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 768, true, 0.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 768, true, 40.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 768, true, 60.0));
   // Mixed.
-  output.mode_infos[21] = OutputConfigurator::ModeInfo(1024, 600, true, 60.0);
-  output.mode_infos[22] = OutputConfigurator::ModeInfo(1024, 600, false, 40.0);
-  output.mode_infos[23] = OutputConfigurator::ModeInfo(1024, 600, false, 50.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 600, true, 60.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 600, false, 40.0));
+  output.get_mode_infos().push_back(new gfx::ModeInfo(1024, 600, false, 50.0));
   // Just one interlaced mode.
-  output.mode_infos[24] = OutputConfigurator::ModeInfo(640, 480, true, 60.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(640, 480, true, 60.0));
   // Refresh rate not available.
-  output.mode_infos[25] = OutputConfigurator::ModeInfo(320, 200, false, 0.0);
+  output.get_mode_infos().push_back(new gfx::ModeInfo(320, 200, false, 0.0));
 
-  EXPECT_EQ(11u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                1920, 1200));
+  EXPECT_EQ(output.get_mode_infos()[index],
+            output.FindOutputModeMatchingSize(1920, 1200));
 
   // Should pick highest refresh rate.
-  EXPECT_EQ(13u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                1920, 1080));
+  EXPECT_EQ(output.get_mode_infos()[index + 2],
+            output.FindOutputModeMatchingSize(1920, 1080));
 
   // Should pick non-interlaced mode.
-  EXPECT_EQ(17u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                1280, 720));
+  EXPECT_EQ(output.get_mode_infos()[index + 6],
+            output.FindOutputModeMatchingSize(1280, 720));
 
   // Interlaced only. Should pick one with the highest refresh rate in
   // interlaced mode.
-  EXPECT_EQ(20u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                1024, 768));
+  EXPECT_EQ(output.get_mode_infos()[index + 9],
+            output.FindOutputModeMatchingSize(1024, 768));
 
   // Mixed: Should pick one with the highest refresh rate in
   // interlaced mode.
-  EXPECT_EQ(23u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                1024, 600));
+  EXPECT_EQ(output.get_mode_infos()[index + 12],
+            output.FindOutputModeMatchingSize(1024, 600));
 
   // Just one interlaced mode.
-  EXPECT_EQ(24u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                640, 480));
+  EXPECT_EQ(output.get_mode_infos()[index + 13],
+            output.FindOutputModeMatchingSize(640, 480));
 
   // Refresh rate not available.
-  EXPECT_EQ(25u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                                320, 200));
+  EXPECT_EQ(output.get_mode_infos()[index + 14],
+            output.FindOutputModeMatchingSize(320, 200));
 
   // No mode found.
-  EXPECT_EQ(0u, OutputConfigurator::FindOutputModeMatchingSize(output,
-                                                               1440, 900));
+  EXPECT_EQ(NULL, output.FindOutputModeMatchingSize(1440, 900));
 }
 
 TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
@@ -543,99 +575,127 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
   // Connect a second output and check that the configurator enters
   // extended mode.
   observer_.Reset();
-  state_controller_.set_state(STATE_DUAL_EXTENDED);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED);
   UpdateOutputs(2, true);
-  const int kDualHeight =
-      kSmallModeHeight + OutputConfigurator::kVerticalGap + kBigModeHeight;
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kBigModeWidth, kDualHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            kSmallModeHeight + OutputConfigurator::kVerticalGap,
-                            kBigModeId, outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  const int kDualHeight = kSmallMode.get_size().height() +
+                          OutputConfigurator::kVerticalGap +
+                          kBigMode.get_size().height();
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kDualHeight,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kBigMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   observer_.Reset();
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Disconnect the second output.
   observer_.Reset();
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kUngrab, kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOff,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Get rid of shared modes to force software mirroring.
-  outputs_[1].mode_infos.erase(kSmallModeId);
-  state_controller_.set_state(STATE_DUAL_EXTENDED);
+  outputs_[1].get_mode_infos().erase(outputs_[1].get_mode_infos().begin());
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kBigModeWidth, kDualHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            kSmallModeHeight + OutputConfigurator::kVerticalGap,
-                            kBigModeId, outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kDualHeight,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kBigMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
 
   observer_.Reset();
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL), delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL), actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
   EXPECT_TRUE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Setting STATE_DUAL_MIRROR should try to reconfigure.
   observer_.Reset();
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_EXTENDED));
-  EXPECT_EQ(JoinActions(NULL), delegate_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED));
+  EXPECT_EQ(JoinActions(NULL), actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Set back to software mirror mode.
   observer_.Reset();
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL), actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
   EXPECT_TRUE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Disconnect the second output.
   observer_.Reset();
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kUngrab, kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOff,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 }
@@ -643,18 +703,21 @@ TEST_F(OutputConfiguratorTest, ConnectSecondOutput) {
 TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   InitWithSingleOutput();
 
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   observer_.Reset();
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
@@ -663,16 +726,20 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_INTERNAL_OFF_EXTERNAL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kBigModeWidth, kBigModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kBigModeId,
-                            outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_SINGLE, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kBigMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, NULL).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kBigMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_SINGLE,
+            configurator_.output_state());
   EXPECT_EQ(1, observer_.num_changes());
 
   // When all displays are turned off, the framebuffer should switch back
@@ -680,16 +747,19 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, 0,
-                            outputs_[1].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_MIRROR, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, NULL).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, NULL).c_str(),
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR,
+            configurator_.output_state());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
@@ -697,37 +767,49 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_MIRROR, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR,
+            configurator_.output_state());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
   // Get rid of shared modes to force software mirroring.
-  outputs_[1].mode_infos.erase(kSmallModeId);
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  outputs_[1].get_mode_infos().erase(outputs_[1].get_mode_infos().begin());
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   observer_.Reset();
   UpdateOutputs(2, true);
-  const int kDualHeight =
-      kSmallModeHeight + OutputConfigurator::kVerticalGap + kBigModeHeight;
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kBigModeWidth, kDualHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            kSmallModeHeight + OutputConfigurator::kVerticalGap,
-                            kBigModeId, outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  const int kDualHeight = kSmallMode.get_size().height() +
+                          OutputConfigurator::kVerticalGap +
+                          kBigMode.get_size().height();
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kDualHeight,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kBigMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
   EXPECT_TRUE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
@@ -736,16 +818,20 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_INTERNAL_OFF_EXTERNAL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kBigModeWidth, kBigModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kBigModeId,
-                            outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_SINGLE, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kBigMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, NULL).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kBigMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_SINGLE,
+            configurator_.output_state());
   EXPECT_FALSE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
@@ -754,17 +840,23 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kBigModeWidth, kDualHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            kSmallModeHeight + OutputConfigurator::kVerticalGap,
-                            0, outputs_[1].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kDualHeight,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, NULL).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     NULL).c_str(),
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
   EXPECT_TRUE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 
@@ -772,17 +864,24 @@ TEST_F(OutputConfiguratorTest, SetDisplayPower) {
   observer_.Reset();
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kBigModeWidth, kDualHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            kSmallModeHeight + OutputConfigurator::kVerticalGap,
-                            kBigModeId, outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kDualHeight,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kBigMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
   EXPECT_TRUE(mirroring_controller_.software_mirroring_enabled());
   EXPECT_EQ(1, observer_.num_changes());
 }
@@ -792,40 +891,46 @@ TEST_F(OutputConfiguratorTest, Casting) {
 
   // Notify configurator that casting session is started.
   configurator_.OnCastingSessionStartedOrStopped(true);
-  EXPECT_EQ(kProjectingOn, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kProjectingOn, actions_->GetActionsAndClear());
 
   // Verify that the configurator keeps a count of active casting sessions
   // instead of treating it as a single global state.
   configurator_.OnCastingSessionStartedOrStopped(true);
-  EXPECT_EQ(kProjectingOn, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kProjectingOn, actions_->GetActionsAndClear());
   configurator_.OnCastingSessionStartedOrStopped(false);
-  EXPECT_EQ(kProjectingOn, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kProjectingOn, actions_->GetActionsAndClear());
 
   // Turn all displays off and check that projecting is not turned off.
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
   EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+                        GetFramebufferAction(kSmallMode.get_size().width(),
+                                             kSmallMode.get_size().height(),
+                                             outputs_[0].get_display_id(),
+                                             0).c_str(),
+                        GetConfigureAction(outputs_[0], 0, 0, 0).c_str(),
+                        kUngrab,
+                        NULL),
+            actions_->GetActionsAndClear());
 
   // Turn all displays back on.
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // Notify configurator that casting session is ended.
   configurator_.OnCastingSessionStartedOrStopped(false);
-  EXPECT_EQ(kProjectingOff, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kProjectingOff, actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, SuspendAndResume) {
@@ -835,189 +940,234 @@ TEST_F(OutputConfiguratorTest, SuspendAndResume) {
   // on.  The configurator should still reprobe on resume in case a display
   // was connected while suspended.
   configurator_.SuspendDisplays();
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
   configurator_.ResumeDisplays();
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // Now turn the display off before suspending and check that the
   // configurator turns it back on and syncs with the server.
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
   EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+                        GetFramebufferAction(kSmallMode.get_size().width(),
+                                             kSmallMode.get_size().height(),
+                                             outputs_[0].get_display_id(),
+                                             0).c_str(),
+                        GetConfigureAction(outputs_[0], 0, 0, NULL).c_str(),
+                        kUngrab,
+                        NULL),
+            actions_->GetActionsAndClear());
 
   configurator_.SuspendDisplays();
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kForceDPMS, kUngrab, kSync, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  kSync,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   configurator_.ResumeDisplays();
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // If a second, external display is connected, the displays shouldn't be
   // powered back on before suspending.
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, 0,
-                            outputs_[1].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, 0).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, 0).c_str(),
+                  kUngrab,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   configurator_.SuspendDisplays();
   EXPECT_EQ(JoinActions(kGrab, kUngrab, kSync, NULL),
-            delegate_->GetActionsAndClear());
+            actions_->GetActionsAndClear());
 
   // If a display is disconnected while suspended, the configurator should
   // pick up the change.
   UpdateOutputs(1, false);
   configurator_.ResumeDisplays();
   EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, 0,
-                            outputs_[0].output).c_str(),
-                        kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+                        GetFramebufferAction(kSmallMode.get_size().width(),
+                                             kSmallMode.get_size().height(),
+                                             outputs_[0].get_display_id(),
+                                             0).c_str(),
+                        GetConfigureAction(outputs_[0], 0, 0, 0).c_str(),
+                        kUngrab,
+                        NULL),
+            actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, Headless) {
   UpdateOutputs(0, false);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
   configurator_.Init(false);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
   configurator_.Start(0);
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR, kForceDPMS, kUngrab,
-                        kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(JoinActions(
+                kGrab, kInitXRandR, kForceDPMS, kUngrab, kProjectingOff, NULL),
+            actions_->GetActionsAndClear());
 
   // Not much should happen when the display power state is changed while
   // no displays are connected.
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_OFF,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
-  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL), delegate_->GetActionsAndClear());
+  EXPECT_EQ(JoinActions(kGrab, kUngrab, NULL), actions_->GetActionsAndClear());
   configurator_.SetDisplayPower(DISPLAY_POWER_ALL_ON,
                                 OutputConfigurator::kSetDisplayPowerNoFlags);
   EXPECT_EQ(JoinActions(kGrab, kForceDPMS, kUngrab, NULL),
-            delegate_->GetActionsAndClear());
+            actions_->GetActionsAndClear());
 
   // Connect an external display and check that it's configured correctly.
   outputs_[0] = outputs_[1];
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kBigModeWidth, kBigModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kBigModeId,
-                            outputs_[0].output).c_str(),
-                        kUngrab, kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kBigMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kBigMode).c_str(),
+                  kUngrab,
+                  kProjectingOff,
+                  NULL),
+      actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, StartWithTwoOutputs) {
   UpdateOutputs(2, false);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
   configurator_.Init(false);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   configurator_.Start(0);
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  kInitXRandR,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, InvalidOutputStates) {
   UpdateOutputs(0, false);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
   configurator_.Init(false);
   configurator_.Start(0);
   observer_.Reset();
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_HEADLESS));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_SINGLE));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_DUAL_EXTENDED));
+  EXPECT_TRUE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_HEADLESS));
+  EXPECT_FALSE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_SINGLE));
+  EXPECT_FALSE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_FALSE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED));
   EXPECT_EQ(1, observer_.num_changes());
   EXPECT_EQ(3, observer_.num_failures());
 
   UpdateOutputs(1, true);
   observer_.Reset();
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_HEADLESS));
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_SINGLE));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_DUAL_EXTENDED));
+  EXPECT_FALSE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_HEADLESS));
+  EXPECT_TRUE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_SINGLE));
+  EXPECT_FALSE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_FALSE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED));
   EXPECT_EQ(1, observer_.num_changes());
   EXPECT_EQ(3, observer_.num_failures());
 
-  state_controller_.set_state(STATE_DUAL_EXTENDED);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED);
   UpdateOutputs(2, true);
   observer_.Reset();
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_HEADLESS));
-  EXPECT_FALSE(configurator_.SetDisplayMode(STATE_SINGLE));
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_MIRROR));
-  EXPECT_TRUE(configurator_.SetDisplayMode(STATE_DUAL_EXTENDED));
+  EXPECT_FALSE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_HEADLESS));
+  EXPECT_FALSE(
+      configurator_.SetDisplayMode(gfx::NativeDisplayBridge::STATE_SINGLE));
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_MIRROR));
+  EXPECT_TRUE(configurator_.SetDisplayMode(
+      gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED));
   EXPECT_EQ(2, observer_.num_changes());
   EXPECT_EQ(2, observer_.num_failures());
 }
 
 TEST_F(OutputConfiguratorTest, GetOutputStateForDisplaysWithoutId) {
-  outputs_[0].has_display_id = false;
+  outputs_[0].set_has_display_id(false);
   UpdateOutputs(2, false);
   configurator_.Init(false);
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   configurator_.Start(0);
-  EXPECT_EQ(STATE_DUAL_EXTENDED, configurator_.output_state());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED,
+            configurator_.output_state());
 }
 
 TEST_F(OutputConfiguratorTest, GetOutputStateForDisplaysWithId) {
-  outputs_[0].has_display_id = true;
+  outputs_[0].set_has_display_id(true);
   UpdateOutputs(2, false);
   configurator_.Init(false);
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   configurator_.Start(0);
-  EXPECT_EQ(STATE_DUAL_MIRROR, configurator_.output_state());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR,
+            configurator_.output_state());
 }
 
 TEST_F(OutputConfiguratorTest, AvoidUnnecessaryProbes) {
@@ -1026,180 +1176,210 @@ TEST_F(OutputConfiguratorTest, AvoidUnnecessaryProbes) {
   // X sends several events just after the configurator starts. Check that
   // the output change events don't trigger an additional probe, which can
   // block the UI thread.
-  test_api_.SendScreenChangeEvent();
-  EXPECT_EQ(kUpdateXRandR, delegate_->GetActionsAndClear());
+  EXPECT_EQ("", actions_->GetActionsAndClear());
 
-  test_api_.SendOutputChangeEvent(
-      outputs_[0].output, outputs_[0].crtc, outputs_[0].current_mode, true);
-  test_api_.SendOutputChangeEvent(
-      outputs_[1].output, outputs_[1].crtc, outputs_[1].current_mode, false);
+  delegate_->SendOutputChangeEvent(outputs_[0], true);
+  delegate_->SendOutputChangeEvent(outputs_[1], false);
   EXPECT_FALSE(test_api_.TriggerConfigureTimeout());
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
   // Send an event stating that the second output is connected and check
   // that it gets updated.
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   UpdateOutputs(2, false);
-  test_api_.SendOutputChangeEvent(
-      outputs_[1].output, outputs_[1].crtc, outputs_[1].current_mode, true);
+  delegate_->SendOutputChangeEvent(outputs_[1], true);
   EXPECT_TRUE(test_api_.TriggerConfigureTimeout());
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // An event about the second output changing modes should trigger another
   // reconfigure.
-  test_api_.SendOutputChangeEvent(
-      outputs_[1].output, outputs_[1].crtc, outputs_[1].native_mode, true);
+  delegate_->SendOutputChangeEvent(outputs_[1], true);
   EXPECT_TRUE(test_api_.TriggerConfigureTimeout());
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // Disconnect the second output.
   UpdateOutputs(1, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        kUngrab, kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOff,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // An additional event about the second output being disconnected should
   // be ignored.
-  test_api_.SendOutputChangeEvent(
-      outputs_[1].output, outputs_[1].crtc, outputs_[1].current_mode, false);
+  delegate_->SendOutputChangeEvent(outputs_[1], false);
   EXPECT_FALSE(test_api_.TriggerConfigureTimeout());
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
   // Lower the limit for which the delegate will succeed, which should result
   // in the second output sticking with its native mode.
   delegate_->set_max_configurable_pixels(1);
   UpdateOutputs(2, true);
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        GetFramebufferAction(kBigModeWidth,
-                            kSmallModeHeight + kBigModeHeight +
-                              OutputConfigurator::kVerticalGap,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, kSmallModeHeight +
-                            OutputConfigurator::kVerticalGap, kBigModeId,
-                            outputs_[1].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, kSmallModeHeight +
-                            OutputConfigurator::kVerticalGap, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  GetFramebufferAction(kBigMode.get_size().width(),
+                                       kSmallMode.get_size().height() +
+                                           kBigMode.get_size().height() +
+                                           OutputConfigurator::kVerticalGap,
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kBigMode).c_str(),
+                  GetConfigureAction(outputs_[1],
+                                     0,
+                                     kSmallMode.get_size().height() +
+                                         OutputConfigurator::kVerticalGap,
+                                     &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // A change event reporting a mode change on the second output should
   // trigger another reconfigure.
   delegate_->set_max_configurable_pixels(0);
-  test_api_.SendOutputChangeEvent(
-      outputs_[1].output, outputs_[1].crtc, outputs_[1].mirror_mode, true);
+  outputs_[1].set_current_mode(outputs_[1].get_mirror_mode());
+  delegate_->SendOutputChangeEvent(outputs_[1], true);
   EXPECT_TRUE(test_api_.TriggerConfigureTimeout());
-  EXPECT_EQ(JoinActions(kGrab,
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, UpdateCachedOutputsEvenAfterFailure) {
   InitWithSingleOutput();
-  const std::vector<OutputConfigurator::OutputSnapshot>* cached =
-      &test_api_.cached_outputs();
-  ASSERT_EQ(static_cast<size_t>(1), cached->size());
-  EXPECT_EQ(outputs_[0].current_mode, (*cached)[0].current_mode);
+  {
+    const ScopedVector<gfx::DisplaySnapshot>& cached =
+        test_api_.cached_outputs();
+    ASSERT_EQ(static_cast<size_t>(1), cached.size());
+    EXPECT_TRUE(
+        outputs_[0].get_current_mode()->Equals(*cached[0]->get_current_mode()));
+  }
 
   // After connecting a second output, check that it shows up in
   // |cached_outputs_| even if an invalid state is requested.
-  state_controller_.set_state(STATE_SINGLE);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_SINGLE);
   UpdateOutputs(2, true);
-  cached = &test_api_.cached_outputs();
-  ASSERT_EQ(static_cast<size_t>(2), cached->size());
-  EXPECT_EQ(outputs_[0].current_mode, (*cached)[0].current_mode);
-  EXPECT_EQ(outputs_[1].current_mode, (*cached)[1].current_mode);
+  {
+    const ScopedVector<gfx::DisplaySnapshot>& cached =
+        test_api_.cached_outputs();
+    ASSERT_EQ(static_cast<size_t>(2), cached.size());
+    EXPECT_TRUE(
+        outputs_[0].get_current_mode()->Equals(*cached[0]->get_current_mode()));
+    EXPECT_TRUE(
+        outputs_[1].get_current_mode()->Equals(*cached[1]->get_current_mode()));
+  }
 }
 
 TEST_F(OutputConfiguratorTest, PanelFitting) {
   // Configure the internal display to support only the big mode and the
   // external display to support only the small mode.
-  outputs_[0].current_mode = kBigModeId;
-  outputs_[0].native_mode = kBigModeId;
-  outputs_[0].mode_infos.clear();
-  outputs_[0].mode_infos[kBigModeId] = OutputConfigurator::ModeInfo(
-      kBigModeWidth, kBigModeHeight, false, 60.0);
-
-  outputs_[1].current_mode = kSmallModeId;
-  outputs_[1].native_mode = kSmallModeId;
-  outputs_[1].mode_infos.clear();
-  outputs_[1].mode_infos[kSmallModeId] = OutputConfigurator::ModeInfo(
-      kSmallModeWidth, kSmallModeHeight, false, 60.0);
+  outputs_[0].get_mode_infos().clear();
+  outputs_[0].get_mode_infos().push_back(kBigMode.Clone());
+  outputs_[0].set_current_mode(outputs_[0].get_mode_infos().back());
+  outputs_[0].set_native_mode(outputs_[0].get_mode_infos().back());
+
+  outputs_[1].get_mode_infos().clear();
+  outputs_[1].get_mode_infos().push_back(kSmallMode.Clone());
+  outputs_[1].set_current_mode(outputs_[1].get_mode_infos().back());
+  outputs_[1].set_native_mode(outputs_[1].get_mode_infos().back());
 
   // The small mode should be added to the internal output when requesting
   // mirrored mode.
   UpdateOutputs(2, false);
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   configurator_.Init(true /* is_panel_fitting_enabled */);
   configurator_.Start(0);
-  EXPECT_EQ(STATE_DUAL_MIRROR, configurator_.output_state());
-  EXPECT_EQ(JoinActions(kGrab, kInitXRandR,
-                        GetAddOutputModeAction(
-                            outputs_[0].output, kSmallModeId).c_str(),
-                        GetFramebufferAction(kSmallModeWidth, kSmallModeHeight,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kSmallModeId,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kSmallModeId,
-                            outputs_[1].output).c_str(),
-                        kForceDPMS, kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR,
+            configurator_.output_state());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  kInitXRandR,
+                  GetAddOutputModeAction(outputs_[0], kSmallMode).c_str(),
+                  GetFramebufferAction(kSmallMode.get_size().width(),
+                                       kSmallMode.get_size().height(),
+                                       outputs_[0].get_display_id(),
+                                       outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kSmallMode).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kSmallMode).c_str(),
+                  kForceDPMS,
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // Both outputs should be using the small mode.
   ASSERT_EQ(1, observer_.num_changes());
   ASSERT_EQ(static_cast<size_t>(2), observer_.latest_outputs().size());
-  EXPECT_EQ(kSmallModeId, observer_.latest_outputs()[0].mirror_mode);
-  EXPECT_EQ(kSmallModeId, observer_.latest_outputs()[0].current_mode);
-  EXPECT_EQ(kSmallModeId, observer_.latest_outputs()[1].mirror_mode);
-  EXPECT_EQ(kSmallModeId, observer_.latest_outputs()[1].current_mode);
+  EXPECT_TRUE(
+      kSmallMode.Equals(*observer_.latest_outputs()[0]->get_mirror_mode()));
+  EXPECT_TRUE(
+      kSmallMode.Equals(*observer_.latest_outputs()[0]->get_current_mode()));
+  EXPECT_TRUE(
+      kSmallMode.Equals(*observer_.latest_outputs()[1]->get_mirror_mode()));
+  EXPECT_TRUE(
+      kSmallMode.Equals(*observer_.latest_outputs()[1]->get_current_mode()));
 
   // Also check that the newly-added small mode is present in the internal
   // snapshot that was passed to the observer (http://crbug.com/289159).
-  const OutputConfigurator::ModeInfo* info = OutputConfigurator::GetModeInfo(
-      observer_.latest_outputs()[0], kSmallModeId);
+  const gfx::ModeInfo* info =
+      observer_.latest_outputs()[0]->get_mode_infos().back();
   ASSERT_TRUE(info);
-  EXPECT_EQ(kSmallModeWidth, info->width);
-  EXPECT_EQ(kSmallModeHeight, info->height);
+  EXPECT_EQ(kSmallMode.get_size().width(), info->get_size().width());
+  EXPECT_EQ(kSmallMode.get_size().height(), info->get_size().height());
 }
 
 TEST_F(OutputConfiguratorTest, OutputProtection) {
   configurator_.Init(false);
   configurator_.Start(0);
-  EXPECT_NE(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_NE(kNoActions, actions_->GetActionsAndClear());
 
   OutputConfigurator::OutputProtectionClientId id =
       configurator_.RegisterOutputProtectionClient();
@@ -1207,53 +1387,55 @@ TEST_F(OutputConfiguratorTest, OutputProtection) {
 
   // One output.
   UpdateOutputs(1, true);
-  EXPECT_NE(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_NE(kNoActions, actions_->GetActionsAndClear());
   uint32_t link_mask = 0;
   uint32_t protection_mask = 0;
-  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(id,
-                                                        outputs_[0].display_id,
-                                                        &link_mask,
-                                                        &protection_mask));
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_TYPE_INTERNAL), link_mask);
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_PROTECTION_METHOD_NONE),
+  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(
+      id, outputs_[0].get_display_id(), &link_mask, &protection_mask));
+  EXPECT_EQ(
+      static_cast<uint32_t>(gfx::NativeDisplayBridge::OUTPUT_TYPE_INTERNAL),
+      link_mask);
+  EXPECT_EQ(static_cast<uint32_t>(
+                gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE),
             protection_mask);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
   // Two outputs.
   UpdateOutputs(2, true);
-  EXPECT_NE(kNoActions, delegate_->GetActionsAndClear());
-  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(id,
-                                                        outputs_[1].display_id,
-                                                        &link_mask,
-                                                        &protection_mask));
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_TYPE_HDMI),
+  EXPECT_NE(kNoActions, actions_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(
+      id, outputs_[1].get_display_id(), &link_mask, &protection_mask));
+  EXPECT_EQ(static_cast<uint32_t>(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI),
             link_mask);
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_PROTECTION_METHOD_NONE),
+  EXPECT_EQ(static_cast<uint32_t>(
+                gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE),
             protection_mask);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
-  EXPECT_TRUE(
-      configurator_.EnableOutputProtection(id,
-                                           outputs_[1].display_id,
-                                           OUTPUT_PROTECTION_METHOD_HDCP));
-  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1].output, HDCP_STATE_DESIRED),
-            delegate_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.EnableOutputProtection(
+      id,
+      outputs_[1].get_display_id(),
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP));
+  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1],
+                                  gfx::NativeDisplayBridge::HDCP_STATE_DESIRED),
+            actions_->GetActionsAndClear());
 
   // Enable protection.
-  delegate_->set_hdcp_state(HDCP_STATE_ENABLED);
-  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(id,
-                                                        outputs_[1].display_id,
-                                                        &link_mask,
-                                                        &protection_mask));
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_TYPE_HDMI), link_mask);
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_PROTECTION_METHOD_HDCP),
+  delegate_->set_hdcp_state(gfx::NativeDisplayBridge::HDCP_STATE_ENABLED);
+  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(
+      id, outputs_[1].get_display_id(), &link_mask, &protection_mask));
+  EXPECT_EQ(static_cast<uint32_t>(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI),
+            link_mask);
+  EXPECT_EQ(static_cast<uint32_t>(
+                gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP),
             protection_mask);
-  EXPECT_EQ(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_EQ(kNoActions, actions_->GetActionsAndClear());
 
   // Protections should be disabled after unregister.
   configurator_.UnregisterOutputProtectionClient(id);
-  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1].output, HDCP_STATE_UNDESIRED),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(GetSetHDCPStateAction(
+                outputs_[1], gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED),
+            actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, OutputProtectionTwoClients) {
@@ -1266,108 +1448,114 @@ TEST_F(OutputConfiguratorTest, OutputProtectionTwoClients) {
   configurator_.Init(false);
   configurator_.Start(0);
   UpdateOutputs(2, true);
-  EXPECT_NE(kNoActions, delegate_->GetActionsAndClear());
+  EXPECT_NE(kNoActions, actions_->GetActionsAndClear());
 
   // Clients never know state enableness for methods that they didn't request.
-  EXPECT_TRUE(
-      configurator_.EnableOutputProtection(client1,
-                                           outputs_[1].display_id,
-                                           OUTPUT_PROTECTION_METHOD_HDCP));
-  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1].output,
-                                  HDCP_STATE_DESIRED).c_str(),
-            delegate_->GetActionsAndClear());
-  delegate_->set_hdcp_state(HDCP_STATE_ENABLED);
+  EXPECT_TRUE(configurator_.EnableOutputProtection(
+      client1,
+      outputs_[1].get_display_id(),
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP));
+  EXPECT_EQ(
+      GetSetHDCPStateAction(
+          outputs_[1], gfx::NativeDisplayBridge::HDCP_STATE_DESIRED).c_str(),
+      actions_->GetActionsAndClear());
+  delegate_->set_hdcp_state(gfx::NativeDisplayBridge::HDCP_STATE_ENABLED);
 
   uint32_t link_mask = 0;
   uint32_t protection_mask = 0;
-  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(client1,
-                                                        outputs_[1].display_id,
-                                                        &link_mask,
-                                                        &protection_mask));
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_TYPE_HDMI), link_mask);
-  EXPECT_EQ(OUTPUT_PROTECTION_METHOD_HDCP, protection_mask);
-
-  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(client2,
-                                                        outputs_[1].display_id,
-                                                        &link_mask,
-                                                        &protection_mask));
-  EXPECT_EQ(static_cast<uint32_t>(OUTPUT_TYPE_HDMI), link_mask);
-  EXPECT_EQ(OUTPUT_PROTECTION_METHOD_NONE, protection_mask);
+  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(
+      client1, outputs_[1].get_display_id(), &link_mask, &protection_mask));
+  EXPECT_EQ(static_cast<uint32_t>(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI),
+            link_mask);
+  EXPECT_EQ(gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_HDCP,
+            protection_mask);
+
+  EXPECT_TRUE(configurator_.QueryOutputProtectionStatus(
+      client2, outputs_[1].get_display_id(), &link_mask, &protection_mask));
+  EXPECT_EQ(static_cast<uint32_t>(gfx::NativeDisplayBridge::OUTPUT_TYPE_HDMI),
+            link_mask);
+  EXPECT_EQ(gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE,
+            protection_mask);
 
   // Protections will be disabled only if no more clients request them.
-  EXPECT_TRUE(
-      configurator_.EnableOutputProtection(client2,
-                                           outputs_[1].display_id,
-                                           OUTPUT_PROTECTION_METHOD_NONE));
-  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1].output,
-                                  HDCP_STATE_DESIRED).c_str(),
-            delegate_->GetActionsAndClear());
-  EXPECT_TRUE(
-      configurator_.EnableOutputProtection(client1,
-                                           outputs_[1].display_id,
-                                           OUTPUT_PROTECTION_METHOD_NONE));
-  EXPECT_EQ(GetSetHDCPStateAction(outputs_[1].output,
-                                  HDCP_STATE_UNDESIRED).c_str(),
-            delegate_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.EnableOutputProtection(
+      client2,
+      outputs_[1].get_display_id(),
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE));
+  EXPECT_EQ(
+      GetSetHDCPStateAction(
+          outputs_[1], gfx::NativeDisplayBridge::HDCP_STATE_DESIRED).c_str(),
+      actions_->GetActionsAndClear());
+  EXPECT_TRUE(configurator_.EnableOutputProtection(
+      client1,
+      outputs_[1].get_display_id(),
+      gfx::NativeDisplayBridge::OUTPUT_PROTECTION_METHOD_NONE));
+  EXPECT_EQ(
+      GetSetHDCPStateAction(
+          outputs_[1], gfx::NativeDisplayBridge::HDCP_STATE_UNDESIRED).c_str(),
+      actions_->GetActionsAndClear());
 }
 
 TEST_F(OutputConfiguratorTest, CTMForMultiScreens) {
-  outputs_[0].touch_device_id = 1;
-  outputs_[1].touch_device_id = 2;
+  outputs_[0].set_touch_device_id(1);
+  outputs_[1].set_touch_device_id(2);
 
   UpdateOutputs(2, false);
   configurator_.Init(false);
-  state_controller_.set_state(STATE_DUAL_EXTENDED);
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_EXTENDED);
   configurator_.Start(0);
 
-  const int kDualHeight =
-      kSmallModeHeight + OutputConfigurator::kVerticalGap + kBigModeHeight;
-  const int kDualWidth = kBigModeWidth;
+  const int kDualHeight = kSmallMode.get_size().height() +
+                          OutputConfigurator::kVerticalGap +
+                          kBigMode.get_size().height();
+  const int kDualWidth = kBigMode.get_size().width();
 
-  OutputConfigurator::CoordinateTransformation ctm1 = delegate_->get_ctm(1);
-  OutputConfigurator::CoordinateTransformation ctm2 = delegate_->get_ctm(2);
+  gfx::Matrix3F ctm1 = delegate_->get_ctm(1);
+  gfx::Matrix3F ctm2 = delegate_->get_ctm(2);
 
-  EXPECT_EQ(kSmallModeHeight - 1, round((kDualHeight - 1) * ctm1.y_scale));
-  EXPECT_EQ(0, round((kDualHeight - 1) * ctm1.y_offset));
+  EXPECT_EQ(kSmallMode.get_size().height() - 1,
+            round((kDualHeight - 1) * ctm1.get(1, 1)));
+  EXPECT_EQ(0, round((kDualHeight - 1) * ctm1.get(1, 2)));
 
-  EXPECT_EQ(kBigModeHeight - 1, round((kDualHeight - 1) * ctm2.y_scale));
-  EXPECT_EQ(kSmallModeHeight + OutputConfigurator::kVerticalGap,
-            round((kDualHeight - 1) * ctm2.y_offset));
+  EXPECT_EQ(kBigMode.get_size().height() - 1,
+            round((kDualHeight - 1) * ctm2.get(1, 1)));
+  EXPECT_EQ(kSmallMode.get_size().height() + OutputConfigurator::kVerticalGap,
+            round((kDualHeight - 1) * ctm2.get(1, 2)));
 
-  EXPECT_EQ(kSmallModeWidth - 1, round((kDualWidth - 1) * ctm1.x_scale));
-  EXPECT_EQ(0, round((kDualWidth - 1) * ctm1.x_offset));
+  EXPECT_EQ(kSmallMode.get_size().width() - 1,
+            round((kDualWidth - 1) * ctm1.get(0, 0)));
+  EXPECT_EQ(0, round((kDualWidth - 1) * ctm1.get(0, 2)));
 
-  EXPECT_EQ(kBigModeWidth - 1, round((kDualWidth - 1) * ctm2.x_scale));
-  EXPECT_EQ(0, round((kDualWidth - 1) * ctm2.x_offset));
+  EXPECT_EQ(kBigMode.get_size().width() - 1,
+            round((kDualWidth - 1) * ctm2.get(0, 0)));
+  EXPECT_EQ(0, round((kDualWidth - 1) * ctm2.get(0, 2)));
 }
 
 TEST_F(OutputConfiguratorTest, HandleConfigureCrtcFailure) {
   InitWithSingleOutput();
 
-  // kFirstMode represents the first mode in the list and
+  // kModeInfo0 represents the first mode in the list and
   // also the mode that we are requesting the output_configurator
   // to choose.  The test will be setup so that this mode will fail
   // and it will have to choose the next best option.
-  const int kFirstMode = 11;
+  const gfx::ModeInfo kModeInfo0(2560, 1600, false, 60.0);
+  const gfx::ModeInfo kModeInfo1(1024, 768, false, 60.0);
+  const gfx::ModeInfo kModeInfo2(1280, 720, false, 60.0);
+  const gfx::ModeInfo kModeInfo3(1920, 1080, false, 60.0);
+  const gfx::ModeInfo kModeInfo4(1920, 1080, false, 40.0);
 
   // Give the mode_info lists a few reasonable modes.
   for (unsigned int i = 0; i < arraysize(outputs_); i++) {
-    outputs_[i].mode_infos.clear();
-
-    int current_mode = kFirstMode;
-    outputs_[i].mode_infos[current_mode++] = OutputConfigurator::ModeInfo(
-        2560, 1600, false, 60.0);
-    outputs_[i].mode_infos[current_mode++] = OutputConfigurator::ModeInfo(
-        1024, 768, false, 60.0);
-    outputs_[i].mode_infos[current_mode++] = OutputConfigurator::ModeInfo(
-        1280, 720, false, 60.0);
-    outputs_[i].mode_infos[current_mode++] = OutputConfigurator::ModeInfo(
-        1920, 1080, false, 60.0);
-    outputs_[i].mode_infos[current_mode++] = OutputConfigurator::ModeInfo(
-        1920, 1080, false, 40.0);
-
-    outputs_[i].current_mode = kFirstMode;
-    outputs_[i].native_mode = kFirstMode;
+    outputs_[i].get_mode_infos().clear();
+
+    outputs_[i].get_mode_infos().push_back(kModeInfo0.Clone());
+    outputs_[i].get_mode_infos().push_back(kModeInfo1.Clone());
+    outputs_[i].get_mode_infos().push_back(kModeInfo2.Clone());
+    outputs_[i].get_mode_infos().push_back(kModeInfo3.Clone());
+    outputs_[i].get_mode_infos().push_back(kModeInfo4.Clone());
+
+    outputs_[i].set_current_mode(outputs_[i].get_mode_infos().front());
+    outputs_[i].set_native_mode(outputs_[i].get_mode_infos().front());
   }
 
   configurator_.Init(false);
@@ -1376,73 +1564,74 @@ TEST_F(OutputConfiguratorTest, HandleConfigureCrtcFailure) {
   // unrealistic but the want to make sure any assumptions don't
   // creep in.
   delegate_->set_max_configurable_pixels(
-      outputs_[0].mode_infos[kFirstMode + 2].width *
-      outputs_[0].mode_infos[kFirstMode + 2].height);
-  state_controller_.set_state(STATE_SINGLE);
+      outputs_[0].get_mode_infos()[2]->get_size().width() *
+      outputs_[0].get_mode_infos()[2]->get_size().height());
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_SINGLE);
   UpdateOutputs(1, true);
 
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(2560, 1600,
-                            outputs_[0].crtc, 0).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode + 3,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode + 2,
-                            outputs_[0].output).c_str(),
-                        kUngrab, kProjectingOff, NULL),
-            delegate_->GetActionsAndClear());
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(
+                      2560, 1600, outputs_[0].get_display_id(), 0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo3).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo2).c_str(),
+                  kUngrab,
+                  kProjectingOff,
+                  NULL),
+      actions_->GetActionsAndClear());
 
   // This test should attempt to configure a mirror mode that will not succeed
   // and should end up in extended mode.
   delegate_->set_max_configurable_pixels(
-      outputs_[0].mode_infos[kFirstMode + 3].width *
-      outputs_[0].mode_infos[kFirstMode + 3].height);
-  state_controller_.set_state(STATE_DUAL_MIRROR);
+      outputs_[0].get_mode_infos()[3]->get_size().width() *
+      outputs_[0].get_mode_infos()[3]->get_size().height());
+  state_controller_.set_state(gfx::NativeDisplayBridge::STATE_DUAL_MIRROR);
   UpdateOutputs(2, true);
 
-  EXPECT_EQ(JoinActions(kUpdateXRandR, kGrab,
-                        GetFramebufferAction(
-                            outputs_[0].mode_infos[kFirstMode].width,
-                            outputs_[0].mode_infos[kFirstMode].height,
-                            outputs_[0].crtc,
-                            outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc,
-                            0, 0, kFirstMode, outputs_[0].output).c_str(),
-                        // First mode tried is expected to fail and it will
-                        // retry wil the 4th mode in the list.
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode + 3,
-                            outputs_[0].output).c_str(),
-                        // Then attempt to configure crtc1 with the first mode.
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kFirstMode,
-                            outputs_[1].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0, 0, kFirstMode + 3,
-                            outputs_[1].output).c_str(),
-                        // Since it was requested to go into mirror mode
-                        // and the configured modes were different, it
-                        // should now try and setup a valid configurable
-                        // extended mode.
-                        GetFramebufferAction(
-                            outputs_[0].mode_infos[kFirstMode].width,
-                            outputs_[0].mode_infos[kFirstMode].height +
-                              outputs_[1].mode_infos[kFirstMode].height +
-                              OutputConfigurator::kVerticalGap,
-                            outputs_[0].crtc, outputs_[1].crtc).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[0].crtc, 0, 0, kFirstMode + 3,
-                            outputs_[0].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            outputs_[1].mode_infos[kFirstMode].height +
-                              OutputConfigurator::kVerticalGap, kFirstMode,
-                            outputs_[1].output).c_str(),
-                        GetCrtcAction(outputs_[1].crtc, 0,
-                            outputs_[1].mode_infos[kFirstMode].height +
-                              OutputConfigurator::kVerticalGap, kFirstMode + 3,
-                            outputs_[1].output).c_str(),
-                        kUngrab, kProjectingOn, NULL),
-            delegate_->GetActionsAndClear());
-
+  EXPECT_EQ(
+      JoinActions(kGrab,
+                  GetFramebufferAction(
+                      outputs_[0].get_mode_infos()[0]->get_size().width(),
+                      outputs_[0].get_mode_infos()[0]->get_size().height(),
+                      outputs_[0].get_display_id(),
+                      outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo0).c_str(),
+                  // First mode tried is expected to fail and it will
+                  // retry wil the 4th mode in the list.
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo3).c_str(),
+                  // Then attempt to configure crtc1 with the first mode.
+                  GetConfigureAction(outputs_[1], 0, 0, &kModeInfo0).c_str(),
+                  GetConfigureAction(outputs_[1], 0, 0, &kModeInfo3).c_str(),
+                  // Since it was requested to go into mirror mode
+                  // and the configured modes were different, it
+                  // should now try and setup a valid configurable
+                  // extended mode.
+                  GetFramebufferAction(
+                      outputs_[0].get_mode_infos()[0]->get_size().width(),
+                      outputs_[0].get_mode_infos()[0]->get_size().height() +
+                          outputs_[1].get_mode_infos()[0]->get_size().height() +
+                          OutputConfigurator::kVerticalGap,
+                      outputs_[0].get_display_id(),
+                      outputs_[1].get_display_id()).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo0).c_str(),
+                  GetConfigureAction(outputs_[0], 0, 0, &kModeInfo3).c_str(),
+                  GetConfigureAction(
+                      outputs_[1],
+                      0,
+                      outputs_[1].get_mode_infos()[0]->get_size().height() +
+                          OutputConfigurator::kVerticalGap,
+                      &kModeInfo0).c_str(),
+                  GetConfigureAction(
+                      outputs_[1],
+                      0,
+                      outputs_[1].get_mode_infos()[0]->get_size().height() +
+                          OutputConfigurator::kVerticalGap,
+                      &kModeInfo3).c_str(),
+                  kUngrab,
+                  kProjectingOn,
+                  NULL),
+      actions_->GetActionsAndClear());
 }
 
 }  // namespace chromeos
diff --git a/chromeos/display/output_util.cc b/chromeos/display/output_util.cc
index a1485b4..2913982 100644
--- a/chromeos/display/output_util.cc
+++ b/chromeos/display/output_util.cc
@@ -4,12 +4,12 @@
 
 #include "chromeos/display/output_util.h"
 
-#include <X11/extensions/Xrandr.h>
-#include <X11/Xatom.h>
 #include <X11/Xlib.h>
 
 #include "base/strings/string_util.h"
 #include "base/x11/edid_parser_x11.h"
+#include "chromeos/display/native_display_bridge_x11.h"
+#include "ui/gfx/display_snapshot.h"
 
 namespace chromeos {
 namespace {
@@ -39,16 +39,22 @@ bool GetOutputDeviceData(XID output,
 
 }  // namespace
 
-std::string GetDisplayName(XID output_id) {
+std::string GetDisplayName(const gfx::DisplaySnapshot* output) {
+  XID output_id =
+      static_cast<const NativeDisplayBridgeX11::X11DisplaySnapshot*>(output)
+          ->get_output();
   std::string display_name;
   GetOutputDeviceData(output_id, NULL, &display_name);
   return display_name;
 }
 
-bool GetOutputOverscanFlag(XID output, bool* flag) {
+bool GetOutputOverscanFlag(const gfx::DisplaySnapshot* output, bool* flag) {
+  XID output_id =
+      static_cast<const NativeDisplayBridgeX11::X11DisplaySnapshot*>(output)
+          ->get_output();
   unsigned long nitems = 0;
   unsigned char *prop = NULL;
-  if (!base::GetEDIDProperty(output, &nitems, &prop))
+  if (!base::GetEDIDProperty(output_id, &nitems, &prop))
     return false;
 
   bool found = ParseOutputOverscanFlag(prop, nitems, flag);
@@ -56,6 +62,11 @@ bool GetOutputOverscanFlag(XID output, bool* flag) {
   return found;
 }
 
+int64_t GetInternalDisplayId(const gfx::DisplaySnapshot* output) {
+  return static_cast<const NativeDisplayBridgeX11::X11DisplaySnapshot*>(output)
+      ->get_index();
+}
+
 bool ParseOutputOverscanFlag(const unsigned char* prop,
                              unsigned long nitems,
                              bool *flag) {
@@ -140,37 +151,4 @@ bool IsInternalOutputName(const std::string& name) {
       name.find(kInternal_DSI) == 0;
 }
 
-const XRRModeInfo* FindXRRModeInfo(const XRRScreenResources* screen_resources,
-                                   XID current_mode) {
-  for (int m = 0; m < screen_resources->nmode; m++) {
-    XRRModeInfo *mode = &screen_resources->modes[m];
-    if (mode->id == current_mode)
-      return mode;
-  }
-  return NULL;
-}
-
-namespace test {
-
-XRRModeInfo CreateModeInfo(int id,
-                           int width,
-                           int height,
-                           bool interlaced,
-                           float refresh_rate) {
-  XRRModeInfo mode_info = {0};
-  mode_info.id = id;
-  mode_info.width = width;
-  mode_info.height = height;
-  if (interlaced)
-    mode_info.modeFlags = RR_Interlace;
-  if (refresh_rate != 0.0f) {
-    mode_info.hTotal = 1;
-    mode_info.vTotal = 1;
-    mode_info.dotClock = refresh_rate;
-  }
-  return mode_info;
-}
-
-}  // namespace test
-
 }  // namespace chromeos
diff --git a/chromeos/display/output_util.h b/chromeos/display/output_util.h
index 3c7a49f..835209b 100644
--- a/chromeos/display/output_util.h
+++ b/chromeos/display/output_util.h
@@ -13,25 +13,26 @@
 // Forward declarations for Xlib and Xrandr.
 // This is so unused X definitions don't pollute the namespace.
 typedef unsigned long XID;
-typedef XID RRMode;
-struct _XRRModeInfo;
-typedef _XRRModeInfo XRRModeInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
+
+namespace gfx {
+class DisplaySnapshot;
+}
 
 namespace chromeos {
 
 // Generates the human readable string from EDID obtained for |output|.
-CHROMEOS_EXPORT std::string GetDisplayName(XID output);
+CHROMEOS_EXPORT std::string GetDisplayName(const gfx::DisplaySnapshot* output);
 
 // Gets the overscan flag from |output| and stores to |flag|. Returns true if
 // the flag is found. Otherwise returns false and doesn't touch |flag|. The
 // output will produce overscan if |flag| is set to true, but the output may
 // still produce overscan even though it returns true and |flag| is set to
 // false.
-CHROMEOS_EXPORT bool GetOutputOverscanFlag(XID output, bool* flag);
+CHROMEOS_EXPORT bool GetOutputOverscanFlag(const gfx::DisplaySnapshot* output,
+                                           bool* flag);
+
+CHROMEOS_EXPORT int64_t
+    GetInternalDisplayId(const gfx::DisplaySnapshot* output);
 
 // Parses |prop| as EDID data and stores the overscan flag to |flag|. Returns
 // true if the flag is found. This is exported for x11_util_unittest.cc.
@@ -42,32 +43,6 @@ CHROMEOS_EXPORT bool ParseOutputOverscanFlag(const unsigned char* prop,
 // Returns true if an output named |name| is an internal display.
 CHROMEOS_EXPORT bool IsInternalOutputName(const std::string& name);
 
-// Find a XRRModeInfo that matches |mode|.
-CHROMEOS_EXPORT const XRRModeInfo* FindXRRModeInfo(
-    const XRRScreenResources* screen_resources,
-    XID mode);
-
-// Find a mode that matches the given size with highest refresh
-// rate. Non-interlaced mode takes precedence, so non-interlaced mode
-// with a lower refresh rate will be used even if there is an interlaced
-// mode with a higher refresh rate.
-CHROMEOS_EXPORT RRMode FindOutputModeMatchingSize(
-    const XRRScreenResources* screen_resources,
-    const XRROutputInfo* output_info,
-    size_t width,
-    size_t height);
-
-namespace test {
-
-// Creates XRRModeInfo for unit tests.
-CHROMEOS_EXPORT XRRModeInfo CreateModeInfo(int id,
-                                           int width,
-                                           int height,
-                                           bool interlaced,
-                                           float refresh_rate);
-
-}  // namespace test
-
 }  // namespace chromeos
 
 #endif  // CHROMEOS_DISPLAY_OUTPUT_UTIL_H_
diff --git a/chromeos/display/real_output_configurator_delegate.cc b/chromeos/display/real_output_configurator_delegate.cc
deleted file mode 100644
index 38c6471..0000000
--- a/chromeos/display/real_output_configurator_delegate.cc
+++ /dev/null
@@ -1,614 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chromeos/display/real_output_configurator_delegate.h"
-
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-#include <X11/extensions/dpms.h>
-#include <X11/extensions/XInput.h>
-#include <X11/extensions/XInput2.h>
-#include <X11/extensions/Xrandr.h>
-
-#include <cmath>
-#include <set>
-#include <utility>
-
-#include "base/logging.h"
-#include "base/message_loop/message_pump_x11.h"
-#include "base/x11/edid_parser_x11.h"
-#include "base/x11/x11_error_tracker.h"
-#include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/dbus/power_manager_client.h"
-#include "chromeos/display/output_util.h"
-
-namespace chromeos {
-
-namespace {
-
-// DPI measurements.
-const float kMmInInch = 25.4;
-const float kDpi96 = 96.0;
-const float kPixelsToMmScale = kMmInInch / kDpi96;
-
-// Prefixes of output name
-const char kOutputName_VGA[] = "VGA";
-const char kOutputName_HDMI[] = "HDMI";
-const char kOutputName_DVI[] = "DVI";
-const char kOutputName_DisplayPort[] = "DP";
-
-const char kContentProtectionAtomName[] = "Content Protection";
-const char kProtectionUndesiredAtomName[] = "Undesired";
-const char kProtectionDesiredAtomName[] = "Desired";
-const char kProtectionEnabledAtomName[] = "Enabled";
-
-bool IsInternalOutput(const XRROutputInfo* output_info) {
-  return IsInternalOutputName(std::string(output_info->name));
-}
-
-RRMode GetOutputNativeMode(const XRROutputInfo* output_info) {
-  return output_info->nmode > 0 ? output_info->modes[0] : None;
-}
-
-}  // namespace
-
-RealOutputConfiguratorDelegate::RealOutputConfiguratorDelegate()
-    : display_(base::MessagePumpX11::GetDefaultXDisplay()),
-      window_(DefaultRootWindow(display_)),
-      screen_(NULL) {
-}
-
-RealOutputConfiguratorDelegate::~RealOutputConfiguratorDelegate() {
-}
-
-void RealOutputConfiguratorDelegate::InitXRandRExtension(int* event_base) {
-  int error_base_ignored = 0;
-  XRRQueryExtension(display_, event_base, &error_base_ignored);
-}
-
-void RealOutputConfiguratorDelegate::UpdateXRandRConfiguration(
-    const base::NativeEvent& event) {
-  XRRUpdateConfiguration(event);
-}
-
-void RealOutputConfiguratorDelegate::GrabServer() {
-  CHECK(!screen_) << "Server already grabbed";
-  XGrabServer(display_);
-  screen_ = XRRGetScreenResources(display_, window_);
-  CHECK(screen_);
-}
-
-void RealOutputConfiguratorDelegate::UngrabServer() {
-  CHECK(screen_) << "Server not grabbed";
-  XRRFreeScreenResources(screen_);
-  screen_ = NULL;
-  XUngrabServer(display_);
-}
-
-void RealOutputConfiguratorDelegate::SyncWithServer() {
-  XSync(display_, 0);
-}
-
-void RealOutputConfiguratorDelegate::SetBackgroundColor(uint32 color_argb) {
-  // Configuring CRTCs/Framebuffer clears the boot screen image.  Set the
-  // same background color while configuring the display to minimize the
-  // duration of black screen at boot time. The background is filled with
-  // black later in ash::DisplayManager.  crbug.com/171050.
-  XSetWindowAttributes swa = {0};
-  XColor color;
-  Colormap colormap = DefaultColormap(display_, 0);
-  // XColor uses 16 bits per color.
-  color.red = (color_argb & 0x00FF0000) >> 8;
-  color.green = (color_argb & 0x0000FF00);
-  color.blue = (color_argb & 0x000000FF) << 8;
-  color.flags = DoRed | DoGreen | DoBlue;
-  XAllocColor(display_, colormap, &color);
-  swa.background_pixel = color.pixel;
-  XChangeWindowAttributes(display_, window_, CWBackPixel, &swa);
-  XFreeColors(display_, colormap, &color.pixel, 1, 0);
-}
-
-void RealOutputConfiguratorDelegate::ForceDPMSOn() {
-  CHECK(DPMSEnable(display_));
-  CHECK(DPMSForceLevel(display_, DPMSModeOn));
-}
-
-std::vector<OutputConfigurator::OutputSnapshot>
-RealOutputConfiguratorDelegate::GetOutputs() {
-  CHECK(screen_) << "Server not grabbed";
-
-  std::vector<OutputConfigurator::OutputSnapshot> outputs;
-  RRCrtc last_used_crtc = None;
-
-  for (int i = 0; i < screen_->noutput && outputs.size() < 2; ++i) {
-    RROutput output_id = screen_->outputs[i];
-    XRROutputInfo* output_info = XRRGetOutputInfo(display_, screen_, output_id);
-    if (output_info->connection == RR_Connected) {
-      OutputConfigurator::OutputSnapshot output = InitOutputSnapshot(
-          output_id, output_info, &last_used_crtc, i);
-      VLOG(2) << "Found display " << outputs.size() << ":"
-              << " output=" << output.output
-              << " crtc=" << output.crtc
-              << " current_mode=" << output.current_mode;
-      outputs.push_back(output);
-    }
-    XRRFreeOutputInfo(output_info);
-  }
-
-  GetTouchscreens(&outputs);
-  return outputs;
-}
-
-void RealOutputConfiguratorDelegate::AddOutputMode(RROutput output,
-                                                   RRMode mode) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "AddOutputMode: output=" << output << " mode=" << mode;
-  XRRAddOutputMode(display_, output, mode);
-}
-
-bool RealOutputConfiguratorDelegate::ConfigureCrtc(
-    RRCrtc crtc,
-    RRMode mode,
-    RROutput output,
-    int x,
-    int y) {
-  CHECK(screen_) << "Server not grabbed";
-  VLOG(1) << "ConfigureCrtc: crtc=" << crtc
-          << " mode=" << mode
-          << " output=" << output
-          << " x=" << x
-          << " y=" << y;
-  // Xrandr.h is full of lies. XRRSetCrtcConfig() is defined as returning a
-  // Status, which is typically 0 for failure and 1 for success. In
-  // actuality it returns a RRCONFIGSTATUS, which uses 0 for success.
-  return XRRSetCrtcConfig(display_,
-                          screen_,
-                          crtc,
-                          CurrentTime,
-                          x,
-                          y,
-                          mode,
-                          RR_Rotate_0,
-                          (output && mode) ? &output : NULL,
-                          (output && mode) ? 1 : 0) == RRSetConfigSuccess;
-}
-
-void RealOutputConfiguratorDelegate::CreateFrameBuffer(
-    int width,
-    int height,
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  int current_width = DisplayWidth(display_, DefaultScreen(display_));
-  int current_height = DisplayHeight(display_, DefaultScreen(display_));
-  VLOG(1) << "CreateFrameBuffer: new=" << width << "x" << height
-          << " current=" << current_width << "x" << current_height;
-  if (width ==  current_width && height == current_height)
-    return;
-
-  DestroyUnusedCrtcs(outputs);
-  int mm_width = width * kPixelsToMmScale;
-  int mm_height = height * kPixelsToMmScale;
-  XRRSetScreenSize(display_, window_, width, height, mm_width, mm_height);
-}
-
-void RealOutputConfiguratorDelegate::ConfigureCTM(
-    int touch_device_id,
-    const OutputConfigurator::CoordinateTransformation& ctm) {
-  VLOG(1) << "ConfigureCTM: id=" << touch_device_id
-          << " scale=" << ctm.x_scale << "x" << ctm.y_scale
-          << " offset=(" << ctm.x_offset << ", " << ctm.y_offset << ")";
-  int ndevices = 0;
-  XIDeviceInfo* info = XIQueryDevice(display_, touch_device_id, &ndevices);
-  Atom prop = XInternAtom(display_, "Coordinate Transformation Matrix", False);
-  Atom float_atom = XInternAtom(display_, "FLOAT", False);
-  if (ndevices == 1 && prop != None && float_atom != None) {
-    Atom type;
-    int format;
-    unsigned long num_items;
-    unsigned long bytes_after;
-    unsigned char* data = NULL;
-    // Verify that the property exists with correct format, type, etc.
-    int status = XIGetProperty(display_, info->deviceid, prop, 0, 0, False,
-        AnyPropertyType, &type, &format, &num_items, &bytes_after, &data);
-    if (data)
-      XFree(data);
-    if (status == Success && type == float_atom && format == 32) {
-      float value[3][3] = {
-          { ctm.x_scale,         0.0, ctm.x_offset },
-          {         0.0, ctm.y_scale, ctm.y_offset },
-          {         0.0,         0.0,          1.0 }
-      };
-      XIChangeProperty(display_,
-                       info->deviceid,
-                       prop,
-                       type,
-                       format,
-                       PropModeReplace,
-                       reinterpret_cast<unsigned char*>(value),
-                       9);
-    }
-  }
-  XIFreeDeviceInfo(info);
-}
-
-void RealOutputConfiguratorDelegate::SendProjectingStateToPowerManager(
-    bool projecting) {
-  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->
-      SetIsProjecting(projecting);
-}
-
-bool RealOutputConfiguratorDelegate::InitModeInfo(
-    RRMode mode,
-    OutputConfigurator::ModeInfo* mode_info) {
-  DCHECK(mode_info);
-  CHECK(screen_) << "Server not grabbed";
-  // TODO: Determine if we need to organize modes in a way which provides
-  // better than O(n) lookup time.  In many call sites, for example, the
-  // "next" mode is typically what we are looking for so using this
-  // helper might be too expensive.
-  for (int i = 0; i < screen_->nmode; ++i) {
-    if (mode == screen_->modes[i].id) {
-      const XRRModeInfo& info = screen_->modes[i];
-      mode_info->width = info.width;
-      mode_info->height = info.height;
-      mode_info->interlaced = info.modeFlags & RR_Interlace;
-      if (info.hTotal && info.vTotal) {
-        mode_info->refresh_rate = static_cast<float>(info.dotClock) /
-            (static_cast<float>(info.hTotal) *
-             static_cast<float>(info.vTotal));
-      } else {
-        mode_info->refresh_rate = 0.0f;
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
-OutputConfigurator::OutputSnapshot
-RealOutputConfiguratorDelegate::InitOutputSnapshot(
-    RROutput id,
-    XRROutputInfo* info,
-    RRCrtc* last_used_crtc,
-    int index) {
-  OutputConfigurator::OutputSnapshot output;
-  output.output = id;
-  output.width_mm = info->mm_width;
-  output.height_mm = info->mm_height;
-  output.has_display_id = base::GetDisplayId(id, index, &output.display_id);
-  output.index = index;
-  bool is_internal = IsInternalOutput(info);
-
-  // Use the index as a valid display ID even if the internal
-  // display doesn't have valid EDID because the index
-  // will never change.
-  if (!output.has_display_id && is_internal)
-    output.has_display_id = true;
-
-  if (info->crtc) {
-    XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(display_, screen_, info->crtc);
-    output.current_mode = crtc_info->mode;
-    output.x = crtc_info->x;
-    output.y = crtc_info->y;
-    XRRFreeCrtcInfo(crtc_info);
-  }
-
-  // Assign a CRTC that isn't already in use.
-  for (int i = 0; i < info->ncrtc; ++i) {
-    if (info->crtcs[i] != *last_used_crtc) {
-      output.crtc = info->crtcs[i];
-      *last_used_crtc = output.crtc;
-      break;
-    }
-  }
-
-  output.native_mode = GetOutputNativeMode(info);
-  output.is_aspect_preserving_scaling = IsOutputAspectPreservingScaling(id);
-  output.touch_device_id = None;
-
-  for (int i = 0; i < info->nmode; ++i) {
-    const RRMode mode = info->modes[i];
-    OutputConfigurator::ModeInfo mode_info;
-    if (InitModeInfo(mode, &mode_info))
-      output.mode_infos.insert(std::make_pair(mode, mode_info));
-    else
-      LOG(WARNING) << "Unable to find XRRModeInfo for mode " << mode;
-  }
-
-  std::string name(info->name);
-  if (is_internal) {
-    output.type = OUTPUT_TYPE_INTERNAL;
-  } else if (name.find(kOutputName_VGA) == 0) {
-    output.type = OUTPUT_TYPE_VGA;
-  } else if (name.find(kOutputName_HDMI) == 0) {
-    output.type = OUTPUT_TYPE_HDMI;
-  } else if (name.find(kOutputName_DVI) == 0) {
-    output.type = OUTPUT_TYPE_DVI;
-  } else if (name.find(kOutputName_DisplayPort) == 0) {
-    output.type = OUTPUT_TYPE_DISPLAYPORT;
-  } else {
-    LOG(ERROR) << "Unknown link type: " << name;
-    output.type = OUTPUT_TYPE_UNKNOWN;
-  }
-
-  return output;
-}
-
-bool RealOutputConfiguratorDelegate::GetHDCPState(RROutput id,
-                                                  HDCPState* state) {
-  unsigned char* values = NULL;
-  int actual_format = 0;
-  unsigned long nitems = 0;
-  unsigned long bytes_after = 0;
-  Atom actual_type = None;
-  int success = 0;
-  // TODO(kcwu): Use X11AtomCache to save round trip time of XInternAtom.
-  Atom prop = XInternAtom(display_, kContentProtectionAtomName, False);
-
-  bool ok = true;
-  // TODO(kcwu): Move this to x11_util (similar method calls in this file and
-  // output_util.cc)
-  success = XRRGetOutputProperty(display_, id, prop, 0, 100, False,
-                                 False, AnyPropertyType, &actual_type,
-                                 &actual_format, &nitems, &bytes_after,
-                                 &values);
-  if (actual_type == None) {
-    LOG(ERROR) << "Property '" << kContentProtectionAtomName
-               << "' does not exist";
-    ok = false;
-  } else if (success == Success && actual_type == XA_ATOM &&
-             actual_format == 32 && nitems == 1) {
-    Atom value = reinterpret_cast<Atom*>(values)[0];
-    if (value == XInternAtom(display_, kProtectionUndesiredAtomName, False)) {
-      *state = HDCP_STATE_UNDESIRED;
-    } else if (value == XInternAtom(display_, kProtectionDesiredAtomName,
-                                    False)) {
-      *state = HDCP_STATE_DESIRED;
-    } else if (value == XInternAtom(display_, kProtectionEnabledAtomName,
-                                    False)) {
-      *state = HDCP_STATE_ENABLED;
-    } else {
-      LOG(ERROR) << "Unknown " << kContentProtectionAtomName << " value: "
-                 << value;
-      ok = false;
-    }
-  } else {
-    LOG(ERROR) << "XRRGetOutputProperty failed";
-    ok = false;
-  }
-  if (values)
-    XFree(values);
-
-  VLOG(3) << "HDCP state: " << ok << "," << *state;
-  return ok;
-}
-
-bool RealOutputConfiguratorDelegate::SetHDCPState(RROutput id,
-                                                  HDCPState state) {
-  Atom name = XInternAtom(display_, kContentProtectionAtomName, False);
-  Atom value = None;
-  switch (state) {
-    case HDCP_STATE_UNDESIRED:
-      value = XInternAtom(display_, kProtectionUndesiredAtomName, False);
-      break;
-    case HDCP_STATE_DESIRED:
-      value = XInternAtom(display_, kProtectionDesiredAtomName, False);
-      break;
-    default:
-      NOTREACHED() << "Invalid HDCP state: " << state;
-      return false;
-  }
-  base::X11ErrorTracker err_tracker;
-  unsigned char* data = reinterpret_cast<unsigned char*>(&value);
-  XRRChangeOutputProperty(display_, id, name, XA_ATOM, 32,
-                          PropModeReplace, data, 1);
-  if (err_tracker.FoundNewError()) {
-    LOG(ERROR) << "XRRChangeOutputProperty failed";
-    return false;
-  } else {
-    return true;
-  }
-}
-
-void RealOutputConfiguratorDelegate::DestroyUnusedCrtcs(
-    const std::vector<OutputConfigurator::OutputSnapshot>& outputs) {
-  CHECK(screen_) << "Server not grabbed";
-  // Setting the screen size will fail if any CRTC doesn't fit afterwards.
-  // At the same time, turning CRTCs off and back on uses up a lot of time.
-  // This function tries to be smart to avoid too many off/on cycles:
-  // - We disable all the CRTCs we won't need after the FB resize.
-  // - We set the new modes on CRTCs, if they fit in both the old and new
-  //   FBs, and park them at (0,0)
-  // - We disable the CRTCs we will need but don't fit in the old FB. Those
-  //   will be reenabled after the resize.
-  // We don't worry about the cached state of the outputs here since we are
-  // not interested in the state we are setting - we just try to get the CRTCs
-  // out of the way so we can rebuild the frame buffer.
-  for (int i = 0; i < screen_->ncrtc; ++i) {
-    // Default config is to disable the crtcs.
-    RRCrtc crtc = screen_->crtcs[i];
-    RRMode mode = None;
-    RROutput output = None;
-    const OutputConfigurator::ModeInfo* mode_info = NULL;
-    for (std::vector<OutputConfigurator::OutputSnapshot>::const_iterator it =
-         outputs.begin(); it != outputs.end(); ++it) {
-      if (crtc == it->crtc) {
-        mode = it->current_mode;
-        output = it->output;
-        if (mode != None)
-          mode_info = OutputConfigurator::GetModeInfo(*it, mode);
-        break;
-      }
-    }
-
-    if (mode_info) {
-      // In case our CRTC doesn't fit in our current framebuffer, disable it.
-      // It'll get reenabled after we resize the framebuffer.
-      int current_width = DisplayWidth(display_, DefaultScreen(display_));
-      int current_height = DisplayHeight(display_, DefaultScreen(display_));
-      if (mode_info->width > current_width ||
-          mode_info->height > current_height) {
-        mode = None;
-        output = None;
-        mode_info = NULL;
-      }
-    }
-
-    ConfigureCrtc(crtc, mode, output, 0, 0);
-  }
-}
-
-bool RealOutputConfiguratorDelegate::IsOutputAspectPreservingScaling(
-    RROutput id) {
-  bool ret = false;
-
-  Atom scaling_prop = XInternAtom(display_, "scaling mode", False);
-  Atom full_aspect_atom = XInternAtom(display_, "Full aspect", False);
-  if (scaling_prop == None || full_aspect_atom == None)
-    return false;
-
-  int nprop = 0;
-  Atom* props = XRRListOutputProperties(display_, id, &nprop);
-  for (int j = 0; j < nprop && !ret; j++) {
-    Atom prop = props[j];
-    if (scaling_prop == prop) {
-      unsigned char* values = NULL;
-      int actual_format;
-      unsigned long nitems;
-      unsigned long bytes_after;
-      Atom actual_type;
-      int success;
-
-      success = XRRGetOutputProperty(display_, id, prop, 0, 100, False, False,
-          AnyPropertyType, &actual_type, &actual_format, &nitems,
-          &bytes_after, &values);
-      if (success == Success && actual_type == XA_ATOM &&
-          actual_format == 32 && nitems == 1) {
-        Atom value = reinterpret_cast<Atom*>(values)[0];
-        if (full_aspect_atom == value)
-          ret = true;
-      }
-      if (values)
-        XFree(values);
-    }
-  }
-  if (props)
-    XFree(props);
-
-  return ret;
-}
-
-void RealOutputConfiguratorDelegate::GetTouchscreens(
-    std::vector<OutputConfigurator::OutputSnapshot>* outputs) {
-  int ndevices = 0;
-  Atom valuator_x = XInternAtom(display_, "Abs MT Position X", False);
-  Atom valuator_y = XInternAtom(display_, "Abs MT Position Y", False);
-  if (valuator_x == None || valuator_y == None)
-    return;
-
-  std::set<int> no_match_touchscreen;
-  XIDeviceInfo* info = XIQueryDevice(display_, XIAllDevices, &ndevices);
-  for (int i = 0; i < ndevices; i++) {
-    if (!info[i].enabled || info[i].use != XIFloatingSlave)
-      continue;  // Assume all touchscreens are floating slaves
-
-    double width = -1.0;
-    double height = -1.0;
-    bool is_direct_touch = false;
-
-    for (int j = 0; j < info[i].num_classes; j++) {
-      XIAnyClassInfo* class_info = info[i].classes[j];
-
-      if (class_info->type == XIValuatorClass) {
-        XIValuatorClassInfo* valuator_info =
-            reinterpret_cast<XIValuatorClassInfo*>(class_info);
-
-        if (valuator_x == valuator_info->label) {
-          // Ignore X axis valuator with unexpected properties
-          if (valuator_info->number == 0 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            width = valuator_info->max;
-          }
-        } else if (valuator_y == valuator_info->label) {
-          // Ignore Y axis valuator with unexpected properties
-          if (valuator_info->number == 1 && valuator_info->mode == Absolute &&
-              valuator_info->min == 0.0) {
-            height = valuator_info->max;
-          }
-        }
-      }
-#if defined(USE_XI2_MT)
-      if (class_info->type == XITouchClass) {
-        XITouchClassInfo* touch_info =
-            reinterpret_cast<XITouchClassInfo*>(class_info);
-        is_direct_touch = touch_info->mode == XIDirectTouch;
-      }
-#endif
-    }
-
-    // Touchscreens should have absolute X and Y axes,
-    // and be direct touch devices.
-    if (width > 0.0 && height > 0.0 && is_direct_touch) {
-      size_t k = 0;
-      for (; k < outputs->size(); k++) {
-        OutputConfigurator::OutputSnapshot* output = &(*outputs)[k];
-        if (output->native_mode == None || output->touch_device_id != None)
-          continue;
-
-        const OutputConfigurator::ModeInfo* mode_info =
-            OutputConfigurator::GetModeInfo(*output, output->native_mode);
-        if (!mode_info)
-          continue;
-
-        // Allow 1 pixel difference between screen and touchscreen
-        // resolutions.  Because in some cases for monitor resolution
-        // 1024x768 touchscreen's resolution would be 1024x768, but for
-        // some 1023x767.  It really depends on touchscreen's firmware
-        // configuration.
-        if (std::abs(mode_info->width - width) <= 1.0 &&
-            std::abs(mode_info->height - height) <= 1.0) {
-          output->touch_device_id = info[i].deviceid;
-
-          VLOG(2) << "Found touchscreen for output #" << k
-                  << " id " << output->touch_device_id
-                  << " width " << width
-                  << " height " << height;
-          break;
-        }
-      }
-
-      if (k == outputs->size()) {
-        no_match_touchscreen.insert(info[i].deviceid);
-        VLOG(2) << "No matching output for touchscreen"
-                << " id " << info[i].deviceid
-                << " width " << width
-                << " height " << height;
-      }
-
-    }
-  }
-
-  // Sometimes we can't find a matching screen for the touchscreen, e.g.
-  // due to the touchscreen's reporting range having no correlation with the
-  // screen's resolution. In this case, we arbitrarily assign unmatched
-  // touchscreens to unmatched screens.
-  for (std::set<int>::iterator it = no_match_touchscreen.begin();
-       it != no_match_touchscreen.end();
-       it++) {
-    for (size_t i = 0; i < outputs->size(); i++) {
-      if ((*outputs)[i].type != OUTPUT_TYPE_INTERNAL &&
-          (*outputs)[i].native_mode != None &&
-          (*outputs)[i].touch_device_id == None ) {
-        (*outputs)[i].touch_device_id = *it;
-        VLOG(2) << "Arbitrarily matching touchscreen "
-                << (*outputs)[i].touch_device_id << " to output #" << i;
-        break;
-      }
-    }
-  }
-
-  XIFreeDeviceInfo(info);
-}
-
-}  // namespace chromeos
diff --git a/chromeos/display/real_output_configurator_delegate.h b/chromeos/display/real_output_configurator_delegate.h
deleted file mode 100644
index 26940c4..0000000
--- a/chromeos/display/real_output_configurator_delegate.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-#define CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
-
-#include <vector>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "chromeos/display/output_configurator.h"
-
-typedef XID Window;
-
-struct _XDisplay;
-typedef struct _XDisplay Display;
-struct _XRROutputInfo;
-typedef _XRROutputInfo XRROutputInfo;
-struct _XRRScreenResources;
-typedef _XRRScreenResources XRRScreenResources;
-
-namespace chromeos {
-
-class RealOutputConfiguratorDelegate : public OutputConfigurator::Delegate {
- public:
-  RealOutputConfiguratorDelegate();
-  virtual ~RealOutputConfiguratorDelegate();
-
-  // OutputConfigurator::Delegate overrides:
-  virtual void InitXRandRExtension(int* event_base) OVERRIDE;
-  virtual void UpdateXRandRConfiguration(
-      const base::NativeEvent& event) OVERRIDE;
-  virtual void GrabServer() OVERRIDE;
-  virtual void UngrabServer() OVERRIDE;
-  virtual void SyncWithServer() OVERRIDE;
-  virtual void SetBackgroundColor(uint32 color_argb) OVERRIDE;
-  virtual void ForceDPMSOn() OVERRIDE;
-  virtual std::vector<OutputConfigurator::OutputSnapshot> GetOutputs() OVERRIDE;
-  virtual void AddOutputMode(RROutput output, RRMode mode) OVERRIDE;
-  virtual bool ConfigureCrtc(
-      RRCrtc crtc,
-      RRMode mode,
-      RROutput output,
-      int x,
-      int y) OVERRIDE;
-  virtual void CreateFrameBuffer(
-      int width,
-      int height,
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs) OVERRIDE;
-  virtual void ConfigureCTM(
-      int touch_device_id,
-      const OutputConfigurator::CoordinateTransformation& ctm) OVERRIDE;
-  virtual void SendProjectingStateToPowerManager(bool projecting) OVERRIDE;
-  virtual bool GetHDCPState(RROutput id, HDCPState* state) OVERRIDE;
-  virtual bool SetHDCPState(RROutput id, HDCPState state) OVERRIDE;
-
- private:
-  // Initializes |mode_info| to contain details corresponding to |mode|. Returns
-  // true on success.
-  bool InitModeInfo(RRMode mode, OutputConfigurator::ModeInfo* mode_info);
-
-  // Helper method for GetOutputs() that returns an OutputSnapshot struct based
-  // on the passed-in information. Further initialization is required (e.g.
-  // |selected_mode|, |mirror_mode|, and |touch_device_id|).
-  OutputConfigurator::OutputSnapshot InitOutputSnapshot(
-      RROutput id,
-      XRROutputInfo* info,
-      RRCrtc* last_used_crtc,
-      int index);
-
-  // Destroys unused CRTCs and parks used CRTCs in a way which allows a
-  // framebuffer resize. This is faster than turning them off, resizing,
-  // then turning them back on.
-  void DestroyUnusedCrtcs(
-      const std::vector<OutputConfigurator::OutputSnapshot>& outputs);
-
-  // Returns whether |id| is configured to preserve aspect when scaling.
-  bool IsOutputAspectPreservingScaling(RROutput id);
-
-  // Searches for touchscreens among input devices,
-  // and tries to match them up to screens in |outputs|.
-  // |outputs| is an array of detected screens.
-  // If a touchscreen with same resolution as an output's native mode
-  // is detected, its id will be stored in this output.
-  void GetTouchscreens(
-      std::vector<OutputConfigurator::OutputSnapshot>* outputs);
-
-  Display* display_;
-  Window window_;
-
-  // Initialized when the server is grabbed and freed when it's ungrabbed.
-  XRRScreenResources* screen_;
-
-  DISALLOW_COPY_AND_ASSIGN(RealOutputConfiguratorDelegate);
-};
-
-}  // namespace chromeos
-
-#endif  // CHROMEOS_DISPLAY_REAL_OUTPUT_CONFIGURATOR_DELEGATE_H_
diff --git a/ui/gfx/display_snapshot.cc b/ui/gfx/display_snapshot.cc
new file mode 100644
index 0000000..20d5044
--- /dev/null
+++ b/ui/gfx/display_snapshot.cc
@@ -0,0 +1,129 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gfx/display_snapshot.h"
+
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "ui/gfx/mode_info.h"
+
+namespace gfx {
+
+DisplaySnapshot::DisplaySnapshot()
+    : current_mode_(NULL),
+      native_mode_(NULL),
+      mirror_mode_(NULL),
+      selected_mode_(NULL),
+      is_aspect_preserving_scaling_(false),
+      type_(NativeDisplayBridge::OUTPUT_TYPE_UNKNOWN),
+      touch_device_id_(0),
+      display_id_(0),
+      has_display_id_(false),
+      transform_(Matrix3F::Identity()) {}
+
+DisplaySnapshot::DisplaySnapshot(const DisplaySnapshot& other)
+    : origin_(other.origin_),
+      physical_size_(other.physical_size_),
+      current_mode_(NULL),
+      native_mode_(NULL),
+      mirror_mode_(NULL),
+      selected_mode_(NULL),
+      is_aspect_preserving_scaling_(other.is_aspect_preserving_scaling_),
+      type_(other.type_),
+      touch_device_id_(other.touch_device_id_),
+      display_id_(other.display_id_),
+      has_display_id_(other.has_display_id_),
+      transform_(other.transform_) {
+  CopyModes(other);
+}
+
+void DisplaySnapshot::operator=(const DisplaySnapshot& other) {
+  is_aspect_preserving_scaling_ = other.is_aspect_preserving_scaling_;
+  type_ = other.type_;
+  touch_device_id_ = other.touch_device_id_;
+  display_id_ = other.display_id_;
+  has_display_id_ = other.has_display_id_;
+  origin_ = other.origin_;
+  physical_size_ = other.physical_size_;
+  current_mode_ = NULL;
+  native_mode_ = NULL;
+  mirror_mode_ = NULL;
+  selected_mode_ = NULL;
+  transform_ = other.transform_;
+
+  mode_infos_.clear();
+  CopyModes(other);
+}
+
+DisplaySnapshot::~DisplaySnapshot() {}
+
+void DisplaySnapshot::CopyModes(const DisplaySnapshot& other) {
+  for (ScopedVector<ModeInfo>::const_iterator it = other.mode_infos_.begin();
+       it != other.mode_infos_.end();
+       ++it) {
+    mode_infos_.push_back((*it)->Clone());
+
+    if (other.current_mode_ == *it)
+      current_mode_ = mode_infos_.back();
+
+    if (other.native_mode_ == *it)
+      native_mode_ = mode_infos_.back();
+
+    if (other.mirror_mode_ == *it)
+      mirror_mode_ = mode_infos_.back();
+
+    if (other.selected_mode_ == *it)
+      selected_mode_ = mode_infos_.back();
+  }
+}
+
+ModeInfo* DisplaySnapshot::FindOutputModeMatchingSize(int width,
+                                                      int height) const {
+  ScopedVector<ModeInfo>::const_iterator best_mode = mode_infos_.end();
+  for (ScopedVector<ModeInfo>::const_iterator it = mode_infos_.begin();
+       it != mode_infos_.end();
+       ++it) {
+    ModeInfo* info = *it;
+    if (info->get_size().width() != width ||
+        info->get_size().height() != height)
+      continue;
+
+    if (best_mode == mode_infos_.end())
+      best_mode = it;
+
+    if (info->is_interlaced()) {
+      if (!(*best_mode)->is_interlaced())
+        continue;
+    } else {
+      if ((*best_mode)->is_interlaced())
+        best_mode = it;
+    }
+
+    if (info->get_refresh_rate() < (*best_mode)->get_refresh_rate())
+      continue;
+
+    best_mode = it;
+  }
+
+  return best_mode == mode_infos_.end() ? NULL : *best_mode;
+}
+
+DisplaySnapshot* DisplaySnapshot::Clone() const {
+  return new DisplaySnapshot(*this);
+}
+
+std::string DisplaySnapshot::ToString() const {
+  return base::StringPrintf(
+      "[type=%d, mode=%s, dim=%dx%d]",
+      type_,
+      current_mode_ ? current_mode_->ToString().c_str() : "",
+      physical_size_.width(),
+      physical_size_.height());
+}
+
+bool DisplaySnapshot::SameAs(const DisplaySnapshot& display) const {
+  return display_id_ == display.display_id_;
+}
+
+}  // namespace gfx
diff --git a/ui/gfx/display_snapshot.h b/ui/gfx/display_snapshot.h
new file mode 100644
index 0000000..68ddc10
--- /dev/null
+++ b/ui/gfx/display_snapshot.h
@@ -0,0 +1,114 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_DISPLAY_SNAPSHOT_H_
+#define UI_GFX_DISPLAY_SNAPSHOT_H_
+
+#include <map>
+#include <string>
+
+#include "base/basictypes.h"
+#include "ui/gfx/geometry/matrix3_f.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/native_display_bridge.h"
+
+namespace gfx {
+
+class ModeInfo;
+
+// Keeps track of a Display's state. The state includes hardware properties
+// (such as display_id, type, physical size, list of modes) and the current
+// state configured by us (current mode, mirror mode, origin, transformation).
+class GFX_EXPORT DisplaySnapshot {
+ public:
+  DisplaySnapshot();
+  virtual ~DisplaySnapshot();
+
+  virtual DisplaySnapshot* Clone() const;
+  virtual std::string ToString() const;
+
+  // Returns true if this state refers to the same display as |display|. False
+  // otherwise. Note, the states may differ.
+  virtual bool SameAs(const DisplaySnapshot& display) const;
+
+  ModeInfo* FindOutputModeMatchingSize(int width, int height) const;
+
+  Point& get_origin() { return origin_; }
+  const Point& get_origin() const { return origin_; }
+
+  void set_transform(const Matrix3F& transform) { transform_ = transform; }
+  const Matrix3F& get_transform() const { return transform_; }
+
+  void set_physical_size(const Size& size) { physical_size_ = size; }
+  const Size& get_physical_size() const { return physical_size_; }
+
+  ModeInfo* get_current_mode() const { return current_mode_; }
+  void set_current_mode(ModeInfo* mode) { current_mode_ = mode; }
+
+  ModeInfo* get_native_mode() const { return native_mode_; }
+  void set_native_mode(ModeInfo* mode) { native_mode_ = mode; }
+
+  ModeInfo* get_mirror_mode() const { return mirror_mode_; }
+  void set_mirror_mode(ModeInfo* mode) { mirror_mode_ = mode; }
+
+  ModeInfo* get_selected_mode() const { return selected_mode_; }
+  void set_selected_mode(ModeInfo* mode) { selected_mode_ = mode; }
+
+  bool get_is_aspect_preserving_scaling() const {
+    return is_aspect_preserving_scaling_;
+  }
+  void set_is_aspect_preserving_scaling(bool is_preserving) {
+    is_aspect_preserving_scaling_ = is_preserving;
+  }
+
+  void set_type(NativeDisplayBridge::OutputType type) { type_ = type; }
+  NativeDisplayBridge::OutputType get_type() const { return type_; }
+
+  int get_touch_device_id() const { return touch_device_id_; }
+  void set_touch_device_id(int id) { touch_device_id_ = id; }
+
+  int64_t get_display_id() const { return display_id_; }
+  void set_display_id(int64_t display_id) { display_id_ = display_id; }
+
+  bool has_display_id() const { return has_display_id_; }
+  void set_has_display_id(bool state) { has_display_id_ = state; }
+
+  ScopedVector<ModeInfo>& get_mode_infos() { return mode_infos_; }
+  const ScopedVector<ModeInfo>& get_mode_infos() const { return mode_infos_; }
+
+  DisplaySnapshot(const DisplaySnapshot& other);
+  void operator=(const DisplaySnapshot& other);
+
+ protected:
+  void CopyModes(const DisplaySnapshot& other);
+
+ private:
+  Point origin_;
+
+  // Physical size of display in mm.
+  Size physical_size_;
+
+  ModeInfo* current_mode_;
+  ModeInfo* native_mode_;
+  ModeInfo* mirror_mode_;
+  ModeInfo* selected_mode_;
+
+  bool is_aspect_preserving_scaling_;
+
+  NativeDisplayBridge::OutputType type_;
+
+  int touch_device_id_;
+
+  int64_t display_id_;
+  bool has_display_id_;
+
+  Matrix3F transform_;
+
+  ScopedVector<ModeInfo> mode_infos_;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_DISPLAY_SNAPSHOT_H_
diff --git a/ui/gfx/gfx.gyp b/ui/gfx/gfx.gyp
index fc179c1..3700f13 100644
--- a/ui/gfx/gfx.gyp
+++ b/ui/gfx/gfx.gyp
@@ -173,6 +173,8 @@
         'display.h',
         'display_observer.cc',
         'display_observer.h',
+        'display_snapshot.cc',
+        'display_snapshot.h',
         'favicon_size.cc',
         'favicon_size.h',
         'frame_time.h',
@@ -221,6 +223,9 @@
         'linux_font_delegate.cc',
         'linux_font_delegate.h',
         'mac/scoped_ns_disable_screen_updates.h',
+        'mode_info.cc',
+        'mode_info.h',
+        'native_display_bridge.h',
         'native_widget_types.h',
         'nine_image_painter.cc',
         'nine_image_painter.h',
diff --git a/ui/gfx/mode_info.cc b/ui/gfx/mode_info.cc
new file mode 100644
index 0000000..c9ee311
--- /dev/null
+++ b/ui/gfx/mode_info.cc
@@ -0,0 +1,38 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gfx/mode_info.h"
+
+#include "base/strings/stringprintf.h"
+
+namespace gfx {
+
+ModeInfo::ModeInfo() : interlaced_(false), refresh_rate_(0.0) {}
+
+ModeInfo::ModeInfo(int width, int height, bool interlaced, float refresh_rate)
+    : size_(width, height),
+      interlaced_(interlaced),
+      refresh_rate_(refresh_rate) {}
+
+ModeInfo::~ModeInfo() {}
+
+bool ModeInfo::Equals(const ModeInfo& mode) const {
+  return size_ == mode.size_ && interlaced_ == mode.interlaced_ &&
+         refresh_rate_ == mode.refresh_rate_;
+}
+
+ModeInfo* ModeInfo::Clone() const {
+  return new ModeInfo(
+      size_.width(), size_.height(), interlaced_, refresh_rate_);
+}
+
+std::string ModeInfo::ToString() const {
+  return base::StringPrintf("[%dx%d %srate=%f]",
+                            size_.width(),
+                            size_.height(),
+                            interlaced_ ? "interlaced " : "",
+                            refresh_rate_);
+}
+
+}  // namespace gfx
diff --git a/ui/gfx/mode_info.h b/ui/gfx/mode_info.h
new file mode 100644
index 0000000..98cdf3f
--- /dev/null
+++ b/ui/gfx/mode_info.h
@@ -0,0 +1,41 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_MODE_INFO_H_
+#define UI_GFX_MODE_INFO_H_
+
+#include <string>
+
+#include "base/basictypes.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/gfx_export.h"
+
+namespace gfx {
+
+class GFX_EXPORT ModeInfo {
+ public:
+  ModeInfo();
+  ModeInfo(int width, int height, bool interlaced, float refresh_rate);
+
+  virtual ~ModeInfo();
+
+  virtual bool Equals(const ModeInfo& mode) const;
+  virtual ModeInfo* Clone() const;
+  virtual std::string ToString() const;
+
+  Size get_size() const { return size_; }
+  bool is_interlaced() const { return interlaced_; }
+  float get_refresh_rate() const { return refresh_rate_; }
+
+ private:
+  Size size_;
+  bool interlaced_;
+  float refresh_rate_;
+
+  DISALLOW_COPY_AND_ASSIGN(ModeInfo);
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_MODE_INFO_H_
diff --git a/ui/gfx/native_display_bridge.h b/ui/gfx/native_display_bridge.h
new file mode 100644
index 0000000..f0d870e
--- /dev/null
+++ b/ui/gfx/native_display_bridge.h
@@ -0,0 +1,106 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_NATIVE_DISPLAY_BRIDGE_H_
+#define UI_GFX_NATIVE_DISPLAY_BRIDGE_H_
+
+#include "base/memory/scoped_vector.h"
+#include "ui/gfx/gfx_export.h"
+
+namespace gfx {
+
+class DisplaySnapshot;
+class Matrix3F;
+class ModeInfo;
+
+class GFX_EXPORT NativeDisplayBridge {
+ public:
+  enum DPMSState { DPMS_ON, DPMS_OFF };
+
+  // Used to describe the state of a multi-display configuration.
+  enum OutputState {
+    STATE_INVALID,
+    STATE_HEADLESS,
+    STATE_SINGLE,
+    STATE_DUAL_MIRROR,
+    STATE_DUAL_EXTENDED,
+  };
+
+  // Video output types.
+  enum OutputType {
+    OUTPUT_TYPE_NONE = 0,
+    OUTPUT_TYPE_UNKNOWN = 1 << 0,
+    OUTPUT_TYPE_INTERNAL = 1 << 1,
+    OUTPUT_TYPE_VGA = 1 << 2,
+    OUTPUT_TYPE_HDMI = 1 << 3,
+    OUTPUT_TYPE_DVI = 1 << 4,
+    OUTPUT_TYPE_DISPLAYPORT = 1 << 5,
+    OUTPUT_TYPE_NETWORK = 1 << 6,
+  };
+
+  // Content protection methods applied on video output.
+  enum OutputProtectionMethod {
+    OUTPUT_PROTECTION_METHOD_NONE = 0,
+    OUTPUT_PROTECTION_METHOD_HDCP = 1 << 0,
+  };
+
+  // HDCP protection state.
+  enum HDCPState {
+    HDCP_STATE_UNDESIRED,
+    HDCP_STATE_DESIRED,
+    HDCP_STATE_ENABLED
+  };
+
+  class Observer {
+   public:
+    virtual ~Observer() {}
+
+    virtual void OnDisplayChanged() = 0;
+
+    virtual void OnDisplayAdded(const DisplaySnapshot& output) = 0;
+
+    virtual void OnDisplayRemoved(const DisplaySnapshot& output) = 0;
+  };
+
+  virtual ~NativeDisplayBridge() {};
+
+  virtual void Initialize() = 0;
+
+  virtual void Lock() = 0;
+
+  virtual void Unlock() = 0;
+
+  virtual void Flush() = 0;
+
+  virtual void SetBackgroundColor(uint32_t color) = 0;
+
+  virtual void SetDPMS(DPMSState state) = 0;
+
+  virtual void GetOutputs(ScopedVector<DisplaySnapshot>& outputs) = 0;
+
+  virtual bool Configure(const DisplaySnapshot& output) = 0;
+
+  virtual void CreateFrameBuffer(
+      int width,
+      int height,
+      const ScopedVector<DisplaySnapshot>& outputs) = 0;
+
+  virtual void AddMode(const DisplaySnapshot& display,
+                       const ModeInfo& mode) = 0;
+
+  virtual void ConfigureCTM(int touch_device_id, const Matrix3F& ctm) = 0;
+
+  virtual bool GetHDCPState(const DisplaySnapshot& output,
+                            HDCPState* state) = 0;
+
+  virtual bool SetHDCPState(const DisplaySnapshot& output, HDCPState state) = 0;
+
+  virtual void AddObserver(Observer* observer) = 0;
+
+  virtual void RemoveObserver(Observer* observer) = 0;
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_NATIVE_DISPLAY_BRIDGE_H_
-- 
1.7.9.5

